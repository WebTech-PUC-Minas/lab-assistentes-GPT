// Início do arquivo: README.md
## ALGUNS ARQUIVOS INTERESSANTES
* ~/.bash_history      - Lista de comandos executados
* ~/.vimrc             - Configuracoes do VIM
* ~/.profile           - Configuracoes do seu Usuario

## PRINCIPAIS COMANDOS NO VIM
* i                             - Abre o modo de insercao
* ESC                           - Fecha o modo de insercao
* :w                            - Salvar
* :q                            - Sair
* :q!                           - Forcar saida
* :wq!                          - Salvar e forcar a saida
* ? PALAVRA                     - Procurar as ocorrencias de PALAVRA
* :%s/STRING_OLD/STRING_NEW/gc  - Substrituir a STRING_OLD pela STRING_NEW
* yy                            - Copiar linha
* NUMEROyy                      - Copiar NUMERO linhas
* dd                            - Excluir linha
* NUMEROdd                      - Excluir NUMERO linhas
* dw                            - Excluir palavra
* NUMEROdw                      - Excluir NUMERO palavras
* p                             - Colar
* :sp ARQUIVO                   - Abre o arquivo ARQUIVO 
* ww                            - Alternar entre os arquivos abertos
* CTRL+V                        - Abre o modo de visualizacao

## ALGUNS COMANDOS PARA O MODO SHELL DO LINUX
* man
* exit
* cd
* ls
* ls -l -t -h
* rm
* cp
* mkdir
* clear
* grep
* grep "PALAVRA" ARQUIVO
* diff
* diff ARQUIVO1 ARQUIVO2
* ssh
* sftp
* wget
* chmod
* javac
* java
* tar -zcvf arquivo.tar.gz pasta
* tar -zxvf arquivo.tar.gz

## COMPILAR E EXECUTAR PROGRAMA JAVA EM LINHA DE COMANDO

1) Compilar: 
>      javac Programa.java

2) Executar: 
>      java Programa

3) Executar alterando entrada padrao: 
>      java Programa < entrada.in

4) Executar alterando saida padrao: 
>      java Programa > saida.in

5) Executar alterando entrada/saida padrao: 
>      java Programa < entrada.in > saida.in

## COMPILAR E EXECUTAR PROGRAMA C++ EM LINHA DE COMANDO

1) Compilar: 
>      g++ fonte.cc -o objeto

2) Executar: 
>       ./objeto
      
3) Executar alterando entrada padrao: 
>      ./objeto < entrada.in

4) Executar alterando saida padrao: 
>      ./objeto > saida.in

5) Executar alterando entrada/saida padrao: 
>      ./objeto < entrada.in > saida.in

## GDB
1) Chamar o gdb
>     gdb objeto

2) Executar no gdb
>      run

3) Acessar a pilha de chamadas
>      bt

// Fim do arquivo: README.md

--------------------------------------------------------------------------------

// Início do arquivo: Arq.java
import java.io.*;
import java.util.Formatter;
import java.util.Scanner;
import java.io.File;
import java.nio.charset.*;

public class Arq
{
   private static String nomeArquivo = "";
   private static String charsetArquivo = "ISO-8859-1";
   private static boolean write = false, read = false;
   private static Formatter saida = null;
   private static Scanner entrada = null;

	public static boolean openWrite(String nomeArq, String charset) {
      boolean resp = false;
      close();
		try{
		   saida = new Formatter(nomeArq, charset);
         nomeArquivo = nomeArq;
         resp = write = true;
		}  catch (Exception e) {}
      return resp;
   }

	public static boolean openWrite(String nomeArq) {
      return openWrite(nomeArq, charsetArquivo);
   }

	public static boolean openWriteClose(String nomeArq, String charset, String conteudo) {
      boolean resp = openWrite(nomeArq, charset);
      if(resp == true){
         println(conteudo);
         close();
      }
      return resp;
   }

	public static boolean openWriteClose(String nomeArq, String conteudo) {
      return openWriteClose(nomeArq, charsetArquivo, conteudo);
   }

	public static boolean openRead(String nomeArq) {
      return openRead(nomeArq, charsetArquivo);
   }

	public static boolean openRead(String nomeArq, String charset) {
      boolean resp = false;
      close();
		try{
         entrada = new Scanner(new File(nomeArq), charset);
         nomeArquivo = nomeArq;
         resp = read = true;
		}  catch (Exception e) {}
      return resp;
   }

   public static String openReadClose(String nomeArq){
      openRead(nomeArq);
      String resp = readAll();
      close();
      return resp;
   }

	public static void close() {
      if(write == true){
         saida.close();
      }
      if(read == true){
         entrada.close();
      }
      write = read = false;
      nomeArquivo = "";
      charsetArquivo = "ISO-8859-1";
	}

   public static long length(){
      long resp = -1;
      if(read != write){
         File file = new File(nomeArquivo);
         resp = file.length();
      }
      return resp;
   }

   public static void print(int x){
      if(write == true){
		   saida.format( "%d", x);
      }
   }

   public static void print(double x){
      if(write == true){
	   	saida.format( "%f", x);
      }
   }

   public static void print(String x){
      if(write == true){
   		saida.format( "%s", x);
      }
   }

   public static void print(boolean x){
      if(write == true){
		   saida.format( "%s", ((x) ? "true" : "false"));
      }
   }

   public static void print(char x){
      if(write == true){
	   	saida.format( "%c", x);
      }
   }

   public static void println(int x){
      if(write == true){
   		saida.format( "%d\n", x);
      }
   }

   public static void println(double x){
      if(write == true){
		   saida.format( "%f\n", x);
      }
   }

   public static void println(String x){
      if(write == true){
	   	saida.format( "%s\n", x);
      }
   }

   public static void println(boolean x){
      if(write == true){
   		saida.format( "%s\n", ((x) ? "true" : "false"));
      }
   }

   public static void println(char x){
      if(write == true){
		   saida.format( "%c\n", x);
      }
   }

   public static int readInt(){
      int resp = -1;
		try{
         resp = entrada.nextInt();
		}  catch (Exception e) {}
      return resp;
   }

   public static char readChar(){
      char resp = ' ';
		try{
         resp = (char)entrada.nextByte();
		}  catch (Exception e) {}
      return resp;
   }

   public static double readDouble(){
      double resp = -1;
		try{
         resp = Double.parseDouble(readString().replace(",","."));
		}  catch (Exception e) {}
      return resp;
   }

   public static String readString(){
      String resp = "";
		try{
         resp = entrada.next();
		}  catch (Exception e) { System.out.println(e.getMessage()); }
      return resp;
	}

   public static boolean readBoolean(){
      boolean resp = false;
		try{
         resp = (entrada.next().equals("true")) ? true : false;
		}  catch (Exception e) {}
      return resp;
	}

   public static String readLine(){
      String resp = "";
		try{
         resp = entrada.nextLine();
		}  catch (Exception e) { System.out.println(e.getMessage()); }
      return resp;
	}


   public static boolean hasNext(){
      return entrada.hasNext();
   }

   public static String readAll(){
      String resp = "";
      while(hasNext()){
         resp += (readLine() + "\n");
      }
      return resp;
   }
}

// Fim do arquivo: Arq.java

--------------------------------------------------------------------------------

// Início do arquivo: MyIO.java
import java.io.*;
import java.nio.charset.*;

class MyIO {

   private static BufferedReader in = new BufferedReader(new InputStreamReader(System.in, Charset.forName("ISO-8859-1")));
   private static String charset = "ISO-8859-1";

   public static void setCharset(String charset_){
      charset = charset_;
      in = new BufferedReader(new InputStreamReader(System.in, Charset.forName(charset)));
   }

   public static void print(){
   }

   public static void print(int x){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.print(x);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
   }
   
   public static void print(float x){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.print(x);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
   }
   
   public static void print(double x){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.print(x);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
   }

   public static void print(String x){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.print(x);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
   }

   public static void print(boolean x){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.print(x);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
   }

   public static void print(char x){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.print(x);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
   }

   public static void println(){
   }

   public static void println(int x){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.println(x);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
   }

   public static void println(float x){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.println(x);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
   }
   
   public static void println(double x){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.println(x);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
   }

   public static void println(String x){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.println(x);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
   }

   public static void println(boolean x){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.println(x);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
   }

   public static void println(char x){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.println(x);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
   }

   public static void printf(String formato, double x){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.printf(formato, x);// "%.2f"
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
   }

   public static double readDouble(){
      double d = -1;
      try{
         d = Double.parseDouble(readString().trim().replace(",","."));
      }catch(Exception e){}
      return d;
   }

   public static double readDouble(String str){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.print(str);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
      return readDouble();
   }

   public static float readFloat(){
      return (float) readDouble();
   }

   public static float readFloat(String str){
      return (float) readDouble(str);
   }

   public static int readInt(){
      int i = -1;
      try{
         i = Integer.parseInt(readString().trim());
      }catch(Exception e){}
      return i;
   }

   public static int readInt(String str){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.print(str);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
      return readInt();
   }

   public static String readString(){
      String s = "";
      char tmp;
      try{
         do{
            tmp = (char)in.read();
            if(tmp != '\n' && tmp != ' ' && tmp != 13){
               s += tmp;
            }
         }while(tmp != '\n' && tmp != ' ');
      }catch(IOException ioe){
         System.out.println("lerPalavra: " + ioe.getMessage());
      }
      return s;
   }

   public static String readString(String str){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.print(str);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
      return readString();
   }

   public static String readLine(){
      String s = "";
      char tmp;
      try{
         do{
            tmp = (char)in.read();
            if(tmp != '\n' && tmp != 13){
               s += tmp;
            }
         }while(tmp != '\n');
      }catch(IOException ioe){
         System.out.println("lerPalavra: " + ioe.getMessage());
      }
      return s;
   }

   public static String readLine(String str){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.print(str);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
      return readLine();
   }

   public static char readChar(){
      char resp = ' ';
      try{
         resp  = (char)in.read();
      }catch(Exception e){}
      return resp;
   }

   public static char readChar(String str){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.print(str);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
      return readChar();
   }

   public static boolean readBoolean(){
      boolean resp = false;
      String str = "";

      try{
         str = readString();
      }catch(Exception e){}

      if(str.equals("true") || str.equals("TRUE") || str.equals("t") || str.equals("1") || 
            str.equals("verdadeiro") || str.equals("VERDADEIRO") || str.equals("V")){
         resp = true;
            }

      return resp;
   }

   public static boolean readBoolean(String str){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.print(str);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
      return readBoolean();
   }

   public static void pause(){
      try{
         in.read();
      }catch(Exception e){}
   }

   public static void pause(String str){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.print(str);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
      pause();
   }
}

// Fim do arquivo: MyIO.java

--------------------------------------------------------------------------------

// Início do arquivo: ExemploURL.java
import java.io.*;
import java.net.*;

class ExemploURL {
   public static String getHtml(String endereco){
      URL url;
      InputStream is = null;
      BufferedReader br;
      String resp = "", line;

      try {
         url = new URL(endereco);
         is = url.openStream();  // throws an IOException
         br = new BufferedReader(new InputStreamReader(is));

         while ((line = br.readLine()) != null) {
            resp += line + "\n";
         }
      } catch (MalformedURLException mue) {
         mue.printStackTrace();
      } catch (IOException ioe) {
         ioe.printStackTrace();
      } 

      try {
         is.close();
      } catch (IOException ioe) {
         // nothing to see here

      }

      return resp;
   }
   public static void main(String[] args) {
      String endereco, html;
      endereco = "http://maratona.crc.pucminas.br/series/Friends.html";
      html = getHtml(endereco);
      System.out.print(html);
   }
}

// Fim do arquivo: ExemploURL.java

--------------------------------------------------------------------------------

// Início do arquivo: Celula.java
/**
 * Celula (pilha, lista e fila dinamica)
 * @author Max do Val Machado
 * @version 2 01/2015
 */
class Celula {
    public int elemento; // Elemento inserido na celula.
    public Celula prox; // Aponta a celula prox.


    /**
     * Construtor da classe.
     */
    public Celula() {
        this(0);
    }

    /**
     * Construtor da classe.
     * @param elemento int inserido na celula.
     */
    public Celula(int elemento) {
        this.elemento = elemento;
        this.prox = null;
    }
}

// Fim do arquivo: Celula.java

--------------------------------------------------------------------------------

// Início do arquivo: ColetaLixo.java


class ColetaLixo {
    private Celula primeiro;

    public ColetaLixo () {
        primeiro = new Celula();
    }

    public void inserir(int x) {
        primeiro.prox = new Celula(x);
        primeiro = primeiro.prox;
    }

    public static void main (String [] args) {
        ColetaLixo coletaLixo = new ColetaLixo ();
        while(true){
            coletaLixo.inserir(0);
        }
    }
}



// Fim do arquivo: ColetaLixo.java

--------------------------------------------------------------------------------

// Início do arquivo: Celula.java
/**
 * Celula (pilha, lista e fila dinamica)
 * @author Max do Val Machado
 * @version 2 01/2015
 */
class Celula {
	public int elemento; // Elemento inserido na celula.
	public Celula prox; // Aponta a celula prox.


	/**
	 * Construtor da classe.
	 */
	public Celula() {
		this(0);
	}

	/**
	 * Construtor da classe.
	 * @param elemento int inserido na celula.
	 */
	public Celula(int elemento) {
      this.elemento = elemento;
      this.prox = null;
	}
}

// Fim do arquivo: Celula.java

--------------------------------------------------------------------------------

// Início do arquivo: Lista.java
/**
 * Lista dinamica
 * @author Max do Val Machado
 * @version 2 01/2015
 */
class Lista {
	private Celula primeiro;
	private Celula ultimo;


	/**
	 * Construtor da classe que cria uma lista sem elementos (somente no cabeca).
	 */
	public Lista() {
		primeiro = new Celula();
		ultimo = primeiro;
	}


	/**
	 * Insere um elemento na primeira posicao da lista.
    * @param x int elemento a ser inserido.
	 */
	public void inserirInicio(int x) {
		Celula tmp = new Celula(x);
      tmp.prox = primeiro.prox;
		primeiro.prox = tmp;
		if (primeiro == ultimo) {                 
			ultimo = tmp;
		}
      tmp = null;
	}


	/**
	 * Insere um elemento na ultima posicao da lista.
    * @param x int elemento a ser inserido.
	 */
	public void inserirFim(int x) {
		ultimo.prox = new Celula(x);
		ultimo = ultimo.prox;
	}


	/**
	 * Remove um elemento da primeira posicao da lista.
    * @return resp int elemento a ser removido.
	 * @throws Exception Se a lista nao contiver elementos.
	 */
	public int removerInicio() throws Exception {
		if (primeiro == ultimo) {
			throw new Exception("Erro ao remover (vazia)!");
		}

      Celula tmp = primeiro;
		primeiro = primeiro.prox;
		int resp = primeiro.elemento;
      tmp.prox = null;
      tmp = null;
		return resp;
	}


	/**
	 * Remove um elemento da ultima posicao da lista.
    * @return resp int elemento a ser removido.
	 * @throws Exception Se a lista nao contiver elementos.
	 */
	public int removerFim() throws Exception {
		if (primeiro == ultimo) {
			throw new Exception("Erro ao remover (vazia)!");
		} 

		// Caminhar ate a penultima celula:
      Celula i;
      for(i = primeiro; i.prox != ultimo; i = i.prox);

      int resp = ultimo.elemento; 
      ultimo = i; 
      i = ultimo.prox = null;
      
		return resp;
	}


	/**
    * Insere um elemento em uma posicao especifica considerando que o 
    * primeiro elemento valido esta na posicao 0.
    * @param x int elemento a ser inserido.
	 * @param pos int posicao da insercao.
	 * @throws Exception Se <code>posicao</code> invalida.
	 */
   public void inserir(int x, int pos) throws Exception {

      int tamanho = tamanho();

      if(pos < 0 || pos > tamanho){
			throw new Exception("Erro ao inserir posicao (" + pos + " / tamanho = " + tamanho + ") invalida!");
      } else if (pos == 0){
         inserirInicio(x);
      } else if (pos == tamanho){
         inserirFim(x);
      } else {
		   // Caminhar ate a posicao anterior a insercao
         Celula i = primeiro;
         for(int j = 0; j < pos; j++, i = i.prox);
		
         Celula tmp = new Celula(x);
         tmp.prox = i.prox;
         i.prox = tmp;
         tmp = i = null;
      }
   }


	/**
    * Remove um elemento de uma posicao especifica da lista
    * considerando que o primeiro elemento valido esta na posicao 0.
	 * @param posicao Meio da remocao.
    * @return resp int elemento a ser removido.
	 * @throws Exception Se <code>posicao</code> invalida.
	 */
	public int remover(int pos) throws Exception {
      int resp;
      int tamanho = tamanho();

		if (primeiro == ultimo){
			throw new Exception("Erro ao remover (vazia)!");

      } else if(pos < 0 || pos >= tamanho){
			throw new Exception("Erro ao remover (posicao " + pos + " / " + tamanho + " invalida!");
      } else if (pos == 0){
         resp = removerInicio();
      } else if (pos == tamanho - 1){
         resp = removerFim();
      } else {
		   // Caminhar ate a posicao anterior a insercao
         Celula i = primeiro;
         for(int j = 0; j < pos; j++, i = i.prox);
		
         Celula tmp = i.prox;
         resp = tmp.elemento;
         i.prox = tmp.prox;
         tmp.prox = null;
         i = tmp = null;
      }

		return resp;
	}

	/**
	 * Mostra os elementos da lista separados por espacos.
	 */
	public void mostrar() {
		System.out.print("[ ");
		for (Celula i = primeiro.prox; i != null; i = i.prox) {
			System.out.print(i.elemento + " ");
		}
		System.out.println("] ");
	}

	/**
	 * Procura um elemento e retorna se ele existe.
	 * @param x Elemento a pesquisar.
	 * @return <code>true</code> se o elemento existir,
	 * <code>false</code> em caso contrario.
	 */
	public boolean pesquisar(int x) {
		boolean resp = false;
		for (Celula i = primeiro.prox; i != null; i = i.prox) {
         if(i.elemento == x){
            resp = true;
            i = ultimo;
         }
		}
		return resp;
	}

	/**
	 * Calcula e retorna o tamanho, em numero de elementos, da lista.
	 * @return resp int tamanho
	 */
   public int tamanho() {
      int tamanho = 0; 
      for(Celula i = primeiro; i != ultimo; i = i.prox, tamanho++);
      return tamanho;
   }
}

// Fim do arquivo: Lista.java

--------------------------------------------------------------------------------

// Início do arquivo: PrincipalLista.java
/**
 * Lista simples dinamica
 * @author Max do Val Machado
 * @version 2 01/2015
 */
class PrincipalLista {
	public static void main(String[] args) {
		try {
			System.out.println("=== LISTA FLEXIVEL SIMPLESMENTE ENCADEADA ===");
			Lista lista = new Lista();

			lista.inserirInicio(1);
			lista.inserirInicio(0);
			lista.inserirFim(4);
			lista.inserirFim(5);
			lista.inserir(2, 2);
			lista.inserir(3, 3);
			lista.inserir(6, 6);
			lista.inserir(-1, 0);
			lista.inserirFim(7);
			lista.inserirFim(8);

			System.out.print("Apos insercoes: ");
			lista.mostrar();

			int x1 = lista.remover(3);
			int x2 = lista.remover(2);
			int x3 = lista.removerFim();
			int x4 = lista.removerInicio();
			int x5 = lista.remover(0);
			int x6 = lista.remover(4);
			lista.inserirFim(9);

			System.out.print("Apos remocoes (" +x1+ ", " +x2+ ", " +x3+ ", " +x4+ ", " +x5+ ", " +x6+ "): ");
			lista.mostrar();
		}
		catch(Exception erro) {
			System.out.println(erro.getMessage());
		}
	}
}

// Fim do arquivo: PrincipalLista.java

--------------------------------------------------------------------------------

// Início do arquivo: ListaDupla.java
/**
 * Lista dupla dinamica
 * @author Max do Val Machado
 * @version 2 01/2015
 */
class ListaDupla {
	private CelulaDupla primeiro;
	private CelulaDupla ultimo;


	/**
	 * Construtor da classe que cria uma lista dupla sem elementos (somente no cabeca).
	 */
	public ListaDupla() {
		primeiro = new CelulaDupla();
		ultimo = primeiro;
	}


	/**
	 * Insere um elemento na primeira posicao da lista.
    * @param x int elemento a ser inserido.
	 */
	public void inserirInicio(int x) {
		CelulaDupla tmp = new CelulaDupla(x);

      tmp.ant = primeiro;
      tmp.prox = primeiro.prox;
      primeiro.prox = tmp;
      if(primeiro == ultimo){
         ultimo = tmp;
      }else{
         tmp.prox.ant = tmp;
      }
      tmp = null;
	}


	/**
	 * Insere um elemento na ultima posicao da lista.
    * @param x int elemento a ser inserido.
	 */
	public void inserirFim(int x) {
		ultimo.prox = new CelulaDupla(x);
      ultimo.prox.ant = ultimo;
		ultimo = ultimo.prox;
	}


	/**
	 * Remove um elemento da primeira posicao da lista.
    * @return resp int elemento a ser removido.
	 * @throws Exception Se a lista nao contiver elementos.
	 */
	public int removerInicio() throws Exception {
		if (primeiro == ultimo) {
			throw new Exception("Erro ao remover (vazia)!");
		}

      CelulaDupla tmp = primeiro;
		primeiro = primeiro.prox;
		int resp = primeiro.elemento;
      tmp.prox = primeiro.ant = null;
      tmp = null;
		return resp;
	}


	/**
	 * Remove um elemento da ultima posicao da lista.
    * @return resp int elemento a ser removido.
	 * @throws Exception Se a lista nao contiver elementos.
	 */
	public int removerFim() throws Exception {
		if (primeiro == ultimo) {
			throw new Exception("Erro ao remover (vazia)!");
		} 
      int resp = ultimo.elemento;
      ultimo = ultimo.ant;
      ultimo.prox.ant = null;
      ultimo.prox = null;
		return resp;
	}


	/**
    * Insere um elemento em uma posicao especifica considerando que o 
    * primeiro elemento valido esta na posicao 0.
    * @param x int elemento a ser inserido.
	 * @param pos int posicao da insercao.
	 * @throws Exception Se <code>posicao</code> invalida.
	 */
   public void inserir(int x, int pos) throws Exception {

      int tamanho = tamanho();

      if(pos < 0 || pos > tamanho){
			throw new Exception("Erro ao inserir posicao (" + pos + " / tamanho = " + tamanho + ") invalida!");
      } else if (pos == 0){
         inserirInicio(x);
      } else if (pos == tamanho){
         inserirFim(x);
      } else {
		   // Caminhar ate a posicao anterior a insercao
         CelulaDupla i = primeiro;
         for(int j = 0; j < pos; j++, i = i.prox);
		
         CelulaDupla tmp = new CelulaDupla(x);
         tmp.ant = i;
         tmp.prox = i.prox;
         tmp.ant.prox = tmp.prox.ant = tmp;
         tmp = i = null;
      }
   }


	/**
    * Remove um elemento de uma posicao especifica da lista
    * considerando que o primeiro elemento valido esta na posicao 0.
	 * @param posicao Meio da remocao.
    * @return resp int elemento a ser removido.
	 * @throws Exception Se <code>posicao</code> invalida.
	 */
	public int remover(int pos) throws Exception {
      int resp;
      int tamanho = tamanho();

		if (primeiro == ultimo){
			throw new Exception("Erro ao remover (vazia)!");

      } else if(pos < 0 || pos >= tamanho){
			throw new Exception("Erro ao remover (posicao " + pos + " / " + tamanho + " invalida!");
      } else if (pos == 0){
         resp = removerInicio();
      } else if (pos == tamanho - 1){
         resp = removerFim();
      } else {
		   // Caminhar ate a posicao anterior a insercao
         CelulaDupla i = primeiro.prox;
         for(int j = 0; j < pos; j++, i = i.prox);
		
         i.ant.prox = i.prox;
         i.prox.ant = i.ant;
         resp = i.elemento;
         i.prox = i.ant = null;
         i = null;
      }

		return resp;
	}


	/**
	 * Mostra os elementos da lista separados por espacos.
	 */
	public void mostrar() {
		System.out.print("[ "); // Comeca a mostrar.
		for (CelulaDupla i = primeiro.prox; i != null; i = i.prox) {
			System.out.print(i.elemento + " ");
		}
		System.out.println("] "); // Termina de mostrar.
	}


	/**
	 * Mostra os elementos da lista de forma invertida 
    * e separados por espacos.
	 */
	public void mostrarInverso() {
		System.out.print("[ ");
		for (CelulaDupla i = ultimo; i != primeiro; i = i.ant){
			System.out.print(i.elemento + " ");
      }
		System.out.println("] "); // Termina de mostrar.
	}


	/**
	 * Procura um elemento e retorna se ele existe.
	 * @param x Elemento a pesquisar.
	 * @return <code>true</code> se o elemento existir,
	 * <code>false</code> em caso contrario.
	 */
	public boolean pesquisar(int x) {
		boolean resp = false;
		for (CelulaDupla i = primeiro.prox; i != null; i = i.prox) {
         if(i.elemento == x){
            resp = true;
            i = ultimo;
         }
		}
		return resp;
	}

	/**
	 * Calcula e retorna o tamanho, em numero de elementos, da lista.
	 * @return resp int tamanho
	 */
   public int tamanho() {
      int tamanho = 0; 
      for(CelulaDupla i = primeiro; i != ultimo; i = i.prox, tamanho++);
      return tamanho;
   }
}

// Fim do arquivo: ListaDupla.java

--------------------------------------------------------------------------------

// Início do arquivo: CelulaDupla.java
/**
 * Celula Dupla (lista dupla dinamica)
 * @author Max do Val Machado
 * @version 2 01/2015
 */
class CelulaDupla {
	public int elemento;
	public CelulaDupla ant;
	public CelulaDupla prox;

	/**
	 * Construtor da classe.
	 */
	public CelulaDupla() {
		this(0);
	}


	/**
	 * Construtor da classe.
	 * @param elemento int inserido na celula.
	 */
	public CelulaDupla(int elemento) {
		this.elemento = elemento;
		this.ant = this.prox = null;
	}
}

// Fim do arquivo: CelulaDupla.java

--------------------------------------------------------------------------------

// Início do arquivo: PrincipalListaDupla.java
/**
 * Lista dupla dinamica
 * @author Max do Val Machado
 * @version 2 01/2015
 */
class PrincipalListaDupla {
	public static void main(String[] args) {
		try {
			System.out.println("=== LISTA DINAMICA DUPLAMENTE ENCADEADA ===");
			ListaDupla lista = new ListaDupla();

			lista.inserirInicio(1);
			lista.inserirInicio(0);
			lista.inserirFim(4);
			lista.inserirFim(5);
			lista.inserir(2, 2);
			lista.inserir(3, 3);
			lista.inserir(6, 6);
			lista.inserir(-1, 0);
			lista.inserirFim(7);
			lista.inserirFim(8);

			System.out.print("Apos insercoes: ");
			lista.mostrar();

			int x1 = lista.remover(3);
			int x2 = lista.remover(2);
			int x3 = lista.removerFim();
			int x4 = lista.removerInicio();
			int x5 = lista.remover(0);
			int x6 = lista.remover(4);

			System.out.print("Apos remocoes (" +x1+ ", " +x2+ ", " +x3+ ", " +x4+ ", " +x5+ ", " +x6+ "): ");
			lista.mostrar();
		}
		catch(Exception erro) {
			System.out.println(erro.getMessage());
		}
	}
}

// Fim do arquivo: PrincipalListaDupla.java

--------------------------------------------------------------------------------

// Início do arquivo: Fila.java
/**
 * Fila dinamica
 * @author Max do Val Machado
 * @version 2 01/2015
 */
public class Fila {
	private Celula primeiro;
	private Celula ultimo;


	/**
	 * Construtor da classe que cria uma fila sem elementos (somente no cabeca).
	 */
	public Fila() {
		primeiro = new Celula();
		ultimo = primeiro;
	}


	/**
	 * Insere elemento na fila (politica FIFO).
	 * @param x int elemento a inserir.
	 */
	public void inserir(int x) {
		ultimo.prox = new Celula(x);
		ultimo = ultimo.prox;
	}


	/**
	 * Remove elemento da fila (politica FIFO).
	 * @return Elemento removido.
	 * @trhows Exception Se a fila nao tiver elementos.
	 */
	public int remover() throws Exception {
		if (primeiro == ultimo) {
			throw new Exception("Erro ao remover!");
		}

      Celula tmp = primeiro;
		primeiro = primeiro.prox;
		int resp = primeiro.elemento;
      tmp.prox = null;
      tmp = null;
		return resp;
	}


	/**
	 * Mostra os elementos separados por espacos.
	 */
	public void mostrar() {
		System.out.print("[ ");
		
		for(Celula i = primeiro.prox; i != null; i = i.prox) {
			System.out.print(i.elemento + " ");
		}
		
		System.out.println("] ");
	}
}

// Fim do arquivo: Fila.java

--------------------------------------------------------------------------------

// Início do arquivo: PrincipalFila.java
/**
 * Fila dinamica
 * @author Max do Val Machado
 * @version 2 01/2015
 */
class PrincipalFila {
   public static void main(String[] args) throws Exception {
      System.out.println("==== FILA FLEXIVEL ====");
      Fila fila = new Fila();
      int x1, x2, x3;

      fila.inserir(5);
      fila.inserir(7);
      fila.inserir(8);
      fila.inserir(9);

      System.out.println("Apos insercoes(5, 7, 8, 9): ");
      fila.mostrar();

      x1 = fila.remover();
      x2 = fila.remover();

      System.out.println("Apos remocoes (" + x1 + ", " + x2 + "):");
      fila.mostrar();

      fila.inserir(3);
      fila.inserir(4);


      System.out.println("Apos insercoes(3, 4): ");
      fila.mostrar();

      x1 = fila.remover();
      x2 = fila.remover();
      x3 = fila.remover();

      System.out.println("Apos remocoes (" + x1 + ", " + x2 + ", " + x3 + "):");
      fila.mostrar();

      fila.inserir(4);
      fila.inserir(5);

      System.out.println("Apos insercoes(4, 5): ");
      fila.mostrar();

      x1 = fila.remover();
      x2 = fila.remover();

      System.out.println("Apos remocoes (" + x1 + ", " + x2 + "):");
      fila.mostrar();

      fila.inserir(6);
      fila.inserir(7);

      System.out.println("Apos insercoes(6, 7): ");
      fila.mostrar();

      x1 = fila.remover();

      System.out.println("Apos remocao (" + x1 + "): ");
      fila.mostrar();
   }
}

// Fim do arquivo: PrincipalFila.java

--------------------------------------------------------------------------------

// Início do arquivo: Celula.java
/**
 * Celula (pilha, lista e fila dinamica)
 * @author Max do Val Machado
 * @version 2 01/2015
 */
class Celula {
	public int elemento; // Elemento inserido na celula.
	public Celula prox; // Aponta a celula prox.


	/**
	 * Construtor da classe.
	 */
	public Celula() {
		this(0);
	}

	/**
	 * Construtor da classe.
	 * @param elemento int inserido na celula.
	 */
	public Celula(int elemento) {
      this.elemento = elemento;
      this.prox = null;
	}
}

// Fim do arquivo: Celula.java

--------------------------------------------------------------------------------

// Início do arquivo: Celula.java
class Celula {
   public int elemento;
   public Celula inf, sup, esq, dir;

   public Celula(){
      this(0);
   }

   public Celula(int elemento){
      this(elemento, null, null, null, null);
   }

   public Celula(int elemento, Celula inf, Celula sup, Celula esq, Celula dir){
      this.elemento = elemento;
      this.inf = inf;
      this.sup = sup;
      this.esq = esq;
      this.dir = dir;
   }
}

// Fim do arquivo: Celula.java

--------------------------------------------------------------------------------

// Início do arquivo: entrada.in
quantidade de testes (por exemplo, 3)
linhas da primeira matriz do primeiro teste
colunas da primeira matriz do primeiro teste
x x x x x ... x
x x x x x ... x
...
x x x x x ... x
linhas da segunda matriz do primeiro teste
colunas da segunda matriz do primeiro teste
x x x x x ... x
x x x x x ... x
...
x x x x x ... x
linhas da primeira matriz do segundo teste
colunas da primeira matriz do segundo teste
x x x x x ... x
x x x x x ... x
...
x x x x x ... x
linhas da segunda matriz do segundo teste
colunas da segunda matriz do segundo teste
x x x x x ... x
x x x x x ... x
...
x x x x x ... x
linhas da primeira matriz do terceiro teste
colunas da primeira matriz do terceiro teste
x x x x x ... x
x x x x x ... x
...
x x x x x ... x
linhas da segunda matriz do terceiro teste
colunas da segunda matriz do terceiro teste
x x x x x ... x
x x x x x ... x
...
x x x x x ... x

// Fim do arquivo: entrada.in

--------------------------------------------------------------------------------

// Início do arquivo: Principal.java
class Principal {

   public static void main(String[] args){
      Matriz m1, m2, soma, m3, m4, multiplicao;

      m1 = new Matriz(MyIO.readInt("Digite o numero de linhas (M1): "), MyIO.readInt("Digite o numero de colunas (M1): "));
      m2 = new Matriz(MyIO.readInt("Digite o numero de linhas (M2): "), MyIO.readInt("Digite o numero de colunas (M2): "));
      m3 = new Matriz(MyIO.readInt("Digite o numero de linhas (M3): "), MyIO.readInt("Digite o numero de colunas (M3): "));
      m4 = new Matriz(MyIO.readInt("Digite o numero de linhas (M4): "), MyIO.readInt("Digite o numero de colunas (M4): "));


      m1.ler();
      m2.ler();
      m3.ler();
      m4.ler();

      //Somar as duas matrizes e salvar o resultado na matriz soma
      soma = m1.soma(m2); //verifique se eh possivel somar

      //Imprimir a matriz 1
      soma.print();

      //Multiplicar duas matrizes e salvar o resultado na matriz multiplicacao
      multiplicacao = m3.multiplicacao(m4); //verifique se eh possivel multiplicar

      //Imprimir a matriz 1
      multiplicacao.print();

   }
}

// Fim do arquivo: Principal.java

--------------------------------------------------------------------------------

// Início do arquivo: Matriz.java
class Matriz {
   private Celula inicio;
   private int linha, coluna;

   public Matriz (){
      Matriz(3, 3);
   }

   public Matriz (int linha, int coluna){
      this.linha = linha;
      this.coluna = coluna;

      //alocar a matriz com this.linha linhas e this.coluna colunas
   }


   public Matriz soma (Matriz m) {
      Matriz resp = null;

      if(this.linha == m.linha && this.coluna == m.coluna){
         resp = new Matriz(this.linha, this.coluna);
         for(){
            for(){
               //sendo c (pont em resp), a (em this) e b (em m)
               c.elemento = a.elemento + b.elemento;
            }
         }
         //...
      }

      return resp;
   }

   public Matriz multiplicacao (Matriz m) {
      Matriz resp = null;

      if(){
         //...
      }

      return resp;
   }

   public boolean isQuadrada(){
      boolean (this.linha == this.coluna);
   }

   public void mostrarDiagonalPrincipal (){
      if(isQuadrada() == true){

      }
   }

   public void mostrarDiagonalSecundaria (){
      if(isQuadrada() == true){
      }
   }
}

// Fim do arquivo: Matriz.java

--------------------------------------------------------------------------------

// Início do arquivo: Pilha.java
/**
 * Pilha dinamica
 * 
 * @author Max do Val Machado
 * @version 2 01/2015
 */
public class Pilha {
	private Celula topo;

	/**
	 * Construtor da classe que cria uma fila sem elementos.
	 */
	public Pilha() {
		topo = null;
	}

	/**
	 * Insere elemento na pilha (politica FILO).
	 * 
	 * @param x int elemento a inserir.
	 */
	public void inserir(int x) {
		Celula tmp = new Celula(x);
		tmp.prox = topo;
		topo = tmp;
		tmp = null;
	}

	/**
	 * Remove elemento da pilha (politica FILO).
	 * 
	 * @return Elemento removido.
	 * @trhows Exception Se a sequencia nao contiver elementos.
	 */
	public int remover() throws Exception {
		if (topo == null) {
			throw new Exception("Erro ao remover!");
		}
		int resp = topo.elemento;
		Celula tmp = topo;
		topo = topo.prox;
		tmp.prox = null;
		tmp = null;
		return resp;
	}

	/**
	 * Mostra os elementos separados por espacos, comecando do topo.
	 */
	public void mostrar() {
		System.out.print("[ ");
		for (Celula i = topo; i != null; i = i.prox) {
			System.out.print(i.elemento + " ");
		}
		System.out.println("] ");
	}

	public int getSoma() {
		return getSoma(topo);
	}

	private int getSoma(Celula i) {
		int resp = 0;
		if (i != null) {
			resp += i.elemento + getSoma(i.prox);
		}
		return resp;
	}

	public int getMax() {
		int max = topo.elemento;
		for (Celula i = topo.prox; i != null; i = i.prox) {
			if (i.elemento > max)
				max = i.elemento;
		}
		return max;
	}

	public void mostraPilha() {
		mostraPilha(topo);
	}

	private void mostraPilha(Celula i) {
		if (i != null) {
			mostraPilha(i.prox);
			System.out.println("" + i.elemento);
		}
	}

}

// Fim do arquivo: Pilha.java

--------------------------------------------------------------------------------

// Início do arquivo: Celula.java
/**
 * Celula (pilha, lista e fila dinamica)
 * @author Max do Val Machado
 * @version 2 01/2015
 */
class Celula {
	public int elemento; // Elemento inserido na celula.
	public Celula prox; // Aponta a celula prox.


	/**
	 * Construtor da classe.
	 */
	public Celula() {
		this(0);
	}

	/**
	 * Construtor da classe.
	 * @param elemento int inserido na celula.
	 */
	public Celula(int elemento) {
      this.elemento = elemento;
      this.prox = null;
	}
}

// Fim do arquivo: Celula.java

--------------------------------------------------------------------------------

// Início do arquivo: PrincipalPilha.java
/**
 * Pilha dinamica
 * @author Max do Val Machado
 * @version 2 01/2015
 */
public class PrincipalPilha {
	public static void main(String[] args) {
		try {
			System.out.println(" ==== PILHA FLEXIVEL ====");
			Pilha pilha = new Pilha();
         int x1, x2, x3;

			pilha.inserir(0);
			pilha.inserir(1);
			pilha.inserir(2);
			pilha.inserir(3);
			pilha.inserir(4);
			pilha.inserir(5);

			System.out.print("Apos insercoes: ");
			pilha.mostrar();

			x1 = pilha.remover();
			x2 = pilha.remover();
			x3 = pilha.remover();

			System.out.print("Apos as remocoes (" + x1 + "," + x2 + "," + x3 + "): ");
			pilha.mostrar();

		}
		catch(Exception erro) {
			System.out.println(erro.getMessage());
		}
	}
}

// Fim do arquivo: PrincipalPilha.java

--------------------------------------------------------------------------------

// Início do arquivo: ListaNativa.java
import java.util.Vector;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Iterator;

class ListaNativa {
   public static void main (String [] args) {
      Vector<String> vector = new Vector<String>();
      ArrayList<String> arrayList = new ArrayList<String>();
      LinkedList<String> linkedList = new LinkedList<String>();

      vector.add("Atlético-MG");
      arrayList.add("Atlético-MG");
      linkedList.add("Atlético-MG");
      vector.add("Cruzeiro");
      arrayList.add("Cruzeiro");
      linkedList.add("Cruzeiro");
      vector.add("América");
      arrayList.add("América");
      linkedList.add("América");

      System.out.println("Tamanhos:" + vector.size() + " -- " + arrayList.size() + " -- " + linkedList.size());
      System.out.println("get(index): " + (String)vector.get(0) + " -- " + (String)arrayList.get(1) + " -- " + (String)linkedList.get(2));

      for (Iterator i = vector.iterator(); i.hasNext();){
         System.out.println("Vector: " + (String)i.next());
      }
      for (Iterator i = arrayList.iterator(); i.hasNext();){
         System.out.println("ArrayList: " + (String)i.next());
      }
      for (Iterator i = linkedList.iterator(); i.hasNext();){
         System.out.println("LinkedList: " + (String)i.next());
      }
   }
}


// Fim do arquivo: ListaNativa.java

--------------------------------------------------------------------------------

// Início do arquivo: FilaNativa.java
import java.util.*;

public class FilaNativa {
   public static void main(String[] args) throws Exception {
      Queue<String> fila = new LinkedList<String>();

      fila.add("Atlético-MG");
      fila.add("Cruzeiro");
      fila.add("América");

      while (!fila.isEmpty()){
         System.out.println("Retirando da fila: " + fila.remove());
      }
   }
}


// Fim do arquivo: FilaNativa.java

--------------------------------------------------------------------------------

// Início do arquivo: PilhaNativa.java
import java.util.Stack;

class PilhaNativa {
   public static void main (String [] args) {
      Stack<String> pilha = new Stack<String>();

      pilha.push("Atlético-MG");
      pilha.push("Cruzeiro");
      pilha.push("América");

      while(pilha.empty() == false){
        System.out.println("Retirando da pilha: " + pilha.pop());
      }
   }
}

// Fim do arquivo: PilhaNativa.java

--------------------------------------------------------------------------------

// Início do arquivo: celula.h
 #ifndef CELULA_H
 #define CELULA_H
 //=============================================================================
#include <stdio.h>
#include <stdlib.h>
 //=============================================================================
typedef struct Celula{
    int elemento;
    struct Celula *prox;
}Celula;
//=============================================================================
Celula* new_celula(int elemento){
    Celula *temp = (Celula*)malloc(sizeof(Celula));
    temp->elemento = elemento;
    temp->prox = NULL;
    return temp;
}
 //=============================================================================
 typedef struct CelulaDupla{
    int elemento;
    struct CelulaDupla *prox, *ant;
}CelulaDupla;
//=============================================================================
CelulaDupla* new_celula_dupla(int elemento){
    CelulaDupla *temp = (CelulaDupla*)malloc(sizeof(CelulaDupla));
    temp->elemento = elemento;
    temp->ant = NULL;
    temp->prox = NULL;
    return temp;
}
 //=============================================================================
#endif
// Fim do arquivo: celula.h

--------------------------------------------------------------------------------

// Início do arquivo: lista_teste.c
#include "lista.h"
//=============================================================================
int main() {

    Lista l;
    int i, x1, x2, x3;
    printf("==== LISTA FLEXIVEL ====\n");

    l = new_lista();

    for(i=0; i < 5; i++)
        insert_end(&l, i);

    printf("Apos inserir os dados: \n");
    print_lista(&l);

    printf("Apos inserir no inicio: \n");
    insert_begin(&l, i++);
    print_lista(&l);

    printf("Apos inserir no final: \n");
    insert_end(&l, i++);
    print_lista(&l);

    printf("Apos inserir na posicao 4: \n");
    insert_at(&l, i++, 4);
    print_lista(&l);

    printf("Apos remover no inicio: \n");
    x1 = remove_begin(&l);
    print_lista(&l);

    printf("Apos remover no final: \n");
    x1 = remove_end(&l);
    print_lista(&l);

    printf("Apos remover na posicao 2: \n");
    x1 = remove_at(&l, 2);
    print_lista(&l);

    delete_lista(&l);

    return 0;
}
// Fim do arquivo: lista_teste.c

--------------------------------------------------------------------------------

// Início do arquivo: pilha_teste.c
#include "pilha.h"
//=============================================================================
int main() {

    Pilha p;
    int i, x1, x2, x3;
    printf("==== PILHA FLEXIVEL ====\n");

    p = new_pilha();

    for(i=0; i < 10; i++)
        push_pilha(&p, i);

    printf("Apos inserrir os dados: \n");
    print_pilha(&p);

    x1 = pop_pilha(&p);
    x2 = pop_pilha(&p);
    x3 = pop_pilha(&p);

    printf("Apos as remocoes (%d, %d, %d) \n", x1, x2, x3);
    print_pilha(&p);

    delete_pilha(&p);

    return 0;
}
// Fim do arquivo: pilha_teste.c

--------------------------------------------------------------------------------

// Início do arquivo: lista_dupla_teste.c
#include "lista_dupla.h"
//=============================================================================
int main() {

    ListaDupla l;
    int i, x1, x2, x3;
    printf("==== LISTA FLEXIVEL ====\n");

    l = new_lista_dupla();

    for(i=0; i < 5; i++)
        insert_end_dupla(&l, i);

    printf("Apos inserir os dados: \n");
    print_lista_dupla(&l);
    print_lista_dupla_inverso(&l);

    printf("Apos inserir no inicio: \n");
    insert_begin_dupla(&l, i++);
    print_lista_dupla(&l);
    print_lista_dupla_inverso(&l);

    printf("Apos inserir no final: \n");
    insert_end_dupla(&l, i++);
    print_lista_dupla(&l);
    print_lista_dupla_inverso(&l);

    printf("Apos inserir na posicao 4: \n");
    insert_at_dupla(&l, i++, 4);
    print_lista_dupla(&l);
    print_lista_dupla_inverso(&l);

    printf("Apos remover no inicio: \n");
    x1 = remove_begin_dupla(&l);
    print_lista_dupla(&l);
    print_lista_dupla_inverso(&l);

    printf("Apos remover no final: \n");
    x1 = remove_end_dupla(&l);
    print_lista_dupla(&l);
    print_lista_dupla_inverso(&l);

    printf("Apos remover na posicao 2: \n");
    x1 = remove_at_dupla(&l, 2);
    print_lista_dupla(&l);
    print_lista_dupla_inverso(&l);

    delete_lista_dupla(&l);

    return 0;
}
// Fim do arquivo: lista_dupla_teste.c

--------------------------------------------------------------------------------

// Início do arquivo: lista_dupla.h
#ifndef LISTADUPLA_H
#define LISTADUPLA_H
//=============================================================================
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <limits.h>
#include "celula.h"
//=============================================================================
typedef struct ListaDupla{
    struct CelulaDupla *primeiro, *ultimo;
    int size;
} ListaDupla;
//=============================================================================
ListaDupla new_lista_dupla(){
    ListaDupla temp;
    temp.primeiro = temp.ultimo = new_celula_dupla(-1);
    temp.size = 0;
    return temp;
}
//=============================================================================
int size_lista_dupla(ListaDupla *l){
    return l->size;
}
//=============================================================================
void insert_begin_dupla(ListaDupla *l, int elemento){
    
    CelulaDupla *temp = new_celula_dupla(-1);
    temp->prox = l->primeiro;

    l->primeiro->elemento = elemento; 
    l->primeiro->ant = temp;   
    l->primeiro = temp;
    l->size++;
}
//=============================================================================
void insert_end_dupla(ListaDupla *l, int elemento){    
    l->ultimo->prox = new_celula_dupla(elemento);
    l->ultimo->prox->ant = l->ultimo;
    l->ultimo = l->ultimo->prox;
    l->size++;
}
//=============================================================================
void insert_at_dupla(ListaDupla *l, int elemento, int pos){
    
    if(pos < 0 || pos > l->size)
        printf("Erro ao tentar inserir na posicao (%d/ tamanho = %d) invalida!", pos, l->size);
    else if (pos == 0)
        insert_begin_dupla(l, elemento);
    else if (pos == l->size)
        insert_end_dupla(l, elemento);
    else{
        
        CelulaDupla *ant = l->primeiro;
        for(int i=0; i<pos;i++) 
            ant = ant->prox;
            
        CelulaDupla *temp = new_celula_dupla(elemento);  
        temp->prox = ant->prox;
        temp->prox->ant = temp;
        temp->ant = ant;
        ant->prox = temp;
        l->size++;
    }
}
//=============================================================================
int remove_end_dupla(ListaDupla *l){

    if(l->primeiro == l->ultimo){
        printf("\nA lista esta vazia!\n");
        return INT_MIN;
    }
    
    CelulaDupla *temp = l->ultimo;
    int elemento = temp->elemento;

    l->ultimo = l->ultimo->ant;
    l->ultimo->prox = NULL;
    l->size--;

    free(temp);
    
    return elemento;
}
//=============================================================================
int remove_at_dupla(ListaDupla *l, int pos){

    if(l->primeiro == l->ultimo){
        printf("\nA lista esta vazia!\n");
        return INT_MIN;
    }else if(pos < 0 || pos > l->size-1)
        printf("Erro ao tentar remover item da posicao (%d/ tamanho = %d) invalida!", pos, l->size);
    else if(pos == l->size-1)
        remove_end_dupla(l);
    else{
        
        CelulaDupla *ant = l->primeiro;
        for(int i=0; i<pos;i++) 
            ant = ant->prox;
            
        CelulaDupla *temp = ant->prox;  
        int elemento = temp->elemento;

        temp->prox->ant = ant;
        ant->prox = temp->prox;
        free(temp);       

        l->size--;

        return elemento;
    }
}
//=============================================================================
int remove_begin_dupla(ListaDupla *l){
    return remove_at_dupla(l, 0);
}
//=============================================================================
bool pesquisar_lista_dupla(ListaDupla *l, int elemento){
    CelulaDupla *i;
    for (i = l->primeiro->prox; i != NULL; i = i->prox)
        if(i->elemento == elemento)
            return true;
    return false;
}
//=============================================================================
void print_lista_dupla(ListaDupla *l){
    CelulaDupla *i;
    printf("[");
    for (i = l->primeiro->prox; i != NULL; i = i->prox)
    {
        printf("%d, ", i->elemento);
    }
    printf("] \n");
}
//=============================================================================
void print_lista_dupla_inverso(ListaDupla *l){
    CelulaDupla *i;
    printf("[");
    for (i = l->ultimo; i != l->primeiro; i = i->ant)
    {
        printf("%d, ", i->elemento);
    }
    printf("] \n");
}
//=============================================================================
void delete_lista_dupla(ListaDupla *l){
    while(l->size > 0)
        remove_at_dupla(l,0);
    free(l->primeiro);
}
//=============================================================================
#endif
// Fim do arquivo: lista_dupla.h

--------------------------------------------------------------------------------

// Início do arquivo: fila.h
#ifndef FILA_H
#define FILA_H
//=============================================================================
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <limits.h>
#include "celula.h"
//=============================================================================
typedef struct Fila{
    struct Celula *primeiro, *ultimo;
    int size;
} Fila;
//=============================================================================
Fila new_fila(){
    Fila temp;
    temp.primeiro = temp.ultimo = new_celula(-1);
    temp.size = 0;
    return temp;
}
//=============================================================================
int size_fila(Fila *f){
    return f->size;
}
//=============================================================================
void enqueue_fila(Fila *f, int elemento){
    f->ultimo->prox = new_celula(elemento);
    f->ultimo = f->ultimo->prox;
    f->size++;
}
//=============================================================================
int dequeue_fila(Fila *f){
    
    if (f->primeiro == f->ultimo){
        printf("\nA fila esta vazia!\n");
        return INT_MIN;
    }
    
    Celula *temp = f->primeiro;
    f->primeiro = f->primeiro->prox;
    f->size--;
    free(temp);
    return f->primeiro->elemento;
}
//=============================================================================
void print_fila(Fila *f){
    Celula *i;
    printf("[");
    for (i = f->primeiro->prox; i != NULL; i = i->prox)
    {
        printf("%d, ", i->elemento);
    }
    printf("] \n");
}
//=============================================================================
void delete_fila(Fila *f){
    while(f->size > 0)
        dequeue_fila(f);
    free(f->primeiro);
}
//=============================================================================
#endif
// Fim do arquivo: fila.h

--------------------------------------------------------------------------------

// Início do arquivo: pilha.h
#ifndef PILHA_H
#define PILHA_H
//=============================================================================
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <limits.h>
#include "celula.h"
//=============================================================================
typedef struct Pilha{
    struct Celula *topo;
    int size;
} Pilha;
//=============================================================================
Pilha new_pilha(){
    Pilha temp;
    temp.topo = NULL;
    temp.size = 0;
    return temp;
}
//=============================================================================
int size_pilha(Pilha *p){
    return p->size;
}
//=============================================================================
void push_pilha(Pilha *p, int elemento){
    Celula *temp = new_celula(elemento);
    temp->prox = p->topo;
    p->topo = temp;
    p->size++;
}
//=============================================================================
int pop_pilha(Pilha *p){
    if (p->topo == NULL){
        printf("\nA pilha esta vazia!\n");
        return INT_MIN;
    }
    int elemento = p->topo->elemento;
    Celula *temp = p->topo;
    p->topo = p->topo->prox;
    p->size--;
    free(temp);
    return elemento;
}
//=============================================================================
void print_pilha(Pilha *p){
    Celula *i;
    printf("[");
    for (i = p->topo; i != NULL; i = i->prox)
    {
        printf("%d, ", i->elemento);
    }
    printf("] \n");
}
//=============================================================================
void delete_pilha(Pilha *p){
    while(p->size > 0)
        pop_pilha(p);
}
//=============================================================================
#endif
// Fim do arquivo: pilha.h

--------------------------------------------------------------------------------

// Início do arquivo: lista.h
#ifndef LISTA_H
#define LISTA_H
//=============================================================================
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <limits.h>
#include "celula.h"
//=============================================================================
typedef struct Lista{
    struct Celula *primeiro, *ultimo;
    int size;
} Lista;
//=============================================================================
Lista new_lista(){
    Lista temp;
    temp.primeiro = temp.ultimo = new_celula(-1);
    temp.size = 0;
    return temp;
}
//=============================================================================
int size_lista(Lista *l){
    return l->size;
}
//=============================================================================
void insert_begin(Lista *l, int elemento){
    
    Celula *temp = new_celula(-1);
    temp->prox = l->primeiro;

    l->primeiro->elemento = elemento;    
    l->primeiro = temp;
    l->size++;
}
//=============================================================================
void insert_end(Lista *l, int elemento){    
    l->ultimo->prox = new_celula(elemento);
    l->ultimo = l->ultimo->prox;
    l->size++;
}
//=============================================================================
void insert_at(Lista *l, int elemento, int pos){
    
    if(pos < 0 || pos > l->size)
        printf("Erro ao tentar inserir na posicao (%d/ tamanho = %d) invalida!", pos, l->size);
    else if (pos == 0)
        insert_begin(l, elemento);
    else if (pos == l->size)
        insert_end(l, elemento);
    else{
        
        Celula *ant = l->primeiro;
        for(int i=0; i<pos;i++) 
            ant = ant->prox;
            
        Celula *temp = new_celula(elemento);  
        temp->prox = ant->prox;
        ant->prox = temp;
        l->size++;
    }
}
//=============================================================================
int remove_at(Lista *l, int pos){

    if(l->primeiro == l->ultimo){
        printf("\nA lista esta vazia!\n");
        return INT_MIN;
    }else if(pos < 0 || pos > l->size-1)
        printf("Erro ao tentar remover item da posicao (%d/ tamanho = %d) invalida!", pos, l->size);
    else{
        
        Celula *ant = l->primeiro;
        for(int i=0; i<pos;i++) 
            ant = ant->prox;
            
        Celula *temp = ant->prox;  
        int elemento = temp->elemento;

        ant->prox = temp->prox;
        free(temp);       

        if(pos == l->size-1)
            l->ultimo = ant;

        l->size--;

        return elemento;
    }
}
//=============================================================================
int remove_begin(Lista *l){
    return remove_at(l, 0);
}
//=============================================================================
int remove_end(Lista *l){
    return remove_at(l, l->size-1);
}
//=============================================================================
bool pesquisar_lista(Lista *l, int elemento){
    Celula *i;
    for (i = l->primeiro->prox; i != NULL; i = i->prox)
        if(i->elemento == elemento)
            return true;
    return false;
}
//=============================================================================
void print_lista(Lista *l){
    Celula *i;
    printf("[");
    for (i = l->primeiro->prox; i != NULL; i = i->prox)
    {
        printf("%d, ", i->elemento);
    }
    printf("] \n");
}
//=============================================================================
void delete_lista(Lista *l){
    while(l->size > 0)
        remove_at(l,0);
    free(l->primeiro);
}
//=============================================================================
#endif
// Fim do arquivo: lista.h

--------------------------------------------------------------------------------

// Início do arquivo: fila_teste.c
#include "fila.h"
//=============================================================================
int main() {

    Fila f;
    int i, x1, x2, x3;
    printf("==== FILA FLEXIVEL ====\n");

    f = new_fila();

    for(i=0; i < 10; i++)
        enqueue_fila(&f, i);

    printf("Apos inserrir os dados: \n");
    print_fila(&f);

    x1 = dequeue_fila(&f);
    x2 = dequeue_fila(&f);
    x3 = dequeue_fila(&f);

    printf("Apos as remocoes (%d, %d, %d) \n", x1, x2, x3);
    print_fila(&f);

    delete_fila(&f);

    return 0;
}
// Fim do arquivo: fila_teste.c

--------------------------------------------------------------------------------

// Início do arquivo: coletalixo.c
#include <stdio.h>
#include <stdlib.h>
#define true 1

typedef struct Celula {
	int elemento;        // Elemento inserido na celula.
	struct Celula* prox; // Aponta a celula prox.
} Celula;

Celula* novaCelula(int elemento) {
	Celula* nova = (Celula*) malloc(sizeof(Celula));
	nova->elemento = elemento;
	nova->prox = NULL;
	return nova;
}

Celula* primeiro;

void start () {
	primeiro = novaCelula(-1);
}

void inserir(int x) {
	primeiro->prox = novaCelula(x);
	Celula* tmp = primeiro;
	primeiro = primeiro->prox;
	free(tmp);
}

int main(int argc, char** argv) {
	start();
	while(true){
		inserir(0);
	}
	return 0;
}



// Fim do arquivo: coletalixo.c

--------------------------------------------------------------------------------

// Início do arquivo: a.out
ELF          >          @       (:          @ 8 
 @         @       @       @                                                                                                     8      8                                                                                                                  -      =      =      `      p                   -      =      =                               8      8      8                                   X      X      X      D       D              Std   8      8      8                             Ptd                        \       \              Qtd                                                  Rtd   -      =      =      P      P             /lib64/ld-linux-x86-64.so.2              GNU                      GNU = fwzz91?}C^~         GNU                                             em                            3                      D                       !                      `                                             o                          "                    libc.so.6 malloc __cxa_finalize __libc_start_main free GLIBC_2.2.5 _ITM_deregisterTMCloneTable __gmon_start__ _ITM_registerTMCloneTable                                ui	   8       =             `      =                    @             @      ?                    ?                    ?                    ?                    ?                    ?                    ?                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            HH/  HtH     5/  %/   h    h   %/  D  %]/  D  %U/  D  1I^HHPTL  H
  H=k  2/  H=Y/  HR/  H9tH/  Ht	        H=)/  H5"/  H)HH?HHHtH.  HtfD      =.   u+UH=.   HtH=.  	d.  ]     wUHH }   HEHEUHEH@    HEUHH^.  ]UHSH(}HD.  E܉HCH/.  HEH$.  H@H.  HEHUH([]UHH}Hu    q    @ AWL=c+  AVIAUIATAUH-T+  SL)HHt1    LLDAHH9uH[]A\A]A^A_ff.        HH                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             ;X   
      L   \   |t   e     $  H  <d           zR x         /    D    $   4   0    FJw ?:*3$"       \                 t                     y8    EC
o             EC
S          V    EC
EH         )    EC
   D     e    FIE E(D0H8G@n8A0A(B BBB    T                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     `                                         
                    =                           =                    o                                    
                                                  ?             0                                         H                    	                            o          o    (      o           o          o                                                                                           =                      0      @                                                      @      GCC: (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0                                                         8                    X                    |                                                                                                   	 (                   
 H                                                            
                      P                    `                                                                                                       `                     =                    =                    =                    ?                     @                    @                                                                                              !                    7     @             F     =              m     `              y     =                                                           !                                         =                   =                    =                                        ?                                 	                                      +                            @              G          V       O    i      8       Z    @                               a                          @                                                        @                                     @      e                                  @                        /           @                        )           @                @                                      "                    crtstuff.c deregister_tm_clones __do_global_dtors_aux completed.8060 __do_global_dtors_aux_fini_array_entry frame_dummy __frame_dummy_init_array_entry coletalixo.c __FRAME_END__ __init_array_end _DYNAMIC __init_array_start __GNU_EH_FRAME_HDR _GLOBAL_OFFSET_TABLE_ __libc_csu_fini free@@GLIBC_2.2.5 _ITM_deregisterTMCloneTable inserir novaCelula _edata __libc_start_main@@GLIBC_2.2.5 __data_start __gmon_start__ __dso_handle _IO_stdin_used __libc_csu_init malloc@@GLIBC_2.2.5 __bss_start main primeiro __TMC_END__ _ITM_registerTMCloneTable __cxa_finalize@@GLIBC_2.2.5  .symtab .strtab .shstrtab .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt.got .plt.sec .text .fini .rodata .eh_frame_hdr .eh_frame .init_array .fini_array .dynamic .data .bss .comment                                                                                                                              #             8      8                                     6             X      X      $                              I             |      |                                     W   o                   $                             a                                                    i                                                       q   o                                               ~   o       (      (                                                H      H                                        B                   0                                                                                                               0                                          P      P                                                `      `                                                             5                                                      
                                                                                                                   \                                           `       `       h                                          =      -                                                =      -                                                =      -                                              ?      /      P                                          @       0                                                @      0                                         0               0      *                                                   @0               .                 	                      6      8                                                   9                                   
// Fim do arquivo: a.out

--------------------------------------------------------------------------------

// Início do arquivo: lista.c
/**
 * Lista simples dinamica
 * @author Max do Val Machado
 * @version 2 01/2015
 */
#include <stdio.h>
#include <stdlib.h>
#include <err.h>
#define bool   short
#define true   1
#define false  0

//TIPO CELULA ===================================================================
typedef struct Celula {
	int elemento;        // Elemento inserido na celula.
	struct Celula* prox; // Aponta a celula prox.
} Celula;

Celula* novaCelula(int elemento) {
   Celula* nova = (Celula*) malloc(sizeof(Celula));
   nova->elemento = elemento;
   nova->prox = NULL;
   return nova;
}

//LISTA PROPRIAMENTE DITA =======================================================
Celula* primeiro;
Celula* ultimo;


/**
 * Cria uma lista sem elementos (somente no cabeca).
 */
void start () {
   primeiro = novaCelula(-1);
   ultimo = primeiro;
}


/**
 * Insere um elemento na primeira posicao da lista.
 * @param x int elemento a ser inserido.
 */
void inserirInicio(int x) {
   Celula* tmp = novaCelula(x);
   tmp->prox = primeiro->prox;
   primeiro->prox = tmp;
   if (primeiro == ultimo) {                    
      ultimo = tmp;
   }
   tmp = NULL;
}

/**
 * Insere um elemento na ultima posicao da lista.
 * @param x int elemento a ser inserido.
 */
void inserirFim(int x) {
   ultimo->prox = novaCelula(x);
   ultimo = ultimo->prox;
}


/**
 * Remove um elemento da primeira posicao da lista.
 * @return resp int elemento a ser removido.
 * @throws Exception Se a lista nao contiver elementos.
 */
int removerInicio() {
   if (primeiro == ultimo) {
      errx(1, "Erro ao remover!");
   }

   Celula* tmp = primeiro;
   primeiro = primeiro->prox;
   int resp = primeiro->elemento;
   tmp->prox = NULL;
   free(tmp);
   tmp = NULL;
   return resp;
}


/**
 * Remove um elemento da ultima posicao da lista.
 * @return resp int elemento a ser removido.
 */
int removerFim() {
   if (primeiro == ultimo) {
      errx(1, "Erro ao remover!");
   } 

   // Caminhar ate a penultima celula:
   Celula* i;
   for(i = primeiro; i->prox != ultimo; i = i->prox);

   int resp = ultimo->elemento;
   ultimo = i;
   free(ultimo->prox);
   i = ultimo->prox = NULL;

   return resp;
}


/**
 * Calcula e retorna o tamanho, em numero de elementos, da lista.
 * @return resp int tamanho
 */
int tamanho() {
   int tamanho = 0;
   Celula* i;
   for(i = primeiro; i != ultimo; i = i->prox, tamanho++);
   return tamanho;
}


/**
 * Insere um elemento em uma posicao especifica considerando que o 
 * primeiro elemento valido esta na posicao 0.
 * @param x int elemento a ser inserido.
 * @param pos int posicao da insercao.
 * @throws Exception Se <code>posicao</code> invalida.
 */
void inserir(int x, int pos) {

   int tam = tamanho();

   if(pos < 0 || pos > tam){
      errx(1, "Erro ao inserir posicao (%d/ tamanho = %d) invalida!", pos, tam);
   } else if (pos == 0){
      inserirInicio(x);
   } else if (pos == tam){
      inserirFim(x);
   } else {
      // Caminhar ate a posicao anterior a insercao
      int j;
      Celula* i = primeiro;
      for(j = 0; j < pos; j++, i = i->prox);

      Celula* tmp = novaCelula(x);
      tmp->prox = i->prox;
      i->prox = tmp;
      tmp = i = NULL;
   }
}


/**
 * Remove um elemento de uma posicao especifica da lista
 * considerando que o primeiro elemento valido esta na posicao 0.
 * @param posicao Meio da remocao.
 * @return resp int elemento a ser removido.
 * @throws Exception Se <code>posicao</code> invalida.
 */
int remover(int pos) {
   int resp;
   int tam = tamanho();

   if (primeiro == ultimo){
      errx(1, "Erro ao remover (vazia)!");
   } else if(pos < 0 || pos >= tam){
      errx(1, "Erro ao remover posicao (%d/ tamanho = %d) invalida!", pos, tam);
   } else if (pos == 0){
      resp = removerInicio();
   } else if (pos == tam - 1){
      resp = removerFim();
   } else {
      // Caminhar ate a posicao anterior a insercao
      Celula* i = primeiro;
      int j;
      for(j = 0; j < pos; j++, i = i->prox);

      Celula* tmp = i->prox;
      resp = tmp->elemento;
      i->prox = tmp->prox;
      tmp->prox = NULL;
      free(tmp);
      i = tmp = NULL;
   }
   return resp;
}


/**
 * Mostra os elementos da lista separados por espacos.
 */
void mostrar() {
   printf("[ ");
   Celula* i;
   for (i = primeiro->prox; i != NULL; i = i->prox) {
      printf("%d ", i->elemento);
   }
   printf("] \n");
}


/**
 * Procura um elemento e retorna se ele existe.
 * @param x Elemento a pesquisar.
 * @return <code>true</code> se o elemento existir,
 * <code>false</code> em caso contrario.
 */
bool pesquisar(int x) {
   bool retorno = false;
   Celula* i;

   for (i = primeiro->prox; i != NULL; i = i->prox) {
      if(i->elemento == x){
         retorno = true;
         i = ultimo;
      }
   }
   return retorno;
}


int main(int argc, char** argv) {
   int x1, x2, x3, x4, x5, x6;
   printf("=== LISTA DINAMICA SIMPLESMENTE ENCADEADA === \n\n");

   start();

   inserirInicio(1);
   inserirInicio(0);
   inserirFim(4);
   inserirFim(5);
   inserir(2, 2);
   inserir(3, 3);
   inserir(6, 6);
   inserir(-1, 0);
   inserirFim(7);
   inserirFim(8);

   printf("Apos insercoes: ");
   mostrar();

   x1 = remover(3);
   x2 = remover(2);
   x3 = removerFim();
   x4 = removerInicio();
   x5 = remover(0);
   x6 = remover(4);

   printf("Apos remocoes (%d, %d, %d, %d, %d, %d): ", x1, x2, x3, x4, x5, x6);
   mostrar();
   return 0;
}

// Fim do arquivo: lista.c

--------------------------------------------------------------------------------

// Início do arquivo: listadupla.c
/**
 * Lista dupla dinamica
 * @author Max do Val Machado
 * @version 2 01/2015
 */
#include <stdio.h>
#include <stdlib.h>
#include <err.h>

#define bool   short
#define true   1
#define false  0

//TIPO CELULA ===================================================================
typedef struct CelulaDupla {
	int elemento;        // Elemento inserido na celula.
	struct CelulaDupla* prox; // Aponta a celula prox.
   struct CelulaDupla* ant;  // Aponta a celula anterior.
} CelulaDupla;

CelulaDupla* novaCelulaDupla(int elemento) {
   CelulaDupla* nova = (CelulaDupla*) malloc(sizeof(CelulaDupla));
   nova->elemento = elemento;
   nova->ant = nova->prox = NULL;
   return nova;
}

//LISTA PROPRIAMENTE DITA =======================================================
CelulaDupla* primeiro;
CelulaDupla* ultimo;


/**
 * Cria uma lista dupla sem elementos (somente no cabeca).
 */
void start () {
   primeiro = novaCelulaDupla(-1);
   ultimo = primeiro;
}


/**
 * Insere um elemento na primeira posicao da lista.
 * @param x int elemento a ser inserido.
 */
void inserirInicio(int x) {
   CelulaDupla* tmp = novaCelulaDupla(x);

   tmp->ant = primeiro;
   tmp->prox = primeiro->prox;
   primeiro->prox = tmp;
   if (primeiro == ultimo) {                    
      ultimo = tmp;
   } else {
      tmp->prox->ant = tmp;
   }
   tmp = NULL;
}


/**
 * Insere um elemento na ultima posicao da lista.
 * @param x int elemento a ser inserido.
 */
void inserirFim(int x) {
   ultimo->prox = novaCelulaDupla(x);
   ultimo->prox->ant = ultimo;
   ultimo = ultimo->prox;
}


/**
 * Remove um elemento da primeira posicao da lista.
 * @return resp int elemento a ser removido.
 */
int removerInicio() {
   if (primeiro == ultimo) {
      errx(1, "Erro ao remover (vazia)!");
   }

   CelulaDupla* tmp = primeiro;
   primeiro = primeiro->prox;
   int resp = primeiro->elemento;
   tmp->prox = primeiro->ant = NULL;
   free(tmp);
   tmp = NULL;
   return resp;
}


/**
 * Remove um elemento da ultima posicao da lista.
 * @return resp int elemento a ser removido.
 */
int removerFim() {
   if (primeiro == ultimo) {
      errx(1, "Erro ao remover (vazia)!");
   } 
   int resp = ultimo->elemento;
   ultimo = ultimo->ant;
   ultimo->prox->ant = NULL;
   free(ultimo->prox);
   ultimo->prox = NULL;
   return resp;
}


/**
 *  Calcula e retorna o tamanho, em numero de elementos, da lista.
 *  @return resp int tamanho
 */
int tamanho() {
   int tamanho = 0; 
   CelulaDupla* i;
   for(i = primeiro; i != ultimo; i = i->prox, tamanho++);
   return tamanho;
}


/**
 * Insere um elemento em uma posicao especifica considerando que o 
 * primeiro elemento valido esta na posicao 0.
 * @param x int elemento a ser inserido.
 * @param pos int posicao da insercao.
 * @throws Exception Se <code>posicao</code> invalida.
 */
void inserir(int x, int pos) {

   int tam = tamanho();

   if(pos < 0 || pos > tam){
      errx(1, "Erro ao remover (posicao %d/%d invalida!", pos, tam);
   } else if (pos == 0){
      inserirInicio(x);
   } else if (pos == tam){
      inserirFim(x);
   } else {
      // Caminhar ate a posicao anterior a insercao
      CelulaDupla* i = primeiro;
      int j;
      for(j = 0; j < pos; j++, i = i->prox);

      CelulaDupla* tmp = novaCelulaDupla(x);
      tmp->ant = i;
      tmp->prox = i->prox;
      tmp->ant->prox = tmp->prox->ant = tmp;
      tmp = i = NULL;
   }
}


/**
 * Remove um elemento de uma posicao especifica da lista
 * considerando que o primeiro elemento valido esta na posicao 0.
 * @param posicao Meio da remocao.
 * @return resp int elemento a ser removido.
 * @throws Exception Se <code>posicao</code> invalida.
 */
int remover(int pos) {
   int resp;
   int tam = tamanho();

   if (primeiro == ultimo){
      errx(1, "Erro ao remover (vazia)!");
   } else if(pos < 0 || pos >= tam){
      errx(1, "Erro ao remover (posicao %d/%d invalida!", pos, tam);
   } else if (pos == 0){
      resp = removerInicio();
   } else if (pos == tam - 1){
      resp = removerFim();
   } else {
      // Caminhar ate a posicao anterior a insercao
      CelulaDupla* i = primeiro->prox;
      int j;
      for(j = 0; j < pos; j++, i = i->prox);

      i->ant->prox = i->prox;
      i->prox->ant = i->ant;
      resp = i->elemento;
      i->prox = i->ant = NULL;
      free(i);
      i = NULL;
   }

   return resp;
}


/**
 * Mostra os elementos da lista separados por espacos.
 */
void mostrar() {
   CelulaDupla* i;
   printf("[ ");
   for (i = primeiro->prox; i != NULL; i = i->prox) {
      printf("%d ", i->elemento);
   }
   printf("] \n");
}


/**
 * Mostra os elementos da lista de forma invertida 
 * e separados por espacos.
 */
void mostrarInverso() {
   printf("[ ");
   CelulaDupla* i;
   for (i = ultimo; i != primeiro; i = i->ant){
      printf("%d ", i->elemento);
   }
   printf("] \n"); // Termina de mostrar.
}


/**
 * Procura um elemento e retorna se ele existe.
 * @param x Elemento a pesquisar.
 * @return <code>true</code> se o elemento existir,
 * <code>false</code> em caso contrario.
 */
bool pesquisar(int x) {
   bool resp = false;
   CelulaDupla* i;

   for (i = primeiro->prox; i != NULL; i = i->prox) {
      if(i->elemento == x){
         resp = true;
         i = ultimo;
      }
   }
   return resp;
}


int main(int argc, char** argv) {
   start();

   printf("LISTA DINAMICA DUPLAMENTE ENCADEADA\n\n");

   inserirInicio(2);
   inserirInicio(1);
   inserirFim(5);
   inserirFim(6);
   inserir(3, 2);
   inserir(4, 3);
   inserir(7, 6);
   inserir(0, 0);
   inserirFim(8);
   inserirFim(9);

   printf("Apos insercoes: ");
   mostrar();
   mostrarInverso();

   remover(3);
   remover(2);
   removerFim();
   removerInicio();
   remover(0);
   remover(4);

   printf("Apos remocoes: ");
   mostrar();
   mostrarInverso();
   return 0;
}

// Fim do arquivo: listadupla.c

--------------------------------------------------------------------------------

// Início do arquivo: fila.c
/**
 * Fila flexivel
 * @author Max do Val Machado
 * @version 2 01/2015
 */
#include <stdio.h>
#include <stdlib.h>
#include <err.h>

//TIPO CELULA ===================================================================
typedef struct Celula {
	int elemento;        // Elemento inserido na celula.
	struct Celula* prox; // Aponta a celula prox.
} Celula;

Celula* novaCelula(int elemento) {
   Celula* nova = (Celula*) malloc(sizeof(Celula));
   nova->elemento = elemento;
   nova->prox = NULL;
   return nova;
}

//FILA PROPRIAMENTE DITA ========================================================
Celula* primeiro;
Celula* ultimo;


/**
 * Cria uma fila sem elementos (somente no cabeca).
 */
void start () {
   primeiro = novaCelula(-1);
   ultimo = primeiro;
}


/**
 * Insere elemento na fila (politica FIFO).
 * @param x int Elemento a inserir.
 */
void inserir(int x) {
   ultimo->prox = novaCelula(x);
   ultimo = ultimo->prox;
}


/**
 * Remove elemento da fila (politica FIFO).
 * @return Elemento removido.
 */
int remover() {
   if (primeiro == ultimo) {
      errx(1, "Erro ao remover!");
   }
   Celula* tmp = primeiro;
   primeiro = primeiro->prox;
   int resp = primeiro->elemento;
   tmp->prox = NULL;
   free(tmp);
   tmp = NULL;
   return resp;
}


/**
 * Mostra os elementos separados por espacos.
 */
void mostrar() {
   Celula* i;
   printf("[ ");
   for (i = primeiro->prox; i != NULL; i = i->prox) {
      printf("%d ", i->elemento);
   }
   printf("] \n");
}


//METODO PRINCIPAL ==============================================================
int main(int argc, char** argv){
   int x1, x2, x3;
   printf("\n==== FILA FLEXIVEL ====");

   start();

   inserir(5);
   inserir(7);
   inserir(8);
   inserir(9);

   printf("\nApos insercoes(5, 7, 8, 9): ");
   mostrar();

   x1 = remover();
   x2 = remover();

   printf("\nApos remocoes (%d, %d):", x1, x2);
   mostrar();

   inserir(3);
   inserir(4);


   printf("\nApos insercoes(3, 4): ");
   mostrar();

   x1 = remover();
   x2 = remover();
   x3 = remover();

   printf("\nApos remocoes (%d, %d, %d):", x1, x2, x3);
   mostrar();

   inserir(4);
   inserir(5);

   printf("\nApos insercoes(4, 5): ");
   mostrar();

   x1 = remover();
   x2 = remover();

   printf("\nApos remocoes (%d, %d):", x1, x2);
   mostrar();

   inserir(6);
   inserir(7);

   printf("\nApos insercoes(6, 7): ");
   mostrar();

   x1 = remover();

   printf("\nApos remocao (%d):", x1);
   mostrar();
}

// Fim do arquivo: fila.c

--------------------------------------------------------------------------------

// Início do arquivo: entrada.in
quantidade de testes (por exemplo, 3)
linhas da primeira matriz do primeiro teste
colunas da primeira matriz do primeiro teste
x x x x x ... x
x x x x x ... x
...
x x x x x ... x
linhas da segunda matriz do primeiro teste
colunas da segunda matriz do primeiro teste
x x x x x ... x
x x x x x ... x
...
x x x x x ... x
linhas da primeira matriz do segundo teste
colunas da primeira matriz do segundo teste
x x x x x ... x
x x x x x ... x
...
x x x x x ... x
linhas da segunda matriz do segundo teste
colunas da segunda matriz do segundo teste
x x x x x ... x
x x x x x ... x
...
x x x x x ... x
linhas da primeira matriz do terceiro teste
colunas da primeira matriz do terceiro teste
x x x x x ... x
x x x x x ... x
...
x x x x x ... x
linhas da segunda matriz do terceiro teste
colunas da segunda matriz do terceiro teste
x x x x x ... x
x x x x x ... x
...
x x x x x ... x

// Fim do arquivo: entrada.in

--------------------------------------------------------------------------------

// Início do arquivo: pilha.c
/**
 * Pilha dinamica
 * @author Max do Val Machado
 * @version 2 01/2015
 */
#include <stdio.h>
#include <stdlib.h>
#include <err.h>

//TIPO CELULA ===================================================================
typedef struct Celula {
	int elemento;        // Elemento inserido na celula.
	struct Celula* prox; // Aponta a celula prox.
} Celula;

Celula* novaCelula(int elemento) {
   Celula* nova = (Celula*) malloc(sizeof(Celula));
   nova->elemento = elemento;
   nova->prox = NULL;
   return nova;
}

//PILHA PROPRIAMENTE DITA =======================================================
Celula* topo; // Sem celula cabeca.


/**
 * Cria uma fila sem elementos.
 */
void start () {
   topo = NULL;
}


/**
 * Insere elemento na pilha (politica FILO).
 * @param x int elemento a inserir.
 */
void inserir(int x) {
   Celula* tmp = novaCelula(x);
   tmp->prox = topo;
   topo = tmp;
   tmp = NULL;
}

/**
 * Remove elemento da pilha (politica FILO).
 * @return Elemento removido.
 */
int remover() {
   if (topo == NULL) {
      errx(1, "Erro ao remover!");
   }

   int resp = topo->elemento;
   Celula* tmp = topo;
   topo = topo->prox;
   tmp->prox = NULL;
   free(tmp);
   tmp = NULL;
   return resp;
}


/**
 * Mostra os elementos separados por espacos, comecando do topo.
 */
void mostrar() {
   Celula* i;
   printf("[");
   for(i = topo; i != NULL; i = i->prox) {
      printf("%d ,", i->elemento);
   }

   printf("] \n");
}


//METODO PRINCIPAL ==============================================================
int main(int argc, char** argv){
   int x1, x2, x3;

   printf("==== PILHA FLEXIVEL ====\n");

   start();

   inserir(0);
   inserir(1);
   inserir(2);
   inserir(3);
   inserir(4);
   inserir(5);

   printf("Apos insercoes: \n");
   mostrar();

   x1 = remover();
   x2 = remover();
   x3 = remover();

   printf("Apos as remocoes (%d, %d, %d) \n ", x1, x2, x3);
   mostrar();
}

// Fim do arquivo: pilha.c

--------------------------------------------------------------------------------

// Início do arquivo: README.md
# U4 - Ordenação em memória principal

## Exemplo de como compilar o código

```
gcc -I. bolha_teste.c -o bolha_teste

```

## Exemplo de como executar o código

```
.\bolha_teste.exe 10
```

// Fim do arquivo: README.md

--------------------------------------------------------------------------------

// Início do arquivo: Selecao.java
/**
 * Algoritmo de ordenacao por selecao
 * @author Max do Val Machado
 * @version 3 08/2020
 */

class Selecao extends Geracao {

	/**
	 * Construtor.
	 */
	public Selecao(){
		super();
	}


	/**
	 * Construtor.
	 * @param int tamanho do array de numeros inteiros.
	 */
	public Selecao(int tamanho){
		super(tamanho);
	}


	/**
	 * Algoritmo de ordenacao por selecao.
	 */
	@Override
	public void sort() {
		for (int i = 0; i < (n - 1); i++) {
			int menor = i;
			for (int j = (i + 1); j < n; j++){
				if (array[menor] > array[j]){
					menor = j;
				}
			}
			swap(menor, i);
		}
	}
}

// Fim do arquivo: Selecao.java

--------------------------------------------------------------------------------

// Início do arquivo: MyIO.java
import java.io.*;
import java.nio.charset.*;

class MyIO {

   private static BufferedReader in = new BufferedReader(new InputStreamReader(System.in, Charset.forName("ISO-8859-1")));
   private static String charset = "ISO-8859-1";

   public static void setCharset(String charset_){
      charset = charset_;
      in = new BufferedReader(new InputStreamReader(System.in, Charset.forName(charset)));
   }

   public static void print(){
   }

   public static void print(int x){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.print(x);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
   }
   
   public static void print(float x){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.print(x);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
   }
   
   public static void print(double x){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.print(x);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
   }

   public static void print(String x){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.print(x);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
   }

   public static void print(boolean x){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.print(x);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
   }

   public static void print(char x){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.print(x);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
   }

   public static void println(){
   }

   public static void println(int x){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.println(x);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
   }

   public static void println(float x){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.println(x);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
   }
   
   public static void println(double x){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.println(x);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
   }

   public static void println(String x){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.println(x);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
   }

   public static void println(boolean x){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.println(x);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
   }

   public static void println(char x){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.println(x);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
   }

   public static void printf(String formato, double x){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.printf(formato, x);// "%.2f"
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
   }

   public static double readDouble(){
      double d = -1;
      try{
         d = Double.parseDouble(readString().trim().replace(",","."));
      }catch(Exception e){}
      return d;
   }

   public static double readDouble(String str){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.print(str);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
      return readDouble();
   }

   public static float readFloat(){
      return (float) readDouble();
   }

   public static float readFloat(String str){
      return (float) readDouble(str);
   }

   public static int readInt(){
      int i = -1;
      try{
         i = Integer.parseInt(readString().trim());
      }catch(Exception e){}
      return i;
   }

   public static int readInt(String str){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.print(str);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
      return readInt();
   }

   public static String readString(){
      String s = "";
      char tmp;
      try{
         do{
            tmp = (char)in.read();
            if(tmp != '\n' && tmp != ' ' && tmp != 13){
               s += tmp;
            }
         }while(tmp != '\n' && tmp != ' ');
      }catch(IOException ioe){
         System.out.println("lerPalavra: " + ioe.getMessage());
      }
      return s;
   }

   public static String readString(String str){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.print(str);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
      return readString();
   }

   public static String readLine(){
      String s = "";
      char tmp;
      try{
         do{
            tmp = (char)in.read();
            if(tmp != '\n' && tmp != 13){
               s += tmp;
            }
         }while(tmp != '\n');
      }catch(IOException ioe){
         System.out.println("lerPalavra: " + ioe.getMessage());
      }
      return s;
   }

   public static String readLine(String str){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.print(str);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
      return readLine();
   }

   public static char readChar(){
      char resp = ' ';
      try{
         resp  = (char)in.read();
      }catch(Exception e){}
      return resp;
   }

   public static char readChar(String str){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.print(str);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
      return readChar();
   }

   public static boolean readBoolean(){
      boolean resp = false;
      String str = "";

      try{
         str = readString();
      }catch(Exception e){}

      if(str.equals("true") || str.equals("TRUE") || str.equals("t") || str.equals("1") || 
            str.equals("verdadeiro") || str.equals("VERDADEIRO") || str.equals("V")){
         resp = true;
            }

      return resp;
   }

   public static boolean readBoolean(String str){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.print(str);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
      return readBoolean();
   }

   public static void pause(){
      try{
         in.read();
      }catch(Exception e){}
   }

   public static void pause(String str){
      try {
         PrintStream out = new PrintStream(System.out, true, charset);
         out.print(str);
      }catch(UnsupportedEncodingException e){ System.out.println("Erro: charset invalido"); }
      pause();
   }
}
// Fim do arquivo: MyIO.java

--------------------------------------------------------------------------------

// Início do arquivo: Quicksort.java
/**
 * Algoritmo de ordenacao Quicksort
 * @author Max do Val Machado
 * @version 3 08/2020
 */
class Quicksort extends Geracao {

	/**
	 * Construtor.
	 */
   public Quicksort(){
      super();
   }


	/**
	 * Construtor.
	 * @param int tamanho do array de numeros inteiros.
	 */
   public Quicksort(int tamanho){
      super(tamanho);
   }


	/**
	 * Algoritmo de ordenacao Quicksort.
	 */
   @Override
   public void sort() {
      quicksort(0, n-1);
   }

	/**
	 * Algoritmo de ordenacao Quicksort.
    * @param int esq inicio do array a ser ordenado
    * @param int dir fim do array a ser ordenado
	 */
    private void quicksort(int esq, int dir) {
        int i = esq, j = dir;
        int pivo = array[(dir+esq)/2];
        while (i <= j) {
            while (array[i] < pivo) i++;
            while (array[j] > pivo) j--;
            if (i <= j) {
                swap(i, j);
                i++;
                j--;
            }
        }
        if (esq < j)  quicksort(esq, j);
        if (i < dir)  quicksort(i, dir);
    }
}

// Fim do arquivo: Quicksort.java

--------------------------------------------------------------------------------

// Início do arquivo: Countingsort.java
/**
 * Metodo de ordenacao por contagem
 * @author Max do Val Machado
 * @version 3 08/2020
 */

class Countingsort extends Geracao {

	/**
	 * Construtor.
	 */
   public Countingsort(){
      super();
   }


	/**
	 * Construtor.
	 * @param int tamanho do array de numeros inteiros.
	 */
   public Countingsort(int tamanho){
      super(tamanho);
   }


	/**
	 * Algoritmo de ordenacao Countingsort.
	 */
   @Override
   public void sort() {
      //Array para contar o numero de ocorrencias de cada elemento
      int[] count = new int[getMaior() + 1];
      int[] ordenado = new int[n];

      //Inicializar cada posicao do array de contagem 
		for (int i = 0; i < count.length; count[i] = 0, i++);

      //Agora, o count[i] contem o numero de elemento iguais a i
      for (int i = 0; i < n; count[array[i]]++, i++);

      //Agora, o count[i] contem o numero de elemento menores ou iguais a i
      for(int i = 1; i < count.length; count[i] += count[i-1], i++);

      //Ordenando
      for(int i = n-1; i >= 0; ordenado[count[array[i]]-1] = array[i], count[array[i]]--, i--);

      //Copiando para o array original
      for(int i = 0; i < n; array[i] = ordenado[i], i++);
   }


	/**
	 * Retorna o maior elemento do array.
    * @return maior elemento
	 */
	public int getMaior() {
	   int maior = array[0];

		for (int i = 0; i < n; i++) {
         if(maior < array[i]){
            maior = array[i];
         }
		}
	   return maior;	
	}
}

// Fim do arquivo: Countingsort.java

--------------------------------------------------------------------------------

// Início do arquivo: Radixsort.java
/**
 * Metodo de ordenacao por contagem
 * @author Daniel Capanema
 * @version 1 04/2023
 */

class Radixsort extends Geracao {

	/**
	 * Construtor.
	 */
   public Radixsort(){
      super();
   }


	/**
	 * Construtor.
	 * @param int tamanho do array de numeros inteiros.
	 */
   public Radixsort(int tamanho){
      super(tamanho);
   }


	/**
	 * Algoritmo de ordenacao Countingsort.
	 */
   @Override
   public void sort() {
      int max = getMaior();
      for (int exp = 1; max/exp > 0; exp *= 10) {
         sort(exp);
     }
   }

   public void sort(int exp) {
      int[] count = new int[10];
      int[] output = new int[n];

      //Inicializar cada posicao do array de contagem 
      for (int i = 0; i < 10; count[i] = 0, i++);

      //Agora, o count[i] contem o numero de elemento iguais a i
      for (int i = 0; i < n; i++) {
          count[(array[i]/exp) % 10]++;
      }

      //Agora, o count[i] contem o numero de elemento menores ou iguais a i
      for (int i = 1; i < 10; i++) {
          count[i] += count[i-1];
      }

      //Ordenando
      for (int i = n-1; i >= 0; i--) {
          output[count[(array[i]/exp) % 10] - 1] = array[i];
          count[(array[i]/exp) % 10]--;
      }

      //Copiando para o array original
      for (int i = 0; i < n; i++) {
          array[i] = output[i];
      }
   }



	/**
	 * Retorna o maior elemento do array.
    * @return maior elemento
	 */
	public int getMaior() {
	   int maior = array[0];

		for (int i = 1; i < n; i++) {
         if(maior < array[i]){
            maior = array[i];
         }
		}
	   return maior;	
	}
}

// Fim do arquivo: Radixsort.java

--------------------------------------------------------------------------------

// Início do arquivo: Principal.java
/**
 * Classe Principal
 * @author Max do Val Machado
 * @version 3 08/2020
 */
class Principal {
	public static void main(String[] args) {

      //Delcaracao de variaveis
      Geracao algoritmo;
      int n = (args.length < 1) ? 1000 : Integer.parseInt(args[0]);
      double inicio, fim;


      //Inicializacao do algoritmo de ordenacao
      //algoritmo = new Bolha(n);
      //algoritmo = new Countingsort(n);
      //algoritmo = new Heapsort(n);
      algoritmo = new Insercao(n);
      //algoritmo = new Mergesort(n);
      //algoritmo = new Quicksort(n);
      //algoritmo = new Radixsort(n);
      //algoritmo = new Selecao(n);
      //algoritmo = new Shellsort(n);


      //Geracao do conjunto a ser ordenado
		//algoritmo.aleatorio();
		algoritmo.crescente();
		//algoritmo.decrescente();


      //Mostrar o conjunto a ser ordenado
		//algoritmo.mostrar();
		

      //Execucao do algoritmo de ordenacao
		inicio = algoritmo.now();
		algoritmo.sort();
		fim = algoritmo.now();


      //Mostrar o conjunto ordenado, tempo de execucao e status da ordenacao
		//algoritmo.mostrar();
		System.out.println("Tempo para ordenar: " + (fim-inicio)/1000.0 + " s.");
		System.out.println("isOrdenado: " + algoritmo.isOrdenado());
	}
}

// Fim do arquivo: Principal.java

--------------------------------------------------------------------------------

// Início do arquivo: Insercao.java
/**
 * Algoritmo de ordenacao por insercao
 * @author Max do Val Machado
 * @version 3 01/2020
 */

class Insercao extends Geracao {

	/**
	 * Construtor.
	 */
   public Insercao(){
      super();
   }


	/**
	 * Construtor.
	 * @param int tamanho do array de numeros inteiros.
	 */
   public Insercao(int tamanho){
      super(tamanho);
   }


	/**
	 * Algoritmo de ordenacao por insercao.
	 */
   @Override
   public void sort() {
		for (int i = 1; i < n; i++) {
			int tmp = array[i];
         int j = i - 1;

         while ((j >= 0) && (array[j] > tmp)) {
            array[j + 1] = array[j];
            j--;
         }
         array[j + 1] = tmp;
      }
	}
}

// Fim do arquivo: Insercao.java

--------------------------------------------------------------------------------

// Início do arquivo: Mergesort.java
/**
 * Algoritmo de ordenacao Mergesort
 * @author Max do Val Machado
 * @version 3 08/2020
 */
class Mergesort extends Geracao {

   /**
    * Construtor.
    */
   public Mergesort(){
      super();
   }


   /**
    * Construtor.
    * @param int tamanho do array de numeros inteiros.
    */
   public Mergesort(int tamanho){
      super(tamanho);
   }


   /**
    * Algoritmo de ordenacao Mergesort.
    */
   @Override
   public void sort() {
      mergesort(0, n-1);
   }

   /**
    * Algoritmo de ordenacao Mergesort.
    * @param int esq inicio do array a ser ordenado
    * @param int dir fim do array a ser ordenado
    */
   private void mergesort(int esq, int dir) {
      if (esq < dir){
         int meio = (esq + dir) / 2;
         mergesort(esq, meio);
         mergesort(meio + 1, dir);
         intercalar(esq, meio, dir);
      }
   }

   /**
    * Algoritmo que intercala os elementos entre as posicoes esq e dir
    * @param int esq inicio do array a ser ordenado
    * @param int meio posicao do meio do array a ser ordenado
    * @param int dir fim do array a ser ordenado
    */ 
   public void intercalar(int esq, int meio, int dir){
      int n1, n2, i, j, k;

      //Definir tamanho dos dois subarrays
      n1 = meio-esq+1;
      n2 = dir - meio;

      int[] a1 = new int[n1+1];
      int[] a2 = new int[n2+1];

      //Inicializar primeiro subarray
      for(i = 0; i < n1; i++){
         a1[i] = array[esq+i];
      }

      //Inicializar segundo subarray
      for(j = 0; j < n2; j++){
         a2[j] = array[meio+j+1];
      }

      //Sentinela no final dos dois arrays
      a1[i] = a2[j] = 0x7FFFFFFF;

      //Intercalacao propriamente dita
      for(i = j = 0, k = esq; k <= dir; k++){
         array[k] = (a1[i] <= a2[j]) ? a1[i++] : a2[j++];
      }
   }
}

// Fim do arquivo: Mergesort.java

--------------------------------------------------------------------------------

// Início do arquivo: Geracao.java
/**
 * Geracao de elementos de um array
 * @author Max do Val Machado
 * @version 3 08/2020
 */

import java.util.*;

class Geracao {
	protected int[] array;
	protected int n;


	/**
	 * Construtor.
	 */
	public Geracao(){
		array = new int[100];
		n = array.length;
	}


	/**
	 * Construtor.
	 * @param int tamanho do array de numeros inteiros.
	 */
	public Geracao(int tamanho){
		array = new int[tamanho];
		n = array.length;
	}


	/**
	 * Produz um array ordenado de modo crescente.
	 */
	public void crescente() {
		for (int i = 0; i < n; i++) {
			array[i] = i;
		}
	}


	/**
	 * Produz um array ordenado de modo decrescente.
	 */
	public void decrescente() {
		for (int i = 0; i < n; i++) {
			array[i] = n - 1 - i;
		}
	}


	/**
	 * Produz um array com numeros aleatorios.
	 */
	public void aleatorio() {
		Random rand = new Random();
		crescente();	
		for (int i = 0; i < n; i++) {
			swap(i, Math.abs(rand.nextInt()) % n);
		}
	}


	/**
	 * Efetua a leitura dos elementos via entrada padrao.
	 */
	public void entradaPadrao() {
		n = MyIO.readInt();
		array = new int[n];

		for (int i = 0; i < n; i++) {
			array[i] = MyIO.readInt();
		}
	}

	/**
	 * Recebe um Efetua a leitura dos elementos via entrada padrao.
	 */
	public void entrada(int[] vet){
		n = vet.length;
		array = new int[n];
		for(int i = 0; i < n; i++){
			array[i] = vet[i];
		}
	}


	/**
	 * Mostra os k primeiros elementos do array.
	 * @param int k indica a quantidade de elementos do array a serem mostrados.
	 */
	public void mostrar(int k) {
		System.out.print("[");

		for (int i = 0; i < k; i++) {
			System.out.print(" ("+i+")" + array[i]);
		}

		System.out.println("]");
	}


	/**
	 * Mostra os elementos do array.
	 */
	public void mostrar() {
		System.out.print("[");

		for (int i = 0; i < n; i++) {
			System.out.print(" ("+i+")" + array[i]);
		}

		System.out.println("]");
	}


	/**
	 * Troca o conteudo de duas posicoes do array
	 * @param i int primeira posicao
	 * @param j int segunda posicao
	 */
	public void swap(int i, int j) {
		int temp = array[i];
		array[i] = array[j];
		array[j] = temp;
	}


	/**
	 * Retorna o timestamp atual
	 * @return timestamp atual
	 */
	public long now(){
		return new Date().getTime();
	}


	/**
	 * Retorna verdadeiro/falso indicando se o array esta ordenado
	 * @return boolean indicando se o array esta ordenado
	 */
	public boolean isOrdenado(){
		boolean resp = true;
		for(int i = 1; i < n; i++){
			if(array[i] < array[i-1]){
				i = n;
				resp = false;
			}
		}
		return resp;
	}

	/*
	 * Metodo a ser implementado nas subclasses
	 */
	public void sort(){
		System.out.println("Método a ser implementado nas subclasses.");
	}
}

// Fim do arquivo: Geracao.java

--------------------------------------------------------------------------------

// Início do arquivo: Heapsort.java
/**
 * Algoritmo de ordenacao Heapsort
 * @author Max do Val Machado
 * @version 3 08/2020
 */

class Heapsort extends Geracao {

   /**
    * Construtor.
    */
   public Heapsort(){
      super();
   }


   /**
    * Construtor.
    * @param int tamanho do array de numeros inteiros.
    */
   public Heapsort(int tamanho){
      super(tamanho);
   }


   /**
    * Algoritmo de ordenacao Heapsort.
    */
   @Override
   public void sort() {
      //Alterar o vetor ignorando a posicao zero
      int[] tmp = new int[n+1];
      for(int i = 0; i < n; i++){
         tmp[i+1] = array[i];
      }
      array = tmp;

      //Contrucao do heap
      for(int tamHeap = 2; tamHeap <= n; tamHeap++){
         construir(tamHeap);
      }

      //Ordenacao propriamente dita
      int tamHeap = n;
      while(tamHeap > 1){
         swap(1, tamHeap--);
         reconstruir(tamHeap);
      }

      //Alterar o vetor para voltar a posicao zero
      tmp = array;
      array = new int[n];
      for(int i = 0; i < n; i++){
         array[i] = tmp[i+1];
      }
   }


   public void construir(int tamHeap){
      for(int i = tamHeap; i > 1 && array[i] > array[i/2]; i /= 2){
         swap(i, i/2);
      }
   }


   public void reconstruir(int tamHeap){
      int i = 1;
      while(i <= (tamHeap/2)){
         int filho = getMaiorFilho(i, tamHeap);
         if(array[i] < array[filho]){
            swap(i, filho);
            i = filho;
         }else{
            i = tamHeap;
         }
      }
   }

   public int getMaiorFilho(int i, int tamHeap){
      int filho;
      if (2*i == tamHeap || array[2*i] > array[2*i+1]){
         filho = 2*i;
      } else {
         filho = 2*i + 1;
      }
      return filho;
   }
}

// Fim do arquivo: Heapsort.java

--------------------------------------------------------------------------------

// Início do arquivo: Bolha.java
/**
 * Metodo de ordenacao da bolha
 * @author Max do Val Machado
 * @version 3 08/2020
 */
class Bolha extends Geracao {

	/**
	 * Construtor.
	 */
   public Bolha(){
      super();
   }


	/**
	 * Construtor.
	 * @param int tamanho do array de numeros inteiros.
	 */
   public Bolha(int tamanho){
      super(tamanho);
   }


	/**
	 * Algoritmo de ordenacao Bolha.
	 */
   @Override
   public void sort() {
		for (int i = (n - 1); i > 0; i--) {
			for (int j = 0; j < i; j++) {
				if (array[j] > array[j + 1]) {
               swap(j, j+1);
				}
			}
		}
   }
}

// Fim do arquivo: Bolha.java

--------------------------------------------------------------------------------

// Início do arquivo: Shellsort.java
/**
 * Algoritmo de ordenacao Shellsort
 * @author Max do Val Machado
 * @version 3 08/2020
 */

class Shellsort extends Geracao {

   /**
    * Construtor.
    */
   public Shellsort(){
      super();
   }


   /**
    * Construtor.
    * @param int tamanho do array de numeros inteiros.
    */
   public Shellsort(int tamanho){
      super(tamanho);
   }


   /**
    * Algoritmo de ordenacao Shellsort.
    */
   @Override
   public void sort() {
      int h = 1;

      do { h = (h * 3) + 1; } while (h < n);

      do {
         h /= 3;
         for(int cor = 0; cor < h; cor++){
            insercaoPorCor(cor, h);
         }
      } while (h != 1);
   }


   /**
    * Metodo que efetua a insercao nos pseudo-arrays do Shellsort.
    * @param int cor cor do pseudo array.
    * @param int h passo do shelsort
    */
   public void insercaoPorCor(int cor, int h){
      for (int i = (h + cor); i < n; i+=h) {
         int tmp = array[i];
         int j = i - h;
         while ((j >= 0) && (array[j] > tmp)) {
            array[j + h] = array[j];
            j-=h;
         }
         array[j + h] = tmp;
      }
   }
}

// Fim do arquivo: Shellsort.java

--------------------------------------------------------------------------------

// Início do arquivo: principal.c
#include "bolha.h"
#include "countingsort.h"
#include "radixsort.h"
#include "heapsort.h"
#include "insercao.h"
#include "mergesort.h"
#include "quicksort.h"
#include "selecao.h"
#include "shellsort.h"
#include "geracao.h"

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

//=============================================================================
int main(int argc, char **argv) {

    //Delcaracao de variaveis
    int n = (argc < 2) ? 1000 : atoi(argv[1]);
    int *array = (int*) malloc(n*sizeof(int));
    clock_t inicio, fim;
    double total;


    //Geracao do conjunto a ser ordenado
	 aleatorio(array, n);
	 //crescente(array, n);
	 //decrescente(array, n);


    //Mostrar o conjunto a ser ordenado
	 //mostrar(array, n);
		

    //Execucao do algoritmo de ordenacao
	 inicio = clock();
    //bolha(array, n);
    //countingsort(array, n);
    //heapsort(array, n);
    //insercao(array, n);
    //mergesort(array, n);
    //quicksort(array, n);
    //selecao(array, n);
    radixsort(array,n);
    //shellsort(array, n);
	 fim = clock();
    total = ((fim - inicio) / (double)CLOCKS_PER_SEC);    


    //Mostrar o conjunto ordenado, tempo de execucao e status da ordenacao
	 //algoritmo.mostrar(array, n);
	 printf("Tempo para ordenar: %f s.\n", total);
	 printf("isOrdenado: %s\n", isOrdenado(array, n) ? "true" : "false");

    //Desalocar o espaco de memoria do array
    free(array);

    return 0;
}

// Fim do arquivo: principal.c

--------------------------------------------------------------------------------

// Início do arquivo: countingsort.c
#include "geracao.h"
#include "countingsort.h"
//=============================================================================
int getMaior(int *array, int n) {
    int maior = array[0];

    for (int i = 0; i < n; i++) {
        if(maior < array[i]){
            maior = array[i];
        }
    }
    return maior;
}
//=============================================================================
void countingsort(int *array, int n) {
    //Array para contar o numero de ocorrencias de cada elemento
    int tamCount = getMaior(array, n) + 1;
    int count[tamCount];
    int ordenado[n];

    //Inicializar cada posicao do array de contagem 
    for (int i = 0; i < tamCount; count[i] = 0, i++);

    //Agora, o count[i] contem o numero de elemento iguais a i
    for (int i = 0; i < n; count[array[i]]++, i++);

    //Agora, o count[i] contem o numero de elemento menores ou iguais a i
    for(int i = 1; i < tamCount; count[i] += count[i-1], i++);

    //Ordenando
    for(int i = n-1; i >= 0; ordenado[count[array[i]]-1] = array[i], count[array[i]]--, i--);

    //Copiando para o array original
    for(int i = 0; i < n; array[i] = ordenado[i], i++);
}
//=============================================================================

// Fim do arquivo: countingsort.c

--------------------------------------------------------------------------------

// Início do arquivo: geracao.h
#ifndef GERACAO_H
#define GERACAO_H
//=============================================================================
#include <stdbool.h>
//=============================================================================
void swap(int *i, int *j);
//=============================================================================
void crescente(int *array, int n);
//=============================================================================
void decrescente(int *array, int n);
//=============================================================================
void aleatorio(int *array, int n);
//=============================================================================
void mostrar(int *array, int n);
//=============================================================================
bool isOrdenado(int *array, int n);
//=============================================================================
#endif

// Fim do arquivo: geracao.h

--------------------------------------------------------------------------------

// Início do arquivo: quicksort.h
#ifndef QUICKSORT_H
#define QUICKSORT_H
//=============================================================================
#include "geracao.h"
//=============================================================================
void quicksortRec(int *array, int esq, int dir);
//=============================================================================
void quicksort(int *array, int n);
//=============================================================================
#endif

// Fim do arquivo: quicksort.h

--------------------------------------------------------------------------------

// Início do arquivo: selecao.c
#include "selecao.h"
//=============================================================================
void selecao(int *array, int n){
    for (int i = 0; i < (n - 1); i++) {
      int menor = i;
      for (int j = (i + 1); j < n; j++){
         if (array[menor] > array[j]){
            menor = j;
         }
      }
      swap(&array[menor], &array[i]);
   }
}
//=============================================================================
// Fim do arquivo: selecao.c

--------------------------------------------------------------------------------

// Início do arquivo: mergesort.c
#include "mergesort.h"
#include <stdlib.h>
//=============================================================================
void mergesort(int *array, int n) {
   mergesortRec(array, 0, n-1);
}
//=============================================================================
void mergesortRec(int *array, int esq, int dir){
   if (esq < dir){
      int meio = (esq + dir) / 2;
      mergesortRec(array, esq, meio);
      mergesortRec(array, meio + 1, dir);
      intercalar(array, esq, meio, dir);
   }
}
//=============================================================================
void intercalar(int* array, int esq, int meio, int dir){
   int n1, n2, i, j, k;

   //Definir tamanho dos dois subarrays
   n1 = meio-esq+1;
   n2 = dir - meio;

   int* a1 = (int*) malloc((n1+1) * sizeof(int)); 
   int* a2 = (int*) malloc((n2+1) * sizeof(int));

   //Inicializar primeiro subarray
   for(i = 0; i < n1; i++){
      a1[i] = array[esq+i];
   }

   //Inicializar segundo subarray
   for(j = 0; j < n2; j++){
      a2[j] = array[meio+j+1];
   }

   //Sentinela no final dos dois arrays
   a1[i] = a2[j] = 0x7FFFFFFF;

   //Intercalacao propriamente dita
   for(i = j = 0, k = esq; k <= dir; k++){
      array[k] = (a1[i] <= a2[j]) ? a1[i++] : a2[j++];
   }
}
//=============================================================================

// Fim do arquivo: mergesort.c

--------------------------------------------------------------------------------

// Início do arquivo: geracao.c
#include "geracao.h"
//=============================================================================
#include <stdio.h>
#include <math.h>
#include <time.h>
#include <stdlib.h>
//=============================================================================
// PROCEDIMENTO PARA TROCAR DOIS ELEMENTOS DO VETOR
void swap(int *i, int *j) {
   int temp = *i;
   *i = *j;
   *j = temp;
}
//=============================================================================
// PROCEDIMENTO PARA PREENCHER UM ARRANJO COM ELEMENTOS EM ORDEM CRESCENTE
void crescente(int *array, int n) {
   for (int i = 0; i < n; i++) {
      array[i] = i;
   }
}
//=============================================================================
// PROCEDIMENTO PARA PREENCHER UM ARRANJO COM ELEMENTOS EM ORDEM DECRESCENTE
void decrescente(int *array, int n) {
   for (int i = 0; i < n; i++) {
      array[i] = n - 1 - i;
   }
}
//=============================================================================
// PROCEDIMENTO PARA PREENCHER UM ARRANJO COM ELEMENTOS EM ORDEM ALEATORIA
void aleatorio(int *array, int n) {
   crescente(array, n);
   srand(time(NULL));
   for (int i = 0; i < n; i++) {
      swap(&array[i], &array[rand() % n]);
   }
}
//=============================================================================
// PROCEDIMENTO PARA PREENCHER UM ARRANJO COM ELEMENTOS DA ENTRADA PADRAO
int entradaPadrao(int *array) {
   int n;
   scanf("%i", &n);
   array = (int*) malloc(n*sizeof(int));
   
   for (int i = 0; i < n; i++) {
      scanf("%i", &array[i]);
   }
   return n;
}
//=============================================================================
// PROCEDIMENTO PARA EXIBIR OS DADOS PRESENTES NO ARRANJO
void mostrar(int *array, int n) {
   printf("[ ");
   for (int i = 0; i < n; i++) {
      printf("%d ", array[i]);
   }
   printf("] \n");
}
//=============================================================================
// PROCEDIMENTO PARA VERIFICAR SE O ARRANJO ESTA ORDENADO
bool isOrdenado(int *array, int n){
   bool resp = true;
   for(int i = 1; i < n; i++){
      if(array[i-1] > array[i]){
         i = n;
         resp = false;
      }
   }
   return resp;
}
//=============================================================================

// Fim do arquivo: geracao.c

--------------------------------------------------------------------------------

// Início do arquivo: countingsort.h
#ifndef COUNTINGSORT_H
#define COUNTINGSORT_H
//=============================================================================
int getMaior(int *array, int n);
//=============================================================================
void countingsort(int *array, int n);
//=============================================================================
#endif

// Fim do arquivo: countingsort.h

--------------------------------------------------------------------------------

// Início do arquivo: selecao.h
#ifndef SELECAO_H
#define SELECAO_H
//=============================================================================
#include "geracao.h"
//=============================================================================
void selecao(int *array, int n);
//=============================================================================
#endif

// Fim do arquivo: selecao.h

--------------------------------------------------------------------------------

// Início do arquivo: radixsort.h
#ifndef RADIXSORT_H
#define RADIXSORT_H
//=============================================================================
int getMax(int *array, int n);
//=============================================================================
void radixsort(int *array, int n);

void radcountingSort(int *array, int n, int exp);
//=============================================================================
#endif

// Fim do arquivo: radixsort.h

--------------------------------------------------------------------------------

// Início do arquivo: radixsort.c
#include "geracao.h"
#include "radixsort.h"
//=============================================================================
int getMax(int *array, int n) {
    int maior = array[0];

    for (int i = 1; i < n; i++) {
        if(maior < array[i]){
            maior = array[i];
        }
    }
    return maior;
}
//=============================================================================
void radixsort(int *array, int n) {
    //Array para contar o numero de ocorrencias de cada elemento
    int max = getMax(array, n);
    for (int exp = 1; max/exp > 0; exp *= 10) {
            radcountingSort(array, n, exp);
    }
}

  void radcountingSort(int *array, int n, int exp) {
        int count[10];
        int output[n];

        //Inicializar cada posicao do array de contagem 
        for (int i = 0; i < 10; count[i] = 0, i++);

        //Agora, o count[i] contem o numero de elemento iguais a i
        for (int i = 0; i < n; i++) {
            count[(array[i]/exp) % 10]++;
        }

        //Agora, o count[i] contem o numero de elemento menores ou iguais a i
        for (int i = 1; i < 10; i++) {
            count[i] += count[i-1];
        }

        //Ordenando
        for (int i = n-1; i >= 0; i--) {
            output[count[(array[i]/exp) % 10] - 1] = array[i];
            count[(array[i]/exp) % 10]--;
        }

        //Copiando para o array original
        for (int i = 0; i < n; i++) {
            array[i] = output[i];
        }
    }
//=============================================================================

// Fim do arquivo: radixsort.c

--------------------------------------------------------------------------------

// Início do arquivo: shellsort.c
#include "shellsort.h"
//=============================================================================
void insercaoPorCor(int *array, int n, int cor, int h){
    for (int i = (h + cor); i < n; i+=h) {
        int tmp = array[i];
        int j = i - h;
        while ((j >= 0) && (array[j] > tmp)) {
            array[j + h] = array[j];
            j-=h;
        }
        array[j + h] = tmp;
    }
}
//=============================================================================
void shellsort(int *array, int n) {
    int h = 1;

    do { h = (h * 3) + 1; } while (h < n);

    do {
        h /= 3;
        for(int cor = 0; cor < h; cor++){
            insercaoPorCor(array, n, cor, h);
        }
    } while (h != 1);
}
//=============================================================================

// Fim do arquivo: shellsort.c

--------------------------------------------------------------------------------

// Início do arquivo: insercao.h
#ifndef INSERCAO_H
#define INSERCAO_H
//=============================================================================
#include "geracao.h"
//=============================================================================
void insercao(int *array, int n);
//=============================================================================
#endif

// Fim do arquivo: insercao.h

--------------------------------------------------------------------------------

// Início do arquivo: mergesort.h
#ifndef MERGESORT_H
#define MERGESORT_H
//=============================================================================
#include "geracao.h"
//=============================================================================
void mergesort(int *array, int n);
//=============================================================================
void mergesortRec(int *array, int esq, int dir);
//=============================================================================
void intercalar(int* array, int esq, int meio, int dir);
//=============================================================================
#endif

// Fim do arquivo: mergesort.h

--------------------------------------------------------------------------------

// Início do arquivo: insercao.c
#include "insercao.h"
//=============================================================================
void insercao(int *array, int n){
    for (int i = 1; i < n; i++) {
      int tmp = array[i];
      int j = i - 1;

      while ((j >= 0) && (array[j] > tmp)) {
         array[j + 1] = array[j];
         j--;
      }
      array[j+1] = tmp;
   }
}
//=============================================================================

// Fim do arquivo: insercao.c

--------------------------------------------------------------------------------

// Início do arquivo: bolha.h
#ifndef BOLHA_H
#define BOLHA_H
//=============================================================================
void bolha(int *array, int n);
//=============================================================================
#endif

// Fim do arquivo: bolha.h

--------------------------------------------------------------------------------

// Início do arquivo: quicksort.c
#include "quicksort.h"
//=============================================================================
void quicksortRec(int *array, int esq, int dir) {
    int i = esq, j = dir;
    int pivo = array[(dir+esq)/2];
    while (i <= j) {
        while (array[i] < pivo) i++;
        while (array[j] > pivo) j--;
        if (i <= j) {
            swap(array + i, array + j);
            i++;
            j--;
        }
    }
    if (esq < j)  quicksortRec(array, esq, j);
    if (i < dir)  quicksortRec(array, i, dir);
}
//=============================================================================
void quicksort(int *array, int n) {
    quicksortRec(array, 0, n-1);
}
//=============================================================================

// Fim do arquivo: quicksort.c

--------------------------------------------------------------------------------

// Início do arquivo: shellsort.h
#ifndef SHELLSORT_H
#define SHELLSORT_H
//=============================================================================
#include "geracao.h"
//=============================================================================
void insercaoPorCor(int *array, int n, int cor, int h);
//=============================================================================
void shellsort(int *array, int n);
//=============================================================================
#endif

// Fim do arquivo: shellsort.h

--------------------------------------------------------------------------------

// Início do arquivo: bolha.c
#include "geracao.h"
#include "bolha.h"
//=============================================================================
void bolha(int *array, int n){
    int i, j;
    for (i = 0; i < (n-1); i--) {
      for (j = 0; j < (n-1); j++) {
         if (array[j] > array[j + 1]) {
            swap(&array[j], &array[j + 1]);
         }
      }
   }
}
//=============================================================================

// Fim do arquivo: bolha.c

--------------------------------------------------------------------------------

// Início do arquivo: heapsort.h
#ifndef HEAPSORT_H
#define HEAPSORT_H
//=============================================================================
#include "geracao.h"
//=============================================================================
void construir(int *array, int tamHeap);
//=============================================================================
int getMaiorFilho(int *array, int i, int tamHeap);
//=============================================================================
void reconstruir(int *array, int tamHeap);
//=============================================================================
void heapsort(int *array, int n);
//=============================================================================
#endif

// Fim do arquivo: heapsort.h

--------------------------------------------------------------------------------

// Início do arquivo: heapsort.c
#include "heapsort.h"
//=============================================================================
void construir(int *array, int tamHeap){
    for(int i = tamHeap; i > 1 && array[i] > array[i/2]; i /= 2){
        swap(array + i, array + i/2);
    }
}
//=============================================================================
int getMaiorFilho(int *array, int i, int tamHeap){
    int filho;
    if (2*i == tamHeap || array[2*i] > array[2*i+1]){
        filho = 2*i;
    } else {
        filho = 2*i + 1;
    }
    return filho;
}
//=============================================================================
void reconstruir(int *array, int tamHeap){
    int i = 1;
    while(i <= (tamHeap/2)){
        int filho = getMaiorFilho(array, i, tamHeap);
        if(array[i] < array[filho]){
            swap(array + i, array + filho);
            i = filho;
        }else{
            i = tamHeap;
        }
    }
}
//=============================================================================
void heapsort(int *array, int n) {
    //Alterar o vetor ignorando a posicao zero
    int arrayTmp[n+1];
    for(int i = 0; i < n; i++){
        arrayTmp[i+1] = array[i];
    }

    //Contrucao do heap
    for(int tamHeap = 2; tamHeap <= n; tamHeap++){
        construir(arrayTmp, tamHeap);
    }

    //Ordenacao propriamente dita
    int tamHeap = n;
    while(tamHeap > 1){
        swap(arrayTmp + 1, arrayTmp + tamHeap--);
        reconstruir(arrayTmp, tamHeap);
    }

    //Alterar o vetor para voltar a posicao zero
    for(int i = 0; i < n; i++){
        array[i] = arrayTmp[i+1];
    }
}
//=============================================================================

// Fim do arquivo: heapsort.c

--------------------------------------------------------------------------------

// Início do arquivo: makefile
all: exec
 
exec: principal.o geracao.o bolha.o countingsort.o radixsort.o heapsort.o insercao.o mergesort.o quicksort.o selecao.o shellsort.o
	gcc -o exec principal.o geracao.o bolha.o countingsort.o radixsort.o heapsort.o insercao.o mergesort.o quicksort.o selecao.o shellsort.o
 
principal.o: principal.c 
	gcc -o principal.o principal.c -c -W -Wall -pedantic
 
bolha.o: bolha.c 
	gcc -o bolha.o bolha.c -c -W -Wall -pedantic

countingsort.o: countingsort.c 
	gcc -o countingsort.o countingsort.c -c -W -Wall -pedantic

radixsort.o: radixsort.c 
	gcc -o radixsort.o radixsort.c -c -W -Wall -pedantic

geracao.o: geracao.c 
	gcc -o geracao.o geracao.c -c -W -Wall -pedantic

heapsort.o: heapsort.c 
	gcc -o heapsort.o heapsort.c -c -W -Wall -pedantic

insercao.o: insercao.c 
	gcc -o insercao.o insercao.c -c -W -Wall -pedantic

mergesort.o: mergesort.c 
	gcc -o mergesort.o mergesort.c -c -W -Wall -pedantic

quicksort.o: quicksort.c 
	gcc -o quicksort.o quicksort.c -c -W -Wall -pedantic

selecao.o: selecao.c 
	gcc -o selecao.o selecao.c -c -W -Wall -pedantic

shellsort.o: shellsort.c 
	gcc -o shellsort.o shellsort.c -c -W -Wall -pedantic

clean:
	rm -rf *.o *~ exec

limpa: 
	rm -rf *.o
// Fim do arquivo: makefile

--------------------------------------------------------------------------------

// Início do arquivo: README.md
# U6 - Árvores binárias
Repositório de códigos da disciplina de Algoritmos e Estrutura de Dados II

// Fim do arquivo: README.md

--------------------------------------------------------------------------------

// Início do arquivo: Principal3.java
/**
 * Principal para Arvore Binaria de Pesquisa
 * @author Max do Val Machado
 */
import java.util.*;

public class Principal3 {
   public static void main(String[] args) throws Exception {
      ArvoreBinaria a1 = new ArvoreBinaria();
      ArvoreBinaria a2 = new ArvoreBinaria();

      Random gerador = new Random();
      gerador.setSeed(4);
      for(int i = 1; i <= 100000; i++){
         int valor = Math.abs(gerador.nextInt());
         if(a1.pesquisar(valor) == false){
            a1.inserir(valor);
            a2.inserir(valor);
         }
         if(i % 100 == 0){
            a1.remover(valor);
            a2.remover(valor);
            a1.remover(a1.getRaiz());
            a2.remover(a2.getRaiz());
         }

         if(ArvoreBinaria.igual(a1, a2) == false){
            System.out.println("Árvores diferentes...");
         }

      }
   }
}

// Fim do arquivo: Principal3.java

--------------------------------------------------------------------------------

// Início do arquivo: TreeSort.java
import java.util.*;
public class TreeSort {
	private No raiz; 
   private int n;

	public TreeSort() {
		raiz = null;
      n = 0;
	}

	public int[] sort() {
      int[] array = new int[n];
      n = 0;
		sort(raiz, array);
      return array;
	}

	private void sort(No i, int[] array) {
		if (i != null) {
			sort(i.esq, array);
			array[n++] = i.elemento;
			sort (i.dir, array);
		}
	}

	public void inserir(int x) {
      n++;
		raiz = inserir(x, raiz);
	}

	private No inserir(int x, No i) {
		if (i == null) {
         i = new No(x);

      } else if (x < i.elemento) {
         i.esq = inserir(x, i.esq);

      } else if (x >= i.elemento) {
         i.dir = inserir(x, i.dir);
      }

		return i;
	}

   public static void main(String[] args){
      TreeSort a = new TreeSort();
      Random gerador = new Random();
      gerador.setSeed(0);
      System.out.print("\nArray: ");
      for(int i = 1; i <= 100; i++){
         int valor = Math.abs(gerador.nextInt() % 1000);
         a.inserir(valor);
         System.out.print(valor + " ");
      }
      System.out.print("\nArray ordenado: ");
      int[] array = a.sort();
      for(int i = 0; i < array.length; i++){
         System.out.print(array[i] + " ");
      }
   }
}

// Fim do arquivo: TreeSort.java

--------------------------------------------------------------------------------

// Início do arquivo: Principal2.java
/**
 * Principal para Arvore Binaria de Pesquisa
 * @author Max do Val Machado
 */
import java.util.*;

public class Principal2 {
    public static void main(String[] args) throws Exception {
        ArvoreBinaria a = new ArvoreBinaria();

        Random gerador = new Random();
        gerador.setSeed(0);
        for(int i = 1; i <= 100000; i++){
            int valor;
            do {
                valor = Math.abs(gerador.nextInt());
            } while (a.pesquisar(valor) == true);

            a.inserir(valor);

            if(i % 1000 == 0){
                double log2 = (Math.log(i) / Math.log(2));
                log2 *= 1.39;
                System.out.println("Número de nós = " + i + " --- log(i,2) = " + log2 + " --- h = " + a.getAltura());
            }
        }
    }
}

// Fim do arquivo: Principal2.java

--------------------------------------------------------------------------------

// Início do arquivo: ArvoreBinaria.java
/**
 * Arvore binaria de pesquisa
 * @author Max do Val Machado
 */
public class ArvoreBinaria {
	private No raiz; // Raiz da arvore.

	/**
	 * Construtor da classe.
	 */
	public ArvoreBinaria() {
		raiz = null;
	}

	/**
	 * Metodo publico iterativo para pesquisar elemento.
	 * @param x Elemento que sera procurado.
	 * @return <code>true</code> se o elemento existir,
	 * <code>false</code> em caso contrario.
	 */
	public boolean pesquisar(int x) {
		return pesquisar(x, raiz);
	}

	/**
	 * Metodo privado recursivo para pesquisar elemento.
	 * @param x Elemento que sera procurado.
	 * @param i No em analise.
	 * @return <code>true</code> se o elemento existir,
	 * <code>false</code> em caso contrario.
	 */
	private boolean pesquisar(int x, No i) {
      boolean resp;
		if (i == null) {
         resp = false;

      } else if (x == i.elemento) {
         resp = true;

      } else if (x < i.elemento) {
         resp = pesquisar(x, i.esq);

      } else {
         resp = pesquisar(x, i.dir);
      }
      return resp;
	}

	/**
	 * Metodo publico iterativo para exibir elementos.
	 */
	public void caminharCentral() {
		System.out.print("[ ");
		caminharCentral(raiz);
		System.out.println("]");
	}

	/**
	 * Metodo privado recursivo para exibir elementos.
	 * @param i No em analise.
	 */
	private void caminharCentral(No i) {
		if (i != null) {
			caminharCentral(i.esq); // Elementos da esquerda.
			System.out.print(i.elemento + " "); // Conteudo do no.
			caminharCentral(i.dir); // Elementos da direita.
		}
	}

	/**
	 * Metodo publico iterativo para exibir elementos.
	 */
	public void caminharPre() {
		System.out.print("[ ");
		caminharPre(raiz);
		System.out.println("]");
	}

	/**
	 * Metodo privado recursivo para exibir elementos.
	 * @param i No em analise.
	 */
	private void caminharPre(No i) {
		if (i != null) {
			System.out.print(i.elemento + " "); // Conteudo do no.
			caminharPre(i.esq); // Elementos da esquerda.
			caminharPre(i.dir); // Elementos da direita.
		}
	}

	/**
	 * Metodo publico iterativo para exibir elementos.
	 */
	public void caminharPos() {
		System.out.print("[ ");
		caminharPos(raiz);
		System.out.println("]");
	}

	/**
	 * Metodo privado recursivo para exibir elementos.
	 * @param i No em analise.
	 */
	private void caminharPos(No i) {
		if (i != null) {
			caminharPos(i.esq); // Elementos da esquerda.
			caminharPos(i.dir); // Elementos da direita.
			System.out.print(i.elemento + " "); // Conteudo do no.
		}
	}


	/**
	 * Metodo publico iterativo para inserir elemento.
	 * @param x Elemento a ser inserido.
	 * @throws Exception Se o elemento existir.
	 */
	public void inserir(int x) throws Exception {
		raiz = inserir(x, raiz);
	}

	/**
	 * Metodo privado recursivo para inserir elemento.
	 * @param x Elemento a ser inserido.
	 * @param i No em analise.
	 * @return No em analise, alterado ou nao.
	 * @throws Exception Se o elemento existir.
	 */
	private No inserir(int x, No i) throws Exception {
		if (i == null) {
         i = new No(x);

      } else if (x < i.elemento) {
         i.esq = inserir(x, i.esq);

      } else if (x > i.elemento) {
         i.dir = inserir(x, i.dir);

      } else {
         throw new Exception("Erro ao inserir!");
      }

		return i;
	}

	/**
	 * Metodo publico para inserir elemento.
	 * @param x Elemento a ser inserido.
	 * @throws Exception Se o elemento existir.
	 */
	public void inserirPai(int x) throws Exception {
      if(raiz == null){
         raiz = new No(x);
      } else if(x < raiz.elemento){
		   inserirPai(x, raiz.esq, raiz);
      } else if(x > raiz.elemento){
		   inserirPai(x, raiz.dir, raiz);
      } else {
         throw new Exception("Erro ao inserirPai!");
      }
	}

	/**
	 * Metodo privado recursivo para inserirPai elemento.
	 * @param x Elemento a ser inserido.
	 * @param i No em analise.
	 * @param pai No superior ao em analise.
	 * @throws Exception Se o elemento existir.
	 */
	private void inserirPai(int x, No i, No pai) throws Exception {
		if (i == null) {
         if(x < pai.elemento){
            pai.esq = new No(x);
         } else {
            pai.dir = new No(x);
         }
      } else if (x < i.elemento) {
         inserirPai(x, i.esq, i);
      } else if (x > i.elemento) {
         inserirPai(x, i.dir, i);
      } else {
         throw new Exception("Erro ao inserirPai!");
      }
	}


	/**
	 * Metodo publico iterativo para remover elemento.
	 * @param x Elemento a ser removido.
	 * @throws Exception Se nao encontrar elemento.
	 */
	public void remover(int x) throws Exception {
		raiz = remover(x, raiz);
	}

	/**
	 * Metodo privado recursivo para remover elemento.
	 * @param x Elemento a ser removido.
	 * @param i No em analise.
	 * @return No em analise, alterado ou nao.
	 * @throws Exception Se nao encontrar elemento.
	 */
	private No remover(int x, No i) throws Exception {

		if (i == null) {
         throw new Exception("Erro ao remover!");

      } else if (x < i.elemento) {
         i.esq = remover(x, i.esq);

      } else if (x > i.elemento) {
         i.dir = remover(x, i.dir);

      // Sem no a direita.
      } else if (i.dir == null) {
         i = i.esq;

      // Sem no a esquerda.
      } else if (i.esq == null) {
         i = i.dir;

      // No a esquerda e no a direita.
      } else {
         i.esq = maiorEsq(i, i.esq);
		}

		return i;
	}

	/**
	 * Metodo para trocar o elemento "removido" pelo maior da esquerda.
	 * @param i No que teve o elemento removido.
	 * @param j No da subarvore esquerda.
	 * @return No em analise, alterado ou nao.
	 */
	private No maiorEsq(No i, No j) {

      // Encontrou o maximo da subarvore esquerda.
		if (j.dir == null) {
			i.elemento = j.elemento; // Substitui i por j.
			j = j.esq; // Substitui j por j.ESQ.

      // Existe no a direita.
		} else {
         // Caminha para direita.
			j.dir = maiorEsq(i, j.dir);
		}
		return j;
	}

	/**
	 * Metodo que retorna o maior elemento da árvore
	 * @return int maior elemento da árvore
	 */
   public int getMaior(){
      int resp = -1;

      if(raiz != null){
         No i;
         for(i = raiz; i.dir != null; i = i.dir);
         resp = i.elemento;
      }

      return resp;
   }


	/**
	 * Metodo que retorna o menor elemento da árvore
	 * @return int menor elemento da árvore
	 */
   public int getMenor(){
      int resp = -1;

      if(raiz != null){
         No i;
         for(i = raiz; i.esq != null; i = i.esq);
         resp = i.elemento;
      }

      return resp;
   }


	/**
	 * Metodo que retorna a altura da árvore
	 * @return int altura da árvore
	 */
   public int getAltura(){
      return getAltura(raiz, 0);
   }


	/**
	 * Metodo que retorna a altura da árvore
	 * @return int altura da árvore
	 */
   public int getAltura(No i, int altura){
      if(i == null){
         altura--;
      } else {
         int alturaEsq = getAltura(i.esq, altura + 1);
         int alturaDir = getAltura(i.dir, altura + 1);
         altura = (alturaEsq > alturaDir) ? alturaEsq : alturaDir;
      }
      return altura;
   }


	/**
	 * Metodo publico iterativo para remover elemento.
	 * @param x Elemento a ser removido.
	 * @throws Exception Se nao encontrar elemento.
	 */
	public void remover2(int x) throws Exception {
      if (raiz == null) {
         throw new Exception("Erro ao remover2!");
      } else if(x < raiz.elemento){
         remover2(x, raiz.esq, raiz);
      } else if (x > raiz.elemento){
         remover2(x, raiz.dir, raiz);
      } else if (raiz.dir == null) {
         raiz = raiz.esq;
      } else if (raiz.esq == null) {
         raiz = raiz.dir;
      } else {
         raiz.esq = maiorEsq(raiz, raiz.esq);
      }
   }

	/**
	 * Metodo privado recursivo para remover elemento.
	 * @param x Elemento a ser removido.
	 * @param i No em analise.
	 * @param pai do No em analise.
	 * @throws Exception Se nao encontrar elemento.
	 */
	private void remover2(int x, No i, No pai) throws Exception {
		if (i == null) {
         throw new Exception("Erro ao remover2!");
      } else if (x < i.elemento) {
         remover2(x, i.esq, i);
      } else if (x > i.elemento) {
         remover2(x, i.dir, i);
      } else if (i.dir == null) {
         pai = i.esq;
      } else if (i.esq == null) {
         pai = i.dir;
      } else {
         i.esq = maiorEsq(i, i.esq);
		}
	}

   public int getRaiz() throws Exception {
      return raiz.elemento;
   }

   public static boolean igual (ArvoreBinaria a1, ArvoreBinaria a2){
      return igual(a1.raiz, a2.raiz);
   }

   private static boolean igual (No i1, No i2){
      boolean resp;
      if(i1 != null && i2 != null){
         resp = (i1.elemento == i2.elemento) && igual(i1.esq, i2.esq) && igual(i1.dir, i2.dir);
      } else if(i1 == null && i2 == null){
         resp = true;
      } else {
         resp = false; 
      }
      return resp;
   }

   public int soma(){
      return soma(raiz);
   }

   public int soma(No i){
      int resp = 0;
      if(i != null){
         resp = i.elemento + soma(i.esq) + soma(i.dir);
      }
      return resp;
   }

   public int quantidadePares(){
      return quantidadePares(raiz);
   }

   public int quantidadePares(No i){
      int resp = 0;
      if(i != null){
         resp = ((i.elemento % 2 == 0) ? 1 : 0) + quantidadePares(i.esq) + quantidadePares(i.dir);
      }
      return resp;
   }

   public boolean hasDiv11(){
      return hasDiv11(raiz);
   }

   public boolean hasDiv11(No i){
      boolean resp = false;
      if(i != null){
         resp = (i.elemento % 11 == 0) || hasDiv11(i.esq) || hasDiv11(i.dir);
      }
      return resp;
   }
}


// Fim do arquivo: ArvoreBinaria.java

--------------------------------------------------------------------------------

// Início do arquivo: Principal.java
/**
 * Principal para Arvore Binaria de Pesquisa
 * @author Max do Val Machado
 */
public class Principal {
    public static void main(String[] args) throws Exception {
        ArvoreBinaria arvoreBinaria = new ArvoreBinaria();
        for(int i=1; i<30; i++){
            arvoreBinaria.inserir(i);
            System.out.print("No. nos: " + i);
            System.out.print("\t Altura: " + arvoreBinaria.getAltura());
            System.out.println("\t log(2): " + Math.log(i)/Math.log(2));
        }
    }
}

// Fim do arquivo: Principal.java

--------------------------------------------------------------------------------

// Início do arquivo: No.java

/**
 * No da arvore binaria
 * @author Max do Val Machado
 */

class No {
    public int elemento; // Conteudo do no.
    public No esq, dir;  // Filhos da esq e dir.

    /**
     * Construtor da classe.
     * @param elemento Conteudo do no.
     */
    public No(int elemento) {
        this(elemento, null, null);
    }

    /**
     * Construtor da classe.
     * @param elemento Conteudo do no.
     * @param esq No da esquerda.
     * @param dir No da direita.
     */
    public No(int elemento, No esq, No dir) {
        this.elemento = elemento;
        this.esq = esq;
        this.dir = dir;
    }
}


// Fim do arquivo: No.java

--------------------------------------------------------------------------------

// Início do arquivo: principal.c
/**
 * Principal para Arvore Binaria de Pesquisa
 * @author Max do Val Machado
 */
#include "arvorebinaria.h"
#include <stdio.h>
#include <stdlib.h>

int main(){

   start();

   inserir(3);
   inserir(5);
   inserir(1);
   inserir(8);
   inserir(2);
   inserir(4);
   inserir(7);
   inserir(6);

   printf("\nInserir: 3, 5, 1, 8, 2, 4, 7 e 6");
   printf("\nCaminhar: central, pre e pos\n");
   caminharCentral();
   caminharPre();
   caminharPos();

   printf("\nRemover: 2");
   printf("\nCaminhar: central, pre e pos\n");
   remover(2);

   caminharCentral();
   caminharPre();
   caminharPos();

   printf("\nVoltando com a árvore inicial");
   printf("\nRemover: 1");
   printf("\nCaminhar: central, pre e pos\n");
   inserir(2);
   remover(1);

   caminharCentral();
   caminharPre();
   caminharPos();

   printf("\nVoltando com a árvore inicial");
   printf("\nRemover: 3");
   printf("\nCaminhar: central, pre e pos\n");
   remover(2);
   inserir(1);
   inserir(2);
   remover(3);

   caminharCentral();
   caminharPre();
   caminharPos();

   return 1;
}

// Fim do arquivo: principal.c

--------------------------------------------------------------------------------

// Início do arquivo: no.h
/**
 * No da arvore binaria
 * @author Max do Val Machado
 */

typedef struct No {
      int elemento;
	struct No *esq, *dir;
} No;

/**
 * Criacao do novo no
 * @param elemento Conteudo do no.
 */
No* novoNo(int);

// Fim do arquivo: no.h

--------------------------------------------------------------------------------

// Início do arquivo: arvorebinaria.h
/**
 * Arvore binaria de pesquisa
 * @author Max do Val Machado
 */

#include "no.h"
#define bool   short
#define true   1
#define false  0

bool pesquisarRec(int, No*);
void caminharCentralRec(No*);
void caminharPreRec(No*);
void caminharPosRec(No*);
void inserirRec(int, No**);
void removerRec(int, No**);
void maiorEsq(No**, No**);

void start();
bool pesquisar(int);
void caminharCentral();
void caminharPre();
void caminharPos();
void inserir(int);
void remover(int);

// Fim do arquivo: arvorebinaria.h

--------------------------------------------------------------------------------

// Início do arquivo: arvorebinaria.c
/**
 * Arvore binaria de pesquisa
 * @author Max do Val Machado
 */
#include <err.h>
#include <stdlib.h>
#include <stdio.h>
#include "arvorebinaria.h"

/*
 * Variavel global
 */
No* raiz;

/**
 * Criar arvore binaria.
 */
void start() {
   raiz = NULL;
}

/**
 * Metodo publico iterativo para pesquisar elemento.
 * @param x Elemento que sera procurado.
 * @return <code>true</code> se o elemento existir,
 * <code>false</code> em caso contrario.
 */
bool pesquisar(int x) {
   return pesquisarRec(x, raiz);
}

/**
 * Metodo privado recursivo para pesquisar elemento.
 * @param x Elemento que sera procurado.
 * @param i No em analise.
 * @return <code>true</code> se o elemento existir,
 * <code>false</code> em caso contrario.
 */
bool pesquisarRec(int x, No* i) {
   bool resp;
   if (i == NULL) {
      resp = false;

   } else if (x == i->elemento) {
      resp = true;

   } else if (x < i->elemento) {
      resp = pesquisarRec(x, i->esq);

   } else {
      resp = pesquisarRec(x, i->dir);
   }
   return resp;
}

/**
 * Metodo publico iterativo para exibir elementos.
 */
void caminharCentral() {
   printf("[ ");
   caminharCentralRec(raiz);
   printf("]\n");
}

/**
 * Metodo privado recursivo para exibir elementos.
 * @param i No em analise.
 */
void caminharCentralRec(No* i) {
   if (i != NULL) {
      caminharCentralRec(i->esq);
      printf("%d ", i->elemento);
      caminharCentralRec(i->dir);
   }
}

/**
 * Metodo publico iterativo para exibir elementos.
 */
void caminharPre() {
   printf("[ ");
   caminharPreRec(raiz);
   printf("]\n");
}

/**
 * Metodo privado recursivo para exibir elementos.
 * @param i No em analise.
 */
void caminharPreRec(No* i) {
   if (i != NULL) {
      printf("%d ", i->elemento);
      caminharPreRec(i->esq);
      caminharPreRec(i->dir);
   }
}

/**
 * Metodo publico iterativo para exibir elementos.
 */
void caminharPos() {
   printf("[ ");
   caminharPosRec(raiz);
   printf("]\n");
}

/**
 * Metodo privado recursivo para exibir elementos.
 * @param i No em analise.
 */
void caminharPosRec(No* i) {
   if (i != NULL) {
      caminharPosRec(i->esq);
      caminharPosRec(i->dir);
      printf("%d ", i->elemento);
   }
}

/**
 * Metodo publico iterativo para inserir elemento.
 * @param x Elemento a ser inserido.
 */
void inserir(int x) {
   inserirRec(x, &raiz);
}

/**
 * Metodo privado recursivo para inserir elemento.
 * @param x Elemento a ser inserido.
 * @param i No** endereco do ponteiro No
 */
void inserirRec(int x, No** i) {
   if (*i == NULL) {
      *i = novoNo(x);

   } else if (x < (*i)->elemento) {
      inserirRec(x, &((*i)->esq));

   } else if (x > (*i)->elemento) {
      inserirRec(x, &((*i)->dir));

   } else {
      errx(1, "Erro ao inserir!");
   }
}

/**
 * Metodo publico iterativo para remover elemento.
 * @param x Elemento a ser removido.
 */
void remover(int x) {
   removerRec(x, &raiz);
}

/**
 * Metodo privado recursivo para remover elemento.
 * @param x Elemento a ser removido.
 * @param i No** endereco do ponteiro No
 */
void removerRec(int x, No** i) {
   if (*i == NULL) {
      errx(1, "Erro ao remover!");

   } else if (x < (*i)->elemento) {
      removerRec(x, &((*i)->esq));

   } else if (x > (*i)->elemento) {
      removerRec(x, &((*i)->dir));

   } else if ((*i)->dir == NULL) {
      No* del = *i;
      *i = (*i)->esq;
      free(del);

   } else if ((*i)->esq == NULL) {
      No* del = *i;
      *i = (*i)->dir;
      free(del);

   } else {
      maiorEsq(i, &((*i)->esq));
   }
}

/**
 * Metodo para trocar no removido pelo maiorEsq.
 * @param i No** endereco do ponteiro No que contem o elemento removido.
 * @param j No** endereco do ponteiro No da subarvore esquerda.
 */
void maiorEsq(No** i, No** j) {
   if ((*j)->dir != NULL) {
      maiorEsq(i, &((*j)->dir));

   } else {
      No* del = *j;
      (*i)->elemento = (*j)->elemento;
      (*j) = (*j)->esq;
      free(del);
   }
}




// Fim do arquivo: arvorebinaria.c

--------------------------------------------------------------------------------

// Início do arquivo: makefile
all: exec

exec: principal.o arvorebinaria.o no.o 
	gcc -o exec principal.o arvorebinaria.o no.o
 
principal.o: principal.c 
	gcc -o principal.o principal.c -c -W -Wall -ansi -pedantic
 
arvorebinaria.o: arvorebinaria.c 
	gcc -o arvorebinaria.o arvorebinaria.c -c -W -Wall -ansi -pedantic
 
no.o: no.c 
	gcc -o no.o no.c -c -W -Wall -ansi -pedantic

clean:
	rm -rf *.o *~ exec

limpa: 
	rm -rf *.o  

// Fim do arquivo: makefile

--------------------------------------------------------------------------------

// Início do arquivo: no.c
/**
 * No da arvore binaria
 * @author Max do Val Machado
 */
#include <stdlib.h>
#include "no.h"

/**
 * Criacao do novo no
 * @param elemento Conteudo do no.
 */
No* novoNo(int elemento) {
   No* novo = (No*) malloc(sizeof(No));
   novo->elemento = elemento;
   novo->esq = NULL;
   novo->dir = NULL;
   return novo;
}

// Fim do arquivo: no.c

--------------------------------------------------------------------------------

// Início do arquivo: no.h
/**
 * No da arvore binaria
 * @author Max do Val Machado
 */
#include <iostream>

using namespace std;

class No {
    public:
        int elemento; // Conteudo do no.
        No *esq, *dir;  // Filhos da esq e dir.
        No(int);
};

// Fim do arquivo: no.h

--------------------------------------------------------------------------------

// Início do arquivo: no.cc
/**
 * No da arvore binaria
 * @author Max do Val Machado
 */

#include "no.h"

/**
 * Construtor da classe.
 * @param elemento Conteudo do no.
 */
No::No(int elemento) {
   this->elemento = elemento;
   this->esq = NULL;
   this->dir = NULL;
}

// Fim do arquivo: no.cc

--------------------------------------------------------------------------------

// Início do arquivo: arvorebinaria.h
/**
 * Arvore binaria de pesquisa
 * @author Max do Val Machado
 */

#include "no.h"

class ArvoreBinaria {
    private:
        No* raiz; // Raiz da arvore.
        bool pesquisar(int, No*);
        void caminharCentral(No*);
        void caminharPre(No*);
        void caminharPos(No*);
        void inserir(int, No* &);
        void remover(int, No* &);
        void maiorEsq(No*, No* &);

    public:
        ArvoreBinaria();
        bool pesquisar(int);
        void caminharCentral();
        void caminharPre();
        void caminharPos();
        void inserir(int);
        void remover(int);
};

// Fim do arquivo: arvorebinaria.h

--------------------------------------------------------------------------------

// Início do arquivo: arvorebinaria.cc
/**
 * Arvore binaria de pesquisa
 * @author Max do Val Machado
 */

#include <err.h>
#include "arvorebinaria.h"

int ArvoreBinaria::soma(int a, int b){
    return a+b;
}

/**
 * Construtor da classe.
 */
ArvoreBinaria::ArvoreBinaria() {
    raiz = NULL;
}

/**
 * Metodo publico iterativo para pesquisar elemento.
 * @param x Elemento que sera procurado.
 * @return <code>true</code> se o elemento existir,
 * <code>false</code> em caso contrario.
 */
bool ArvoreBinaria::pesquisar(int x) {
    return pesquisar(x, raiz);
}

/**
 * Metodo privado recursivo para pesquisar elemento.
 * @param x Elemento que sera procurado.
 * @param i No em analise.
 * @return <code>true</code> se o elemento existir,
 * <code>false</code> em caso contrario.
 */
bool ArvoreBinaria::pesquisar(int x, No* i) {
    bool resp;
    if (i == NULL) {
        resp = false;

    } else if (x == i->elemento) {
        resp = true;

    } else if (x < i->elemento) {
        resp = pesquisar(x, i->esq);

    } else {
        resp = pesquisar(x, i->dir);
    }
    return resp;
}

/**
 * Metodo publico iterativo para exibir elementos.
 */
void ArvoreBinaria::caminharCentral() {
    cout << "[ ";
    caminharCentral(raiz);
    cout << "]\n";
}

/**
 * Metodo privado recursivo para exibir elementos.
 * @param i No em analise.
 */
void ArvoreBinaria::caminharCentral(No* i) {
    if (i != NULL) {
        caminharCentral(i->esq); // Elementos da esquerda.
        cout << i->elemento << " "; // Conteudo do no.
        caminharCentral(i->dir); // Elementos da direita.
    }
}

/**
 * Metodo publico iterativo para exibir elementos.
 */
void ArvoreBinaria::caminharPre() {
    cout << "[ ";
    caminharPre(raiz);
    cout << "]\n";
}

/**
 * Metodo privado recursivo para exibir elementos.
 * @param i No em analise.
 */
void ArvoreBinaria::caminharPre(No* i) {
    if (i != NULL) {
        cout << i->elemento << " "; // Conteudo do no.
        caminharPre(i->esq); // Elementos da esquerda.
        caminharPre(i->dir); // Elementos da direita.
    }
}

/**
 * Metodo publico iterativo para exibir elementos.
 */
void ArvoreBinaria::caminharPos() {
    cout << "[ ";
    caminharPos(raiz);
    cout << "]\n";
}

/**
 * Metodo privado recursivo para exibir elementos.
 * @param i No em analise.
 */
void ArvoreBinaria::caminharPos(No* i) {
    if (i != NULL) {
        caminharPos(i->esq); // Elementos da esquerda.
        caminharPos(i->dir); // Elementos da direita.
        cout << i->elemento << " "; // Conteudo do no.
    }
}

/**
 * Metodo publico iterativo para inserir elemento.
 * @param x Elemento a ser inserido.
 */
void ArvoreBinaria::inserir(int x) {
    inserir(x, raiz);
}

/**
 * Metodo privado recursivo para inserir elemento.
 * @param x Elemento a ser inserido.
 * @param i No em analise.
 */
void ArvoreBinaria::inserir(int x, No* &i) {
    if (i == NULL) {
        i = new No(x);

    } else if (x < i->elemento) {
        inserir(x, i->esq);

    } else if (x > i->elemento) {
        inserir(x, i->dir);

    } else {
        errx(1, "Erro ao inserir!");
    }
}

/**
 * Metodo publico iterativo para remover elemento.
 * @param x Elemento a ser removido.
 */
void ArvoreBinaria::remover(int x) {
    remover(x, raiz);
}

/**
 * Metodo privado recursivo para remover elemento.
 * @param x Elemento a ser removido.
 * @param i No em analise.
 */
void ArvoreBinaria::remover(int x, No* &i) {
    if (i == NULL) {
        errx(1, "Erro ao remover!");

    } else if (x < i->elemento) {
        remover(x, i->esq);

    } else if (x > i->elemento) {
        remover(x, i->dir);

        // Sem no a direita.
    } else if (i->dir == NULL) {
        No* del = i;
        i = i->esq;
        delete del;

        // Sem no a esquerda.
    } else if (i->esq == NULL) {
        No* del = i;
        i = i->dir;
        delete del;

        // No a esquerda e no a direita.
    } else {
        maiorEsq(i, i->esq);
    }
}


/**
 * Metodo para trocar no removido pelo maior elemento da esquerda.
 * @param i No que teve o elemento removido.
 * @param j No da subarvore esquerda.
 */
void ArvoreBinaria::maiorEsq(No* i, No* &j) {
    // Encontrou o maximo da subarvore esquerda.
    if (j->dir == NULL) {
        No* del = j;
        i->elemento = j->elemento; // Substitui i por j.
        j = j->esq; // Substitui j por j.ESQ.
        delete del;

        // Existe no a direita.
    } else {
        maiorEsq(i, j->dir); // Caminha para direita.
    }
}

// Fim do arquivo: arvorebinaria.cc

--------------------------------------------------------------------------------

// Início do arquivo: makefile
all: exec
 
exec: principal.o arvorebinaria.o no.o 
	g++ -o exec principal.o arvorebinaria.o no.o
 
principal.o: principal.cc arvorebinaria.h no.h
	g++ -o principal.o principal.cc -c -W -Wall -ansi -pedantic
 
arvorebinaria.o: arvorebinaria.cc arvorebinaria.h no.h
	g++ -o arvorebinaria.o arvorebinaria.cc -c -W -Wall -ansi -pedantic
 
no.o: no.cc no.h
	g++ -o no.o no.cc -c -W -Wall -ansi -pedantic

clean:
	rm -rf *.o *~ exec

// Fim do arquivo: makefile

--------------------------------------------------------------------------------

// Início do arquivo: principal.cc
/**
 * Principal para Arvore Binaria de Pesquisa
 * @author Max do Val Machado
 */
#include "arvorebinaria.h"
#include <iostream>
using namespace std;

int main(){//int argc, char** argv){
   ArvoreBinaria* arvoreBinaria = new ArvoreBinaria();

   arvoreBinaria->inserir(3);
   arvoreBinaria->inserir(5);
   arvoreBinaria->inserir(1);
   arvoreBinaria->inserir(8);
   arvoreBinaria->inserir(2);
   arvoreBinaria->inserir(4);
   arvoreBinaria->inserir(7);
   arvoreBinaria->inserir(6);

   cout << "\nInserir: 3, 5, 1, 8, 2, 4, 7 e 6";
   cout << "\nCaminhar: central, pre e pos\n";
   arvoreBinaria->caminharCentral();
   arvoreBinaria->caminharPre();
   arvoreBinaria->caminharPos();


   cout << "\nRemover: 2";
   cout << "\nCaminhar: central, pre e pos\n";
   arvoreBinaria->remover(2);

   arvoreBinaria->caminharCentral();
   arvoreBinaria->caminharPre();
   arvoreBinaria->caminharPos();

   cout << "\nVoltando com a árvore inicial";
   cout << "\nRemover: 1";
   cout << "\nCaminhar: central, pre e pos\n";
   arvoreBinaria->inserir(2);
   arvoreBinaria->remover(1);

   arvoreBinaria->caminharCentral();
   arvoreBinaria->caminharPre();
   arvoreBinaria->caminharPos();

   cout << "\nVoltando com a árvore inicial";
   cout << "\nRemover: 3";
   cout << "\nCaminhar: central, pre e pos\n";
   arvoreBinaria->remover(2);
   arvoreBinaria->inserir(1);
   arvoreBinaria->inserir(2);
   arvoreBinaria->remover(3);

   arvoreBinaria->caminharCentral();
   arvoreBinaria->caminharPre();
   arvoreBinaria->caminharPos();


   return 1;
}

// Fim do arquivo: principal.cc

--------------------------------------------------------------------------------

// Início do arquivo: Celula.java
class Celula {
   Contato contato;
   Celula prox;

   public Celula (){
      this(null, null);
   }

   public Celula(Contato contato){
      this(contato, null);
   }

   public Celula (Contato contato, Celula prox){
      this.contato = contato;
      this.prox = prox;
   }
}

// Fim do arquivo: Celula.java

--------------------------------------------------------------------------------

// Início do arquivo: Contato.java
class Contato {
   public String nome;
   public String telefone;
   public String email;
   public int cpf;

   public Contato(){
      this("","","",-1);
   }
   public Contato(String nome, String telefone, String email, int cpf){
      this.nome = nome;
      this.telefone = telefone;
      this.email = email;
      this.cpf = cpf;
   }
}

// Fim do arquivo: Contato.java

--------------------------------------------------------------------------------

// Início do arquivo: No.java

class No {
	public char letra;
	public No esq, dir;
	public Celula primeiro, ultimo;
	
	public No(char letra) {
		this.letra = letra;
		this.esq = this.dir = null;
		primeiro = ultimo = new Celula();
	}
}

// Fim do arquivo: No.java

--------------------------------------------------------------------------------

// Início do arquivo: Agenda.java
public class Agenda {
	private No raiz; 

	public Agenda() {
		raiz = new No ('M');
		raiz.esq = new No ('G');
		raiz.dir = new No ('T');
		raiz.esq.esq = new No ('A');
		//inserir todas as 26 letras do alfabeto...
	}

	public boolean pesquisarNome(String nome) {
		return pesquisarNome(raiz, nome);
	}

	private boolean pesquisarNome(No no, String nome) {
      boolean resp;
		if (no == null) { 
         resp = false;
      } else if (Char.toUpper(nome.charAt(0)) == no.letra) { 
         resp = false;
         for(Celula i = no.primeiro.prox; (!resp && i != null); i = i.prox){
            if(i.contato.nome.equals(nome) == true){
               resp = true;
            }
         }
      } else if (Char.toUpper(nome.charAt(0)) < no.letra) { 
         resp = pesquisarNome(no.esq, nome); 

      } else { 
         resp = pesquisarNome(no.dir, nome); 
      }
      return resp;
	}

	public void inserir(Contato contato) throws Exception {
		if(Character.isLetter(contato.nome.charAt(0))){
			raiz = inserir(raiz, contato);	
		} else {
			throw new Exception("Erro ao inserir!");
		}
	}

	private No inserir(No no, Contato contato) throws Exception {
		// insere o nó com a letra
		if (no == null) {
			no = new no(Character.toUpperCase(contato.nome.charAt(0)));
			no.ultimo.prox = new Celula(contato);
			no.ultimo = no.ultimo.prox;	
		
		// insere o contatinho
		} else if (Character.toUpperCase(contato.nome.charAt(0)) == no.letra) { 
			no.ultimo.prox = new Celula(contato);
			no.ultimo = no.ultimo.prox;
		
		// letra menor, caminha para a esquerda
		} else if (Character.toUpperCase(contato.nome.charAt(0)) < no.letra) { 
			no.esq = inserir(no.esq, contato);

		// letra maior, caminha para a direita
		} else { 
			no.dir = inserir(no.dir, contato);
		}
		return no;
	}
	
	public boolean pesquisar(int cpf) {
		return pesquisar(raiz, cpf);
	}

	private boolean pesquisar(No no, int cpf) {
		boolean resp = false;
		if (no != null) {
			resp = pesquisar(no.primeiro.prox, cpf);
			if(resp == false){
				resp = pesquisar(no.esq, cpf);
				if(resp == false){
					resp = pesquisar(no.dir, cpf);
				}
			}
		}
		return resp;
	}

	private boolean pesquisar(Celula i, int cpf){
		//efeuar a pesquisa na lista a partir do i
	}

}








// Fim do arquivo: Agenda.java

--------------------------------------------------------------------------------

// Início do arquivo: Celula.java
/**
 * Celula (pilha, lista e fila dinamica)
 * @author Max do Val Machado
 * @version 2 01/2015
 */
class Celula {
	public int elemento; // Elemento inserido na celula.
	public Celula prox; // Aponta a celula prox.


	/**
	 * Construtor da classe.
	 */
	public Celula() {
		this(0);
	}

	/**
	 * Construtor da classe.
	 * @param elemento int inserido na celula.
	 */
	public Celula(int elemento) {
      this.elemento = elemento;
      this.prox = null;
	}
}

// Fim do arquivo: Celula.java

--------------------------------------------------------------------------------

// Início do arquivo: CelulaMat.java
class CelulaMat {
   public int elemento;
   public CelulaMat inf, sup, esq, dir;
   public Celula primeiro, ultimo;

   public CelulaMat(){
      this(0);
   }

   public CelulaMat(int elemento){
      this(elemento, null, null, null, null);
   }

   public CelulaMat(int elemento, CelulaMat inf, CelulaMat sup, CelulaMat esq, CelulaMat dir){
      this.elemento = elemento;
      this.inf = inf;
      this.sup = sup;
      this.esq = esq;
      this.dir = dir;
      this.primeiro = this.ultimo = new Celula();
   }
}

// Fim do arquivo: CelulaMat.java

--------------------------------------------------------------------------------

// Início do arquivo: MatrizDeLista.java
class MatrizDeLista {
   private CelulaMat inicio;
   private int linha, coluna;

   public MatrizDeLista(){
      this(3, 3);
   }

   public MatrizDeLista(int linha, int coluna){
      this.linha = linha;
      this.coluna = coluna;

      //alocar todas as celulas da matriz!!!
      //igual ao construtor da matriz flexível!!! 
      //Lembre-se que cada lista eh criada atutomaticamente no construtor de CelulaMat().
   }


   boolean pesquisar(int elemento){
      boolean resp = false;

      for(CelulaMat i = inicio; !resp && i != null; i = i.dir){
         for(CelulaMat j = i; !resp && j != null; j = j.inf){
            if(j.elemento == elemento){
               resp = true;
            } else {
               for(Celula k = j.primeiro.prox; k != null; k = k.prox){
                  if(k.elemento == elemento){
                     resp = true;
                     k = j.ultimo;
                  }
               }
            }
         }
      }

      return resp;
   }

   boolean pesquisar(int i, int j, int elemento){
      boolean resp = false;
      CelulaMat pi, pj;

      for(int ii = 0, pi = inicio; ii < i; ii++, pi = pi.dir){
         for(int jj = 0, pj = pi; jj < j; jj++, pj = pj.inf);
      }

      for(Celula k = pj.primeiro.prox; k != null; k = k.prox){
         if(k.elemento == elemento){
            resp = true;
            k = j.ultimo;
         }
      }

   }

}

// Fim do arquivo: MatrizDeLista.java

--------------------------------------------------------------------------------

// Início do arquivo: ArvoreArvore.java
/**
 * Arvore de arvore
 * @author Max do Val Machado
 */
public class ArvoreArvore {
	private No raiz; // Raiz da arvore.

	/**
	 * Construtor da classe.
	 */
	public ArvoreArvore() {
		raiz = null;
      inserir('M');
      inserir('T');
      inserir('F');
      //os outros 23 caracteres.
	}

   public void inserir(char letra){
      //igualzinho (mesmo, de verdade) ao da árvore binária padrão!!!
   }


   public void inserir(String s){
      inserir(s, raiz);
   }

   public void inserir(String s, No i) throws Exception {
		if (i == null) {
         throw new Exception("Erro ao inserir: caractere invalido!");

      } else if (s.charAt(0) < i.elemento) {
         inserir(x, i.esq);

      } else if (s.charAt(0) > i.elemento) {
         inserir(x, i.dir);

      } else {
         i.outro = inserir(s, i.outro);
      }
   }


	private No2 inserir(String s, No2 i) throws Exception {
		if (i == null) {
         i = new No2(x);

      } else if (s.compareTo(i.elemento) < 0) {
         i.esq = inserir(x, i.esq);

      } else if (s.compareTo(i.elemento) > 0) {
         i.dir = inserir(x, i.dir);

      } else {
         throw new Exception("Erro ao inserir: elemento existente!");
      }

		return i;
	}


   public void mostrar(){
      mostrar(raiz);
   }

   public void mostrar(No i){
      if (i != null){
         mostrar(i.esq);
         //System.out.println("Letra: " + i.elemento);
         mostrar(i.outra);
         mostrar(i.dir);
      }
   }

   public void mostrar(No2 i){
      if (i != null){
         mostrar(i.esq);
         System.out.println(i.elemento);
         mostrar(i.dir);
      }
   }



   public boolean hasStringTam10(){
      return hasStringTam10(raiz);
   }

   public boolean hasStringTam10(No i){
      boolean resp = false;
      if(i != null){
         resp = hasStringTam10(i.outro) || hasStringTam10(i.esq) || hasStringTam10(i.dir);
      }
      return resp;
   }

   public boolean hasStringTam10(No2 i){
      boolean resp = false;
      if(i != null){
         resp = i.elemento.length() == 10 || hasStringTam10(i.esq) || hasStringTam10(i.dir);
      }
      return resp;
   }


   public boolean hasStringTam10(char c){
      return hasStringTam10(raiz, c);
   }

   public boolean hasStringTam10(No i, char c){
      boolean resp;
		if (i == null) { 
         resp = false;

      } else if (c < i.elemento) { 
         resp = hasStringTam10(i.esq, c); 

      } else if (c > i.elemento) { 
         resp = hasStringTam10(i.dir, c); 
      
      } else { 
         resp = hasStringTam10(i.outro); 
      }
      return resp;
   } 





	/**
	 * Metodo publico iterativo para pesquisar elemento.
	 * @param elemento Elemento que sera procurado.
	 * @return <code>true</code> se o elemento existir,
	 * <code>false</code> em caso contrario.
	 */
	public boolean pesquisar(String elemento) {
		return pesquisar(raiz, elemento);
	}

	private boolean pesquisar(No no, String x) {
      boolean resp;
		if (no == null) { 
         resp = false;

      } else if (x.charAt(0) < no.elemento) { 
         resp = pesquisar(no.esq, x); 

      } else if (x.charAt(0) > no.elemento) { 
         resp = pesquisar(no.dir, x); 
      
      } else { 
         resp = pesquisarSegundaArvore(no.outro, x); 
      }
      return resp;
	}

	private boolean pesquisarSegundaArvore(No2 no, String x) {
      boolean resp;
		if (no == null) { 
         resp = false;

      } else if (x.compareTo(no.elemento) < 0) { 
         resp = pesquisarSegundaArvore(no.esq, x); 

      } else if (x.compareTo(no.elemento) > 0) { 
         resp = pesquisarSegundaArvore(no.dir, x); 

      } else { 
         resp = true; 
      }
      return resp;
	}


   public int contPalavra(char letra){
      return contPalavra(letra, raiz);
   }

   public int contPalavra(char letra, No i) throws Exception {
      int resp = 0;

		if (i == null) {
         throw new Exception("Erro ao pesquisar: caractere invalido!");

      } else if (letra < i.elemento) {
         resp = contPalavra(letra, i.esq);

      } else if (letra > i.elemento) {
         resp = contPalavra(letra, i.dir);

      } else {
         resp = contPalavra(i.outro);
      }

      return resp;
   }

   public int contPalavra(No2 i){
      int resp = 0;
      if(i != null){
         resp = 1 + contPalavra(i.esq) + contPalavra(i.dir);
      }
      return resp;
   }
}


















// Fim do arquivo: ArvoreArvore.java

--------------------------------------------------------------------------------

// Início do arquivo: No2.java
class No2 {
	public String elemento; // Conteudo do no.
	public No2 esq; // No da esquerda.
	public No2 dir; // No da direita.
	
   /**
	 * Construtor da classe.
	 * @param elemento Conteudo do no.
	 */
	No2(String elemento) {
		this.elemento = elemento;
		this.esq = this.dir = null;
	}

	/**
	 * Construtor da classe.
	 * @param elemento Conteudo do no.
	 * @param esq No2 da esquerda.
	 * @param dir No2 da direita.
	 */
	No2(String elemento, No2 esq, No2 dir) {
		this.elemento = elemento;
		this.esq = esq;
		this.dir = dir;
	}
}

// Fim do arquivo: No2.java

--------------------------------------------------------------------------------

// Início do arquivo: No.java
class No {
	public char elemento; // Conteudo do no.
	public No esq; // No da esquerda.
	public No dir; // No da direita.
   public No2 outro;
	
   /**
	 * Construtor da classe.
	 * @param elemento Conteudo do no.
	 */
	No(char elemento) {
		this.elemento = elemento;
		this.esq = this.dir = null;
      this.outro = null;
	}

	/**
	 * Construtor da classe.
	 * @param elemento Conteudo do no.
	 * @param esq No da esquerda.
	 * @param dir No da direita.
	 */
	No(char elemento, No esq, No dir) {
		this.elemento = elemento;
		this.esq = esq;
		this.dir = dir;
      this.outro = null;
	}
}







// Fim do arquivo: No.java

--------------------------------------------------------------------------------

// Início do arquivo: README.md
# AEDII
Repositório de códigos da disciplina de Algoritmos e Estrutura de Dados II

// Fim do arquivo: README.md

--------------------------------------------------------------------------------

// Início do arquivo: Fila.java
/**
 * Fila estatica
 * @author Max do Val Machado
 * @version 2 01/2015
 */
class Fila {
   private int[] array;
   private int primeiro; // Remove do indice "primeiro".
   private int ultimo; // Insere no indice "ultimo".


   /**
    * Construtor da classe.
    */
   public Fila () {
      this(6);
   }


   /**
    * Construtor da classe.
    * @param tamanho Tamanho da fila.
    */
   public Fila (int tamanho){
      array = new int[tamanho+1];
      primeiro = ultimo = 0;
   }


   /**
    * Insere um elemento na ultima posicao da fila.
    * @param x int elemento a ser inserido.
    * @throws Exception Se a fila estiver cheia.
    */
   public void inserir(int x) throws Exception {

      //validar insercao
      if (((ultimo + 1) % array.length) == primeiro) {
         throw new Exception("Erro ao inserir!");
      }

      array[ultimo] = x;
      ultimo = (ultimo + 1) % array.length;
   }


   /**
    * Remove um elemento da primeira posicao da fila e movimenta 
    * os demais elementos para o primeiro da mesma.
    * @return resp int elemento a ser removido.
    * @throws Exception Se a fila estiver vazia.
    */
   public int remover() throws Exception {

      //validar remocao
      if (primeiro == ultimo) {
         throw new Exception("Erro ao remover!");
      }

      int resp = array[primeiro];
      primeiro = (primeiro + 1) % array.length;
      return resp;
   }


   /**
    * Mostra os array separados por espacos.
    */
   public void mostrar (){
      System.out.print("[ ");

      for(int i = primeiro; i != ultimo; i = ((i + 1) % array.length)) {
         System.out.print(array[i] + " ");
      }

      System.out.println("]");
   }

   public void mostrarRec(){
      System.out.print("[ ");
      mostrarRec(primeiro);
      System.out.println("]");
   }

   public void mostrarRec(int i){
      if(i != ultimo){
         System.out.print(array[i] + " ");
         mostrarRec((i + 1) % array.length);
      }
   }


   /**
    * Retorna um boolean indicando se a fila esta vazia
    * @return boolean indicando se a fila esta vazia
    */
   public boolean isVazia() {
      return (primeiro == ultimo); 
   }
}

// Fim do arquivo: Fila.java

--------------------------------------------------------------------------------

// Início do arquivo: ListaOrdenada.java
/**
 * Lista estatica
 * @author Max do Val Machado
 * @version 2 01/2015
 */
class ListaOrdenada {
   private int[] array;
   private int n;


   /**
    * Construtor da classe.
    */
   public ListaOrdenada () {
      this(6);
   }


   /**
    * Construtor da classe.
    * @param tamanho Tamanho da lista.
    */
   public ListaOrdenada (int tamanho){
      array = new int[tamanho];
      n = 0;
   }


   /**
    * Insere um elemento 
    * @param x int elemento a ser inserido.
    * @throws Exception Se a lista estiver cheia ou a posicao invalida.
    */
   public void inserir(int x) throws Exception {

      //validar insercao
      if(n >= array.length){
         throw new Exception("Erro ao inserir!");
      }

      //procurar a posicao de insercao e movimentando os demais elementos para o fim do array
      int pos;
      for(pos = n-1; pos >= 0 && array[pos] > x; pos--){
         array[pos+1] = array[pos];
      }
      array[pos+1] = x;
      n++;
   }

   /**
    * Retorna verdadeiro/falso indicando se o array esta ordenado
    * @return boolean indicando se o array esta ordenado
    */
   public boolean isOrdenado(){
      boolean resp = true;
      for(int i = 1; i < n; i++){
         if(array[i] < array[i-1]){
            i = n;
            resp = false;
         }
      }
      return resp;
   }


   /**
    * Remove um elemento da primeira posicao da lista e movimenta 
    * os demais elementos para o inicio da mesma.
    * @return resp int elemento a ser removido.
    * @throws Exception Se a lista estiver vazia.
    */
   public int removerInicio() throws Exception {

      //validar remocao
      if (n == 0) {
         throw new Exception("Erro ao remover!");
      }

      int resp = array[0];
      n--;

      for(int i = 0; i < n; i++){
         array[i] = array[i+1];
      }

      return resp;
   }


   /**
    * Remove um elemento da ultima posicao da lista.
    * @return resp int elemento a ser removido.
    * @throws Exception Se a lista estiver vazia.
    */
   public int removerFim() throws Exception {

      //validar remocao
      if (n == 0) {
         throw new Exception("Erro ao remover!");
      }

      return array[--n];
   }


   /**
    * Remove um elemento de uma posicao especifica da lista e 
    * movimenta os demais elementos para o inicio da mesma.
    * @param pos Posicao de remocao.
    * @return resp int elemento a ser removido.
    * @throws Exception Se a lista estiver vazia ou a posicao for invalida.
    */
   public int remover(int pos) throws Exception {

      //validar remocao
      if (n == 0 || pos < 0 || pos >= n) {
         throw new Exception("Erro ao remover!");
      }

      int resp = array[pos];
      n--;

      for(int i = pos; i < n; i++){
         array[i] = array[i+1];
      }

      return resp;
   }


   /**
    * Mostra os elementos da lista separados por espacos.
    */
   public void mostrar (){
      System.out.print("[ ");
      for(int i = 0; i < n; i++){
         System.out.print(array[i] + " ");
      }
      System.out.println("]");
   }


   /**
    * Procura um elemento e retorna se ele existe.
    * @param x int elemento a ser pesquisado.
    * @return <code>true</code> se o array existir,
    * <code>false</code> em caso contrario.
    */
   public boolean pesquisar(int x) {
      boolean retorno = false;
      for (int i = 0; i < n && retorno == false; i++) {
         retorno = (array[i] == x);
      }
      return retorno;
   }
}

// Fim do arquivo: ListaOrdenada.java

--------------------------------------------------------------------------------

// Início do arquivo: PrincipalFila.java
/**
 * Fila estatica
 * @author Max do Val Machado
 * @version 2 01/2015
 */
class PrincipalFila {
   public static void main(String[] args) throws Exception {
      System.out.println("==== FILA ESTATICA ====");
      Fila fila = new Fila();
      int x1, x2, x3;

      fila.inserir(5);
      fila.inserir(7);
      fila.inserir(8);
      fila.inserir(9);

      System.out.println("Apos insercoes(5, 7, 8, 9): ");
      fila.mostrar();

      x1 = fila.remover();
      x2 = fila.remover();

      System.out.println("Apos remocoes (" + x1 + ", " + x2 + "):");
      fila.mostrar();

      fila.inserir(3);
      fila.inserir(4);


      System.out.println("Apos insercoes(3, 4): ");
      fila.mostrar();

      x1 = fila.remover();
      x2 = fila.remover();
      x3 = fila.remover();

      System.out.println("Apos remocoes (" + x1 + ", " + x2 + ", " + x3 + "):");
      fila.mostrar();

      fila.inserir(4);
      fila.inserir(5);

      System.out.println("Apos insercoes(4, 5): ");
      fila.mostrar();

      x1 = fila.remover();
      x2 = fila.remover();

      System.out.println("Apos remocoes (" + x1 + ", " + x2 + "):");
      fila.mostrar();

      fila.inserir(6);
      fila.inserir(7);

      System.out.println("Apos insercoes(6, 7): ");
      fila.mostrar();

      x1 = fila.remover();

      System.out.println("Apos remocao (" + x1 + "): ");
      fila.mostrar();
   }
}

// Fim do arquivo: PrincipalFila.java

--------------------------------------------------------------------------------

// Início do arquivo: Lista.java
/**
 * Lista estatica
 * @author Max do Val Machado
 * @version 2 01/2015
 */
class Lista {
   private int[] array;
   private int n;


   /**
    * Construtor da classe.
    */
   public Lista () {
      this(6);
   }


   /**
    * Construtor da classe.
    * @param tamanho Tamanho da lista.
    */
   public Lista (int tamanho){
      array = new int[tamanho];
      n = 0;
   }


   /**
    * Insere um elemento na primeira posicao da lista e move os demais
    * elementos para o fim da lista.
    * @param x int elemento a ser inserido.
    * @throws Exception Se a lista estiver cheia.
    */
   public void inserirInicio(int x) throws Exception {

      //validar insercao
      if(n >= array.length){
         throw new Exception("Erro ao inserir!");
      } 

      //levar elementos para o fim do array
      for(int i = n; i > 0; i--){
         array[i] = array[i-1];
      }

      array[0] = x;
      n++;
   }


   /**
    * Insere um elemento na ultima posicao da lista.
    * @param x int elemento a ser inserido.
    * @throws Exception Se a lista estiver cheia.
    */
   public void inserirFim(int x) throws Exception {

      //validar insercao
      if(n >= array.length){
         throw new Exception("Erro ao inserir!");
      }

      array[n] = x;
      n++;
   }


   /**
    * Insere um elemento em uma posicao especifica e move os demais
    * elementos para o fim da lista.
    * @param x int elemento a ser inserido.
    * @param pos Posicao de insercao.
    * @throws Exception Se a lista estiver cheia ou a posicao invalida.
    */
   public void inserir(int x, int pos) throws Exception {

      //validar insercao
      if(n >= array.length || pos < 0 || pos > n){
         throw new Exception("Erro ao inserir!");
      }

      //levar elementos para o fim do array
      for(int i = n; i > pos; i--){
         array[i] = array[i-1];
      }

      array[pos] = x;
      n++;
   }


   /**
    * Remove um elemento da primeira posicao da lista e movimenta 
    * os demais elementos para o inicio da mesma.
    * @return resp int elemento a ser removido.
    * @throws Exception Se a lista estiver vazia.
    */
   public int removerInicio() throws Exception {

      //validar remocao
      if (n == 0) {
         throw new Exception("Erro ao remover!");
      }

      int resp = array[0];
      n--;

      for(int i = 0; i < n; i++){
         array[i] = array[i+1];
      }

      return resp;
   }


   /**
    * Remove um elemento da ultima posicao da lista.
    * @return resp int elemento a ser removido.
    * @throws Exception Se a lista estiver vazia.
    */
   public int removerFim() throws Exception {

      //validar remocao
      if (n == 0) {
         throw new Exception("Erro ao remover!");
      }

      return array[--n];
   }


   /**
    * Remove um elemento de uma posicao especifica da lista e 
    * movimenta os demais elementos para o inicio da mesma.
    * @param pos Posicao de remocao.
    * @return resp int elemento a ser removido.
    * @throws Exception Se a lista estiver vazia ou a posicao for invalida.
    */
   public int remover(int pos) throws Exception {

      //validar remocao
      if (n == 0 || pos < 0 || pos >= n) {
         throw new Exception("Erro ao remover!");
      }

      int resp = array[pos];
      n--;

      for(int i = pos; i < n; i++){
         array[i] = array[i+1];
      }

      return resp;
   }


   /**
    * Mostra os elementos da lista separados por espacos.
    */
   public void mostrar (){
      System.out.print("[ ");
      for(int i = 0; i < n; i++){
         System.out.print(array[i] + " ");
      }
      System.out.println("]");
   }


   /**
    * Procura um elemento e retorna se ele existe.
    * @param x int elemento a ser pesquisado.
    * @return <code>true</code> se o array existir,
    * <code>false</code> em caso contrario.
    */
   public boolean pesquisar(int x) {
      boolean retorno = false;
      for (int i = 0; i < n && retorno == false; i++) {
         retorno = (array[i] == x);
      }
      return retorno;
   }
}

// Fim do arquivo: Lista.java

--------------------------------------------------------------------------------

// Início do arquivo: PrincipalLista.java
/**
 * Lista estatica
 * @author Max do Val Machado
 * @version 2 01/2015
 */
class PrincipalLista {
   public static void main(String[] args) throws Exception {
      System.out.println("==== LISTA ESTATICA ====");
      Lista lista = new Lista();
      int x1, x2, x3;

      lista.inserirInicio(1);
      lista.inserirInicio(0);
      lista.inserirFim(2);
      lista.inserirFim(3);
      lista.inserir(4, 3);
      lista.inserir(5, 2);

      System.out.print("Apos insercoes: ");
      lista.mostrar();

      x1 = lista.removerInicio();
      x2 = lista.removerFim();
      x3 = lista.remover(2);

      System.out.print("Apos remocoes (" + x1 + ", " + x2 + ", " + x3 + "):");
      lista.mostrar();
   }
}

// Fim do arquivo: PrincipalLista.java

--------------------------------------------------------------------------------

// Início do arquivo: Fila2Pilha.java
/**
 * Fila 2 Pilha
 * @author Felipe Cunha
 * @version 1 1/2017
 */

 public class Fila2Pilha{

   private Fila f1, f2;

   public Fila2Pilha(){
     f1 = new Fila(6);
     f2 = new Fila(6);
   }

   public Fila2Pilha(int tamanho){
     f1 = new Fila (tamanho);
     f2 = new Fila (tamanho);
   }

   public void empilhar(int elemento) throws Exception {
     while(!f1.isVazia()){
       f2.inserir(f1.remover());
     }

     f1.inserir(elemento);

     while(!f2.isVazia()){
       f1.inserir(f2.remover());
     }
   }

   public int desempilhar() throws Exception {
     return f1.remover();
   }

   public void mostrar(){
     f1.mostrar();
   }

   public boolean isVazia(){
     return f1.isVazia();
   }

   public static void main(String []args) throws Exception{
     Fila2Pilha p1 = new Fila2Pilha();

     p1.empilhar(10);
     p1.empilhar(11);
     p1.empilhar(15);
     p1.empilhar(20);

     p1.mostrar();

   }
 }

// Fim do arquivo: Fila2Pilha.java

--------------------------------------------------------------------------------

// Início do arquivo: PrincipalListaOrdenada.java
import java.util.*;
/**
 * Lista estatica
 * @author Max do Val Machado
 * @version 2 01/2015
 */
class PrincipalListaOrdenada {
   public static void main(String[] args) throws Exception {
		Random gerador = new Random();
      System.out.println("==== LISTA ESTATICA ====");
      ListaOrdenada lista = new ListaOrdenada(1000);

      for(int i = 0; i < 1000; i++){
         lista.inserir(Math.abs(gerador.nextInt()) % 1000);
      }

      System.out.print("Apos insercoes: ");
      lista.mostrar();
      System.out.print("Ordenada: " +  lista.isOrdenado());
   }
}

// Fim do arquivo: PrincipalListaOrdenada.java

--------------------------------------------------------------------------------

// Início do arquivo: lista.c
/**
 * Lista estatica
 * @author Max do Val Machado
 * @version 2 01/2015
 */
#include <stdio.h>
#include <stdlib.h>

#define MAXTAM    6
#define bool      short
#define true      1
#define false     0

int array[MAXTAM];   // Elementos da pilha 
int n;               // Quantidade de array.


/**
 * Inicializacoes
 */
void start(){
   n = 0;
}


/**
 * Insere um elemento na primeira posicao da lista e move os demais
 * elementos para o fim da 
 * @param x int elemento a ser inserido.
 */
void inserirInicio(int x) {
   int i;

   //validar insercao
   if(n >= MAXTAM){
      printf("Erro ao inserir!");
      exit(1);
   } 

   //levar elementos para o fim do array
   for(i = n; i > 0; i--){
      array[i] = array[i-1];
   }

   array[0] = x;
   n++;
}


/**
 * Insere um elemento na ultima posicao da 
 * @param x int elemento a ser inserido.
 */
void inserirFim(int x) {

   //validar insercao
   if(n >= MAXTAM){
      printf("Erro ao inserir!");
      exit(1);
   }

   array[n] = x;
   n++;
}


/**
 * Insere um elemento em uma posicao especifica e move os demais
 * elementos para o fim da 
 * @param x int elemento a ser inserido.
 * @param pos Posicao de insercao.
 */
void inserir(int x, int pos) {
   int i;

   //validar insercao
   if(n >= MAXTAM || pos < 0 || pos > n){
      printf("Erro ao inserir!");
      exit(1);
   }

   //levar elementos para o fim do array
   for(i = n; i > pos; i--){
      array[i] = array[i-1];
   }

   array[pos] = x;
   n++;
}


/**
 * Remove um elemento da primeira posicao da lista e movimenta 
 * os demais elementos para o inicio da mesma.
 * @return resp int elemento a ser removido.
 */
int removerInicio() {
   int i, resp;

   //validar remocao
   if (n == 0) {
      printf("Erro ao remover!");
      exit(1);
   }

   resp = array[0];
   n--;

   for(i = 0; i < n; i++){
      array[i] = array[i+1];
   }

   return resp;
}


/**
 * Remove um elemento da ultima posicao da 
 * @return resp int elemento a ser removido.
 */
int removerFim() {

   //validar remocao
   if (n == 0) {
      printf("Erro ao remover!");
      exit(1);
   }

   return array[--n];
}


/**
 * Remove um elemento de uma posicao especifica da lista e 
 * movimenta os demais elementos para o inicio da mesma.
 * @param pos Posicao de remocao.
 * @return resp int elemento a ser removido.
 */
int remover(int pos) {
   int i, resp;

   //validar remocao
   if (n == 0 || pos < 0 || pos >= n) {
      printf("Erro ao remover!");
      exit(1);
   }

   resp = array[pos];
   n--;

   for(i = pos; i < n; i++){
      array[i] = array[i+1];
   }

   return resp;
}


/**
 * Mostra os array separados por espacos.
 */
void mostrar (){
   int i;

   printf("[ ");

   for(i = 0; i < n; i++){
      printf("%d ", array[i]);
   }

   printf("]\n");
}


/**
 * Procura um array e retorna se ele existe.
 * @param x int elemento a ser pesquisado.
 * @return <code>true</code> se o array existir,
 * <code>false</code> em caso contrario.
 */
bool pesquisar(int x) {
   bool retorno = false;
   int i;

   for (i = 0; i < n && retorno == false; i++) {
      retorno = (array[i] == x);
   }
   return retorno;
}


int main(int argc, char** argv){
   int x1, x2, x3;

   printf("==== LISTA ESTATICA ====\n");

   start();

   inserirInicio(1);
   inserirInicio(0);
   inserirFim(2);
   inserirFim(3);
   inserir(4, 3);
   inserir(5, 2);

   printf("Apos insercoes: ");
   mostrar();

   x1 = removerInicio();
   x2 = removerFim();
   x3 = remover(2);

   printf("Apos remocoes (%d, %d, %d): ", x1, x2, x3);
   mostrar();
}

// Fim do arquivo: lista.c

--------------------------------------------------------------------------------

// Início do arquivo: fila.c
/**
 * Lista estatica
 * @author Max do Val Machado
 * @version 2 01/2015
 */
#include <stdio.h>
#include <stdlib.h>

#define MAXTAM    6
#define bool      short
#define true      1
#define false     0

int array[MAXTAM+1];   // Elementos da pilha 
int primeiro;          // Remove do indice "primeiro".
int ultimo;             // Insere no indice "ultimo".


/**
 * Inicializacoes
 */
void start(){
   primeiro = ultimo = 0;
}


/**
 * Insere um elemento na ultima posicao da 
 * @param x int elemento a ser inserido.
 * @Se a fila estiver cheia.
 */
void inserir(int x) {

   //validar insercao
   if (((ultimo + 1) % MAXTAM) == primeiro) {
      printf("Erro ao inserir!");
      exit(1);
   }

   array[ultimo] = x;
   ultimo = (ultimo + 1) % MAXTAM;
}


/**
 * Remove um elemento da primeira posicao da fila e movimenta 
 * os demais elementos para o primeiro da mesma.
 * @return resp int elemento a ser removido.
 * @Se a fila estiver vazia.
 */
int remover() {

   //validar remocao
   if (primeiro == ultimo) {
      printf("Erro ao remover!");
      exit(1);
   }

   int resp = array[primeiro];
   primeiro = (primeiro + 1) % MAXTAM;
   return resp;
}


/**
 * Mostra os array separados por espacos.
 */
void mostrar (){
   int i;
   printf("\n[");

   for(i = primeiro; i != ultimo; i = ((i + 1) % MAXTAM)) {
      printf(" %d", array[i]);
   }

   printf(" ]");
}


/**
 * Retorna um bool indicando se a fila esta vazia
 * @return bool indicando se a fila esta vazia
 */
bool isVazia() {
   return (primeiro == ultimo); 
}


int main(int argc, char** argv){
   int x1, x2, x3;
   printf("\n==== FILA ESTATICA ====");
   start();

   inserir(5);
   inserir(7);
   inserir(8);
   inserir(9);

   printf("\nApos insercoes(5, 7, 8, 9): ");
   mostrar();

   x1 = remover();
   x2 = remover();

   printf("\nApos remocoes (%d, %d):", x1, x2);
   mostrar();

   inserir(3);
   inserir(4);


   printf("\nApos insercoes(3, 4): ");
   mostrar();

   x1 = remover();
   x2 = remover();
   x3 = remover();

   printf("\nApos remocoes (%d, %d, %d):", x1, x2, x3);
   mostrar();

   inserir(4);
   inserir(5);

   printf("\nApos insercoes(4, 5): ");
   mostrar();

   x1 = remover();
   x2 = remover();

   printf("\nApos remocoes (%d, %d):", x1, x2);
   mostrar();

   inserir(6);
   inserir(7);

   printf("\nApos insercoes(6, 7): ");
   mostrar();

   x1 = remover();

   printf("\nApos remocao (%d):", x1);
   mostrar();
}

// Fim do arquivo: fila.c

--------------------------------------------------------------------------------

// Início do arquivo: ArgumentoMain.java
class ArgumentoMain {
   public static void main (String[] args){
      System.out.println("Primeiro parametro: " + args[0]);
      System.out.println("Numero de parametros: " + args.length);
   }
}

// Fim do arquivo: ArgumentoMain.java

--------------------------------------------------------------------------------

// Início do arquivo: TratamentoExcecao03.java
/**
 * Tratamento de excecao
 * @author Max do Val Machado
 * @version 2 01/2015
 */
public class TratamentoExcecao03 {
   public static void main(String[] args) {
      try {
         Integer i = new Integer(args[0]);
         MyIO.println("A variavel i vale " + i);

      } catch (NumberFormatException e) {
         MyIO.println("Erro de formatacao!!!");

      } catch (ArrayIndexOutOfBoundsException e){
         MyIO.println("Erro na passagem de parametros!!!");

      } finally {
         MyIO.println("FIM DE PROGRAMA!!!");
      }
   }
}

// Fim do arquivo: TratamentoExcecao03.java

--------------------------------------------------------------------------------

// Início do arquivo: TratamentoExcecao04.java
/**
 * Tratamento de excecao
 * @author Max do Val Machado
 * @version 2 01/2015
 */
public class TratamentoExcecao04 {
   public static void metodo1(String s) throws NumberFormatException, ArrayIndexOutOfBoundsException {
      Integer i = new Integer(s);
      MyIO.println("A variavel i vale " + i);
   }

   public static void metodo2(String s) throws NumberFormatException {
      Integer i = new Integer(s);
      MyIO.println("A variavel i vale " + i);
   }

   public static void main(String[] args) {
      try {
         metodo1(args[0]);
      } catch (NumberFormatException e) {
         MyIO.println("Erro!!!");

      } catch (ArrayIndexOutOfBoundsException e){
         MyIO.println("Erro!!!");
      }

      MyIO.println("-------------->>>>>>>>    <<<<<<<<--------------");

      try {
         metodo2(args[0]);
      } catch (NumberFormatException e) {
         MyIO.println("Erro!!!");
      }

      MyIO.println("-------------->>>>>>>>    <<<<<<<<--------------");
   }
}

// Fim do arquivo: TratamentoExcecao04.java

--------------------------------------------------------------------------------

// Início do arquivo: TratamentoExcecao05.java
/**
 * Tratamento de excecao
 * @author Max do Val Machado
 * @version 2 01/2015
 */
public class TratamentoExcecao05 {
   public static void metodo(int i) throws Exception {
      if(i % 2 == 1){
         throw new Exception ("Valor impar");
      }
   }

   public static void main(String[] args) throws Exception {

      int i = 2;
      MyIO.println("-------------->>>>>>>>    <<<<<<<<--------------");
      metodo(i);
      MyIO.println("-------------->>>>>>>>    <<<<<<<<--------------");
      metodo(++i);
      MyIO.println("-------------->>>>>>>>    <<<<<<<<--------------");
   }
}

// Fim do arquivo: TratamentoExcecao05.java

--------------------------------------------------------------------------------

// Início do arquivo: TratamentoExcecao01.java
/**
 * Tratamento de excecao
 * @author Max do Val Machado
 * @version 2 01/2015
 */
public class TratamentoExcecao01 {
   public static void main(String[] args) {
      Integer i = new Integer(args[0]);
      MyIO.println("A variavel i vale " + i);
      MyIO.println("FIM DE PROGRAMA!!!");
   }
}

// Fim do arquivo: TratamentoExcecao01.java

--------------------------------------------------------------------------------

// Início do arquivo: TratamentoExcecao02.java
/**
 * Tratamento de excecao
 * @author Max do Val Machado
 * @version 2 01/2015
 */
public class TratamentoExcecao02 {
   public static void main(String[] args) {
      try {
         Integer i = new Integer(args[0]);
         MyIO.println("A variavel i vale " + i);

      } catch (ArrayIndexOutOfBoundsException e){
         MyIO.println("Erro na passagem de parametros!!!");

      } finally {
         MyIO.println("FIM DE PROGRAMA!!!");
      }
   }
}

// Fim do arquivo: TratamentoExcecao02.java

--------------------------------------------------------------------------------

// Início do arquivo: Ponteiro08Objeto.java
class Ponteiro08Objeto {
   public static void main(String args[]){
      Cliente c1 = new Cliente(1, "aa");
      Cliente vet[] = new Cliente [5];

      System.out.println("c1 -->> [" + c1 + "] -- [" + c1.getCodigo() + "/" + c1.getNome() + "]");

      for(int i = 0; i < vet.length; i++){
         vet[i] = c1.clone();
         System.out.println("vet["+ i +"] -->> [" + vet[i] + "] -- [" + vet[i].getCodigo() + "/" + vet[i].getNome() + "]");
      }
   }
}


// Fim do arquivo: Ponteiro08Objeto.java

--------------------------------------------------------------------------------

// Início do arquivo: Ponteiro02PassagemTipoPrimitivo.java
/**
 * Ponteiro
 * @author Max do Val Machado
 * @version 2 01/2015
 */
class Ponteiro02PassagemTipoPrimitivo {
   public static void passagemDeTipoPrimitivo(int a){
      System.out.println("a: " + a);
      a = 10;
      System.out.println("a: " + a);
   }
   public static void main(String[] args) {
      int x = 5;
      System.out.println("x: " + x);
      passagemDeTipoPrimitivo(x);
      System.out.println("x: " + x);
   }
}


// Fim do arquivo: Ponteiro02PassagemTipoPrimitivo.java

--------------------------------------------------------------------------------

// Início do arquivo: Ponteiro05PassagemObjeto.java
/**
 * Ponteiro
 * @author Max do Val Machado
 * @version 3 01/2016
 */
class Cliente{
   private int codigo;
   private String nome;
   public Cliente(){
      this(0, "");
   }
   public Cliente(int codigo){
      this(codigo, "");
   }
   public Cliente(int codigo, String nome){
      this.codigo = codigo;
      this.nome = nome;
   }
   public int getCodigo(){
      return codigo;
   }
   public void setCodigo(int codigo){
      this.codigo = codigo;
   }
   public String getNome(){
      return nome;
   }
   public void setNome(String nome){
      this.nome = nome;
   }
}

class Ponteiro05PassagemObjeto { 

   /**
    * Metodo que recebe um ponteiro contendo o endereco de um objeto. Em seguida, o metodo altera o 
    * conteudo do objeto apontado pelo ponteiro (o mesmo objeto apontado por c1 no metodo principal). 
    * Depois, o metodo retorna o conteudo do nosso ponteiro (endereco recebido como parametro).
    */
   public static Cliente setar2(Cliente y){
      y.setCodigo(6);
      y.setNome("ff");
      System.out.println("ADDRs: y(" + y + ")");
      System.out.println("ATRIBUTOs: y(" + y.getCodigo() + " / " + y.getNome()+")");

      return y;
   }

   /**
    * Metodo que recebe um ponteiro contendo o endereco de um objeto. Em seguida, o metodo altera o 
    * conteudo do objeto apontado pelo ponteiro (o mesmo objeto apontado por c1 no metodo principal). 
    * Depois, o metodo faz com que o ponteiro corrente aponte para outro objeto (veja que c1 do metodo 
    * princial continua apontando para o primeiro objeto). No final, a coleta de lixo do java libera a 
    * area de memoria que continha o ponteiro e o objeto criados neste metodo.
    */
   public static void setar1(Cliente x){
      x.setCodigo(4);
      x.setNome("dd");
      System.out.println("ADDRs: x(" + x + ")");
      System.out.println("ATRIBUTOs: x(" + x.getCodigo() + " / " + x.getNome()+")");

      x = new Cliente (5, "ee");
      System.out.println("ADDRs: x(" + x + ")");
      System.out.println("ATRIBUTOs: x(" + x.getCodigo() + " / " + x.getNome()+")");
   }


   public static void main (String[] args){

      //Declarando tres ponteiros 
      Cliente c1 = new Cliente(1, "aa");
      Cliente c2 = c1;
      Cliente c3 = new Cliente(2, "bb");
      System.out.println("ADDRs: c1(" + c1 + ")\tc2(" + c2 + ")\tc3(" + c3 + ")");
      System.out.println("ATRIBUTOs:");
      System.out.println("c1(" + c1.getCodigo() + " / " + c1.getNome()+")");
      System.out.println("c2(" + c2.getCodigo() + " / " + c2.getNome()+")");
      System.out.println("c3(" + c3.getCodigo() + " / " + c3.getNome()+")");

      //Chamando o metodo setar1 e passando POR VALOR O ADDR de c1
      setar1(c1);
      System.out.println("ADDRs: c1(" + c1 + ")\tc2(" + c2 + ")\tc3(" + c3 + ")");
      System.out.println("ATRIBUTOs:");
      System.out.println("c1(" + c1.getCodigo() + " / " + c1.getNome()+")");
      System.out.println("c2(" + c2.getCodigo() + " / " + c2.getNome()+")");
      System.out.println("c3(" + c3.getCodigo() + " / " + c3.getNome()+")");

      //Chamando o metodo setar2, passando POR VALOR O ADDR DE c2 e retornando um novo endereco para C3
      c3 = setar2(c2);
      System.out.println("ADDRs: c1(" + c1 + ")\tc2(" + c2 + ")\tc3(" + c3 + ")");
      System.out.println("ATRIBUTOs:");
      System.out.println("c1(" + c1.getCodigo() + " / " + c1.getNome()+")");
      System.out.println("c2(" + c2.getCodigo() + " / " + c2.getNome()+")");
      System.out.println("c3(" + c3.getCodigo() + " / " + c3.getNome()+")");
   }
}

// Fim do arquivo: Ponteiro05PassagemObjeto.java

--------------------------------------------------------------------------------

// Início do arquivo: Cliente.java
class Cliente {
	private int codigo;
	private String nome;
	public Cliente (){
		this.codigo = 0;			this.nome = "";
	}
	public Cliente (int codigo, String nome){
		this.codigo = codigo;	this.nome = nome;
	}
	public int getCodigo(){				    	return codigo;			}
	public void setCodigo(int codigo){	this.codigo = codigo;	}
	public String getNome(){			     	return nome;				}
	public void setNome(String nome){  	this.nome = nome;		}

   public Cliente clone (){
		Cliente resp = new Cliente();
		resp.codigo = this.codigo;
		resp.nome = this.nome;
		return resp;
	}

}


// Fim do arquivo: Cliente.java

--------------------------------------------------------------------------------

// Início do arquivo: Ponteiro07ObjetoClone.java
/**
 * Ponteiro
 * @author Max do Val Machado
 * @version 3 01/2016
 */
class Cliente{
   private int codigo;
   private String nome;
   public Cliente(){
      this(0, "");
   }
   public Cliente(int codigo){
      this(codigo, "");
   }
   public Cliente(int codigo, String nome){
      this.codigo = codigo;
      this.nome = nome;
   }
   public int getCodigo(){
      return codigo;
   }
   public void setCodigo(int codigo){
      this.codigo = codigo;
   }
   public String getNome(){
      return nome;
   }
   public void setNome(String nome){
      this.nome = nome;
   }
   public Cliente clone(){
      return new Cliente(this.codigo, this.nome);
   }
}

class Ponteiro07ObjetoClone {

   public static void main (String[] args){

      //Declarando tres ponteiros 
      Cliente c1 = null, c2 = null, c3 = null;
      System.out.println("ADDRs: c1(" + c1 + ")\tc2(" + c2 + ")\tc3(" + c3 + ")");

      //Alocando areas de memoria (ou inicializando objetos) e apontando os ponteiros para tais areas
      c1 = new Cliente(1, "aa");
      c2 = c1;
      c3 = new Cliente(2, "bb");
      System.out.println("ADDRs: c1(" + c1 + ")\tc2(" + c2 + ")\tc3(" + c3 + ")");

      //Setando o codigo apontado por c1 e c2
      c2.setCodigo(3);
      System.out.println("ATRIBUTOs:");
      System.out.println("c1(" + c1.getCodigo() + " / " + c1.getNome()+")");
      System.out.println("c2(" + c2.getCodigo() + " / " + c2.getNome()+")");
      System.out.println("c3(" + c3.getCodigo() + " / " + c3.getNome()+")");

   }
}

// Fim do arquivo: Ponteiro07ObjetoClone.java

--------------------------------------------------------------------------------

// Início do arquivo: Ponteiro04Objeto.java
/**
 * Ponteiro
 * @author Max do Val Machado
 * @version 3 01/2016
 */
class Cliente{
   private int codigo;
   private String nome;
   public Cliente(){
      this(0, "");
   }
   public Cliente(int codigo){
      this(codigo, "");
   }
   public Cliente(int codigo, String nome){
      this.codigo = codigo;
      this.nome = nome;
   }
   public int getCodigo(){
      return codigo;
   }
   public void setCodigo(int codigo){
      this.codigo = codigo;
   }
   public String getNome(){
      return nome;
   }
   public void setNome(String nome){
      this.nome = nome;
   }
}

class Ponteiro04Objeto {

   public static void main (String[] args){

      //Declarando tres ponteiros 
      Cliente c1 = null, c2 = null, c3 = null;
      System.out.println("ADDRs: c1(" + c1 + ")\tc2(" + c2 + ")\tc3(" + c3 + ")");

      //Alocando areas de memoria (ou inicializando objetos) e apontando os ponteiros para tais areas
      c1 = new Cliente(1, "aa");
      c2 = c1;
      c3 = new Cliente(2, "bb");
      System.out.println("ADDRs: c1(" + c1 + ")\tc2(" + c2 + ")\tc3(" + c3 + ")");

      //Setando o codigo apontado por c1 e c2
      c2.setCodigo(3);
      System.out.println("ATRIBUTOs:");
      System.out.println("c1(" + c1.getCodigo() + " / " + c1.getNome()+")");
      System.out.println("c2(" + c2.getCodigo() + " / " + c2.getNome()+")");
      System.out.println("c3(" + c3.getCodigo() + " / " + c3.getNome()+")");

   }
}

// Fim do arquivo: Ponteiro04Objeto.java

--------------------------------------------------------------------------------

// Início do arquivo: Ponteiro06PassagemObjetoClone.java
/**
 * Ponteiro
 * @author Max do Val Machado
 * @version 3 01/2016
 */
class Cliente{
   private int codigo;
   private String nome;
   public Cliente(){
      this(0, "");
   }
   public Cliente(int codigo){
      this(codigo, "");
   }
   public Cliente(int codigo, String nome){
      this.codigo = codigo;
      this.nome = nome;
   }
   public int getCodigo(){
      return codigo;
   }
   public void setCodigo(int codigo){
      this.codigo = codigo;
   }
   public String getNome(){
      return nome;
   }
   public void setNome(String nome){
      this.nome = nome;
   }
   public Cliente clone(){
      return new Cliente(this.codigo, this.nome);
   }
}

class Ponteiro06PassagemObjetoClone {

   /**
    * Metodo que recebe um ponteiro contendo o endereco de um objeto. Em seguida, o metodo altera o 
    * conteudo do objeto apontado pelo ponteiro (o mesmo objeto apontado por c1 no metodo principal). 
    * Depois, o metodo retorna o conteudo do nosso ponteiro (endereco recebido como parametro).
    */
   public static Cliente setar2(Cliente y){
      y.setCodigo(6);
      y.setNome("ff");
      System.out.println("ADDRs: y(" + y + ")");
      System.out.println("ATRIBUTOs: y(" + y.getCodigo() + " / " + y.getNome()+")");

      return y;
   }

   /**
    * Metodo que recebe um ponteiro contendo o endereco de um objeto. Em seguida, o metodo altera o 
    * conteudo do objeto apontado pelo ponteiro (o mesmo objeto apontado por c1 no metodo principal). 
    * Depois, o metodo faz com que o ponteiro corrente aponte para outro objeto (veja que c1 do metodo 
    * princial continua apontando para o primeiro objeto). No final, a coleta de lixo do java libera a 
    * area de memoria que continha o ponteiro e o objeto criados neste metodo.
    */
   public static void setar1(Cliente x){
      x.setCodigo(4);
      x.setNome("dd");
      System.out.println("ADDRs: x(" + x + ")");
      System.out.println("ATRIBUTOs: x(" + x.getCodigo() + " / " + x.getNome()+")");

      x = new Cliente (5, "ee");
      System.out.println("ADDRs: x(" + x + ")");
      System.out.println("ATRIBUTOs: x(" + x.getCodigo() + " / " + x.getNome()+")");
   }


   public static void main (String[] args){

      //Declarando tres ponteiros 
      Cliente c1 = new Cliente(1, "aa");
      Cliente c2 = c1.clone();
      Cliente c3 = new Cliente(2, "bb");
      System.out.println("ADDRs: c1(" + c1 + ")\tc2(" + c2 + ")\tc3(" + c3 + ")");
      System.out.println("ATRIBUTOs:");
      System.out.println("c1(" + c1.getCodigo() + " / " + c1.getNome()+")");
      System.out.println("c2(" + c2.getCodigo() + " / " + c2.getNome()+")");
      System.out.println("c3(" + c3.getCodigo() + " / " + c3.getNome()+")");

      //Chamando o metodo setar1 e passando POR VALOR O ADDR de c1
      setar1(c1);
      System.out.println("ADDRs: c1(" + c1 + ")\tc2(" + c2 + ")\tc3(" + c3 + ")");
      System.out.println("ATRIBUTOs:");
      System.out.println("c1(" + c1.getCodigo() + " / " + c1.getNome()+")");
      System.out.println("c2(" + c2.getCodigo() + " / " + c2.getNome()+")");
      System.out.println("c3(" + c3.getCodigo() + " / " + c3.getNome()+")");

      //Chamando o metodo setar2, passando POR VALOR O ADDR DE c2 e retornando um novo endereco para C3
      c3 = setar2(c2);
      System.out.println("ADDRs: c1(" + c1 + ")\tc2(" + c2 + ")\tc3(" + c3 + ")");
      System.out.println("ATRIBUTOs:");
      System.out.println("c1(" + c1.getCodigo() + " / " + c1.getNome()+")");
      System.out.println("c2(" + c2.getCodigo() + " / " + c2.getNome()+")");
      System.out.println("c3(" + c3.getCodigo() + " / " + c3.getNome()+")");
   }
}

// Fim do arquivo: Ponteiro06PassagemObjetoClone.java

--------------------------------------------------------------------------------

// Início do arquivo: Ponteiro01Array.java
/**
 * Ponteiro
 * @author Max do Val Machado
 * @version 2 01/2015
 */
class Ponteiro01Array {
   public static void main (String[] args) {
      int[] vet = new int [5];
      System.out.println(vet);

      vet = new int [5];
      System.out.println(vet);
   }
}

// Fim do arquivo: Ponteiro01Array.java

--------------------------------------------------------------------------------

// Início do arquivo: Ponteiro03PassagemArray.java
/**
 * Ponteiro
 * @author Max do Val Machado
 * @version 2 01/2015
 */
class Ponteiro03PassagemArray { 
   public static void passangemDeArray(int[] b){
      for(int i = 0; i < 5; i++){
         b[i] *= 5;
         System.out.println("b[" + i + "]: " + b[i]);
      }
      b = new int[5];
      for(int i = 0; i < 5; i++){
         b[i] = i;
         System.out.println("b[" + i + "]: " + b[i]);
      }
   }
   public static void main(String[] args) {
      int[] y = new int [5];

      for(int i = 0; i < 5; i++){
         y[i] = i;
         System.out.println("y[" + i + "]: " + y[i]);
      }
      passangemDeArray(y);
      for(int i = 0; i < 5; i++){
         System.out.println("y[" + i + "]: " + y[i]);
      }
   }
}


// Fim do arquivo: Ponteiro03PassagemArray.java

--------------------------------------------------------------------------------

// Início do arquivo: ExemploArq02Leitura.java
class ExemploArq02Leitura
{
  public static void main(String[] args)
  {
     //Abrir o arquivo texto
     Arq.openRead("exemplo.txt");


     //Ler o arquivo texto
     int inteiro = Arq.readInt();
     double real = Arq.readDouble();
     char caractere = Arq.readChar();
     boolean boleano = Arq.readBoolean();
     String str = Arq.readString();


     //Fechar o arquivo texto
     Arq.close();

     //Mostrar os valores lidos na tela
     MyIO.println("inteiro: " + inteiro);
     MyIO.println("real: " + real);
     MyIO.println("caractere: " + caractere);
     MyIO.println("boleano: " + boleano);
     MyIO.println("str: " + str);

  } // Fim main()
} // Fim class

// Fim do arquivo: ExemploArq02Leitura.java

--------------------------------------------------------------------------------

// Início do arquivo: ExemploRAF03Cabecote.java
import java.io.*;  

public class ExemploRAF03Cabecote {  
   public static void main(String args[]) throws Exception {

      RandomAccessFile raf = new RandomAccessFile("exemplo.txt","rw");  

      raf.writeInt(1);  
      raf.writeDouble(5.3);  
      raf.writeChar('X');  
      raf.writeBoolean(true);  
      raf.writeBytes("Algoritmos");

      raf.seek(0); //Retornando o cabecote para a posicao 0
      System.out.println(raf.readInt()); //imprimindo o inteiro

      raf.seek(12); //Setando o cabecote na posicao 12 (do caractere,
                    //12 = 4 do int + 8 do double)
      System.out.println(raf.readChar());

      raf.seek(12); //Setando o cabecote novamente na posicao 12
      raf.writeChar('@'); //Substituindo o caractere

      raf.seek(12);
      System.out.println(raf.readChar());

      raf.close();
   }  
}  

// Fim do arquivo: ExemploRAF03Cabecote.java

--------------------------------------------------------------------------------

// Início do arquivo: ExemploRAF02Leitura.java
import java.io.*;

class ExemploRAF02Leitura {
   public static void main (String[] args) throws Exception{
      RandomAccessFile raf = new RandomAccessFile("exemplo.txt", "rw");

      int inteiro  = raf.readInt();
      double real = raf.readDouble();
      char caractere  = raf.readChar();
      boolean boleano  = raf.readBoolean();
      String str  = raf.readLine();

      raf.close();

      System.out.println("inteiro: " + inteiro);
      System.out.println("real: " + real);
      System.out.println("caractere: " + caractere);
      System.out.println("boleano: " + boleano);
      System.out.println("str: " + str);
   }
}


// Fim do arquivo: ExemploRAF02Leitura.java

--------------------------------------------------------------------------------

// Início do arquivo: ExemploArq01Escrita.java
class ExemploArq01Escrita
{
  public static void main(String[] args)
  {
     //Abrir o arquivo texto
     Arq.openWrite("exemplo.txt");


     //Escrever no arquivo texto
     Arq.println(1);
     Arq.println(5.3);
     Arq.println('X');
     Arq.println(true);
     Arq.println("Algoritmos");


     //Fechar o arquivo texto
     Arq.close();

  } // Fim main()
} // Fim class

// Fim do arquivo: ExemploArq01Escrita.java

--------------------------------------------------------------------------------

// Início do arquivo: ExemploArq03Exercicio.java
class ExemploArq03Exercicio {
   public static void main (String[] args){
      Arq.openRead("exemplo.txt");

      String str  = "";
      while (Arq.hasNext() == true){
         str += Arq.readChar();
      }

      Arq.close();

      Arq.openWrite("copia.txt");
      Arq.print(str);
      Arq.close();
   }
}

// Fim do arquivo: ExemploArq03Exercicio.java

--------------------------------------------------------------------------------

// Início do arquivo: ExemploArq02bLeitura.java
class ExemploArq02bLeitura
{
  public static void main(String[] args)
  {
     //Abrir o arquivo texto
     Arq.openRead("exemplo.txt");


     //Ler o arquivo texto
     int inteiro = Integer.parseInt(Arq.readLine());
     double real = Double.parseDouble(Arq.readLine().replace(",","."));
     char caractere = Arq.readLine().charAt(0);
     boolean boleano = Boolean.parseBoolean(Arq.readLine());
     String str = Arq.readLine();


     //Fechar o arquivo texto
     Arq.close();

     //Mostrar os valores lidos na tela
     MyIO.println("inteiro: " + inteiro);
     MyIO.println("real: " + real);
     MyIO.println("caractere: " + caractere);
     MyIO.println("boleano: " + boleano);
     MyIO.println("str: " + str);

  } // Fim main()
} // Fim class

// Fim do arquivo: ExemploArq02bLeitura.java

--------------------------------------------------------------------------------

// Início do arquivo: ExemploRAF01Escrita.java
import java.io.*;  

public class ExemploRAF01Escrita {  
   public static void main(String args[]) throws Exception {

      RandomAccessFile raf = new RandomAccessFile("exemplo.txt","rw");  

      raf.writeInt(1);  
      raf.writeDouble(5.3);  
      raf.writeChar('X');  
      raf.writeBoolean(true);  
      raf.writeBytes("Algoritmos");          

      raf.close();
   }  
}  

// Fim do arquivo: ExemploRAF01Escrita.java

--------------------------------------------------------------------------------

// Início do arquivo: PrintRecursivo.java
/**
 * Recursividade
 * @author Max do Val Machado
 * @version 2 01/2015
 */
class PrintRecursivo{ 
   public static void printRecursivo(int i){
      System.out.println("valor de i: " + i);
      if(i > 0){
         printRecursivo(i-1);
      }
      System.out.println("valor de i: " + i);
   }
   public static void main(String[] args){
      int n = Integer.parseInt(args[0]);
      printRecursivo(n);
   }
}

// Fim do arquivo: PrintRecursivo.java

--------------------------------------------------------------------------------

// Início do arquivo: Multiplicacao.java
class Multiplicacao {
   public static int multiplicacao(int a, int b){
      return multiplicacao(a, b, 0);
   }

   public static int multiplicacao(int a, int b, int i){
      int resp = 0;

      if(i < b){
         resp = a + multiplicacao(a, b, i+1);
      }

      return resp;
   }

   public static int multiplicacaoInt(int a, int b){
      int resp = 0;
      for(int i = 0; i < b; i++){
         resp = a + resp;
      }
      return resp;
   }

   public static void main (String[] args){
      int mult = multiplicacaoInt(4, 3);
      System.out.println("RESPOSTA INT: " + mult);

      mult = multiplicacao(4, 3);
      System.out.println("RESPOSTA REC: " + mult);
   }
}

// Fim do arquivo: Multiplicacao.java

--------------------------------------------------------------------------------

// Início do arquivo: ContarMaiuscula.java
/**
 * Recursividade
 * @author Max do Val Machado
 * @version 2 01/2015
 */
class ContarMaiuscula {
   public static boolean isUpper(char x){
      return (x >= 'A' && x <= 'Z');
   }

   public static int contMaiusculo(String s){
      int cont = 0;

      for(int i = 0; i < s.length(); i++){
         if(isUpper(s.charAt(i)) == true){
            cont++;
         }
      }
      return cont;
   }
   public static int contMaiusculo2(String s){
      return contMaiusculo2(s, 0);
   }
   public static int contMaiusculo2(String s, int i){
      int cont = 0;

      if(i < s.length()){
         if(isUpper(s.charAt(i)) == true){
            cont++;
         }
         cont += contMaiusculo2(s, i + 1);
      }
      return cont;
   }

   public static void main (String[] args){
      System.out.println("AlGoritmos e Estruturas de Dados: " + contMaiusculo("AlGoritmos e Estruturas de Dados"));
      System.out.println("AlGoritmos e Estruturas de Dados: " + contMaiusculo2("AlGoritmos e Estruturas de Dados"));
   }
}

// Fim do arquivo: ContarMaiuscula.java

--------------------------------------------------------------------------------

// Início do arquivo: FatorialRecursivo.java
/**
 * Recursividade
 * @author Max do Val Machado
 * @version 2 01/2015
 */
class FatorialRecursivo{
   public static int fatorial(int n){
      int resp;
      System.out.println("fat (" + n + ")");
      resp = (n == 1) ? 1 : n * fatorial(n-1);
      System.out.println("fat n(" + n + "): " + resp);
      return resp;
   }

   public static void main(String[] args){
      int n = Integer.parseInt(args[0]);
      System.out.println("FATORIAL RECURSIVO(" + n + "): " + fatorial(n));
   }
}


// Fim do arquivo: FatorialRecursivo.java

--------------------------------------------------------------------------------

// Início do arquivo: FibonacciRecursivo.java
/**
 * Recursividade
 * @author Max do Val Machado
 * @version 2 01/2015
 */
class FibonacciRecursivo {
   public static int fibRec (int n){
      int resp;
      System.out.println("fib (" + n + ")");
      resp = (n == 0 || n == 1) ? 1 : fibRec(n-1) + fibRec(n-2);
      System.out.println("fib (" + n + "): " + resp);
      return resp;
   }
   public static void main (String[] args){
      int n = Integer.parseInt(args[0]);
      System.out.println("FIBONACCI RECURSIVO(" + n + "): " + fibRec(n));
   }
}

// Fim do arquivo: FibonacciRecursivo.java

--------------------------------------------------------------------------------

// Início do arquivo: ChamandoMetodo.java
class ChamandoMetodo {
   public static void primeiro(){
      System.out.println("1o - inicio");
      segundo();
      System.out.println("1o - fim");
   }
   public static void segundo(){
      System.out.println("2o - inicio");
      terceiro();
      System.out.println("2o - fim");
   }
   public static void terceiro(){
      System.out.println("3o - inicio e fim");
   }
   public static void main (String[] args){
      System.out.println("main - inicio");
      primeiro();
      System.out.println("main - fim");
   }
}

// Fim do arquivo: ChamandoMetodo.java

--------------------------------------------------------------------------------

// Início do arquivo: ExemploMyIO.java
class ExemploMyIO {
   public static void main (String[] args){
      String str = MyIO.readString("Entre com uma palavra: ");
      int inteiro = MyIO.readInt("Entre com um inteiro: ");
      double real = MyIO.readDouble("Entre com um real: ");
      char caractere = MyIO.readChar("Entre com um caractere: ");

      MyIO.println("Sua string: " + str);
      MyIO.println("Seu inteiro: " + inteiro);
      MyIO.println("Seu real: " + real);
      MyIO.println("Seu caractere: " + caractere);
   }
}

// Fim do arquivo: ExemploMyIO.java

--------------------------------------------------------------------------------

// Início do arquivo: entrada.txt
hoje
3000000
12.3
a


// Fim do arquivo: entrada.txt

--------------------------------------------------------------------------------

// Início do arquivo: ExemploScanner.java
import java.util.*;

class ExemploScanner {
   public static void main(String [] args){

      //Declaracao da classe scanner
      Scanner scanner = new Scanner (System.in);

      System.out.printf("Entre com uma palavra: ");
      String str = scanner.nextLine();

      System.out.printf("Entre com um caractere: ");
      char caractere = scanner.nextLine().charAt(0);

      System.out.printf("Entre com um numero inteiro: ");
      int inteiro = scanner.nextInt();

      System.out.printf("Entre com um numero real: ");
      double real = scanner.nextDouble();

      System.out.println("Sua str: " + str);
      System.out.println("Seu inteiro: " + inteiro);
      System.out.println("Seu real: " + real);
      System.out.println("Seu caractere: " + caractere);

   } // fim main ()
} // fim class 


// Fim do arquivo: ExemploScanner.java

--------------------------------------------------------------------------------

// Início do arquivo: ExemploBufferedReader.java
import java.io.*;
import java.nio.charset.*;

class ExemploBufferedReader {

   //Declaracao da classe BufferedReader
   private static BufferedReader in = new BufferedReader(new InputStreamReader(System.in, Charset.forName("ISO-8859-1")));

   public static String readString(){
      String s = "";
      char tmp;
      try{
         do{
            tmp = (char)in.read();
            if(tmp != '\n' && tmp != ' ' && tmp != 13){
               s += tmp;
            }
         }while(tmp != '\n' && tmp != ' ');
      }catch(IOException ioe){}
      return s;
   }

   public static void main(String [] args) throws Exception {

      System.out.printf("Entre com uma palavra: ");
      String str = readString();

      System.out.printf("Entre com um numero inteiro: ");
      int inteiro = Integer.parseInt(readString().trim());

      System.out.printf("Entre com um numero real: ");
      double real = Double.parseDouble(readString().trim().replace(",","."));

      System.out.printf("Entre com um caractere: ");
      char caractere = (char)in.read();

      System.out.println("Sua str: " + str);
      System.out.println("Seu inteiro: " + inteiro);
      System.out.println("Seu real: " + real);
      System.out.println("Seu caractere: " + caractere);
    } // fim main ()
} // fim class 


// Fim do arquivo: ExemploBufferedReader.java

--------------------------------------------------------------------------------

// Início do arquivo: ExemploOO.java
import java.util.*;

class Aluno {
   private String nome;
   private double nota;
   private Scanner sc = new Scanner (System.in);

   public Aluno (){
      nome = "";
      nota = 0.0;
   }

   public Aluno(String nome, double nota){
      this.nome = nome;
      this.nota = nota;
   }

   public String getNome(){
      return nome;
   }

   public void setNome(String nome){
      this.nome = nome;
   }

   public double getNota(){
      return nota;
   }

   public void setNota(double nota){
      this.nota = nota;
   }

   public void ler(){
      System.out.println("Entre com o nome do aluno: ");
      nome = sc.nextLine();

      System.out.println("Entre com a nota do aluno: ");
      nota = sc.nextDouble();
   }

   public void imprimir(){
      System.out.println("Aluno: " + nome + " (nota " + nota + ")");
   }

}

class ExemploOO {
   static Scanner sc = new Scanner (System.in);

   public static void main(String [] args){
      double media = 0;
      int numeroAluno = 5;
      Aluno[] aluno = new Aluno[numeroAluno];

      for(int i = 0; i < aluno.length; i++){
         aluno[i] = new Aluno();
      }

      for(int i = 0; i < aluno.length; i++){
         aluno[i].ler();
         media += aluno[i].getNota();
      }

      media /= numeroAluno;
      System.out.println("Média: " + media);
      System.out.println("\n\n=======================");
      System.out.println("\n\n");

      for(int i = 0; i < aluno.length; i++){
         if(aluno[i].getNota() >= media){
            aluno[i].imprimir();
         }
      }
   } // fim main ()
} // fim class 


// Fim do arquivo: ExemploOO.java

--------------------------------------------------------------------------------

// Início do arquivo: Lixao.java




class Lixao{
   public static void main(String[] args){
      Funcionario f1 = new Funcionario();
      Funcionario f2 = new Funcionario(5);
      Funcionario f3 = new Funcionario(10, "Ze");

      System.out.println("(1) ==================================");
      f1.imprimir();     f2.imprimir();    f3.imprimir();

      int i = 0;
      f1.codigo = i; i++;
      f2.codigo = i; i++;
      f3.codigo = i; i++;
    
      f1.nome = "Zaza";  f2.nome = "Zizi";

      System.out.println("(2) ==================================");
      f1.imprimir();     f2.imprimir();    f3.imprimir();
   }    
}






















// Fim do arquivo: Lixao.java

--------------------------------------------------------------------------------

// Início do arquivo: Funcionario.java
class Funcionario{
   public int codigo;
   public String nome;

   public Funcionario(){
      codigo = 0;
      nome = "";
   }

   public Funcionario(int cod){
      codigo = cod;
      nome = "";
   }

   public Funcionario(int cod, String nom){
      codigo = cod;
      nome = nom;
   }

   public void imprimir(){
      System.out.println("Codigo: " + codigo);
      System.out.println("Nome: " + nome);
   }
}


// Fim do arquivo: Funcionario.java

--------------------------------------------------------------------------------

// Início do arquivo: Principal.java
/**
 * Introducao a programacao orientada por objetos
 * @author Max do Val Machado
 * @version 2 01/2015
 */
class Principal
{
   public static void main(String[] args)
   {
      Retangulo r1 = new Retangulo();
      Retangulo r2 = new Retangulo();

      r1.lerTudo();
      r1.escreverTudo();

      r2.lerTudo();
      r2.escreverTudo();

      if (r1.comparar(r2.getB(), r2.getH()) == true){
         System.out.println("Os retangulos " + r1.getNome() + " e " + r2.getNome() + "sao iguais!");
      }else{
         System.out.println("Os retangulos " + r1.getNome() + " e " + r2.getNome() + "sao diferentes!");
      }

      if (r1.comparar(r2) == true){
         System.out.println("Os retangulos " + r1.getNome() + " e " + r2.getNome() + "sao iguais!");
      }else{
         System.out.println("Os retangulos " + r1.getNome() + " e " + r2.getNome() + "sao diferentes!");
      }

      if (r1.comparar(r1) == true){
         System.out.println("Os retangulos " + r1.getNome() + " e " + r1.getNome() + "sao iguais!");
      }else{
         System.out.println("Os retangulos " + r1.getNome() + " e " + r1.getNome() + "sao diferentes!");
      }

      if (r2.comparar(r1) == true){
         System.out.println("Os retangulos " + r2.getNome() + " e " + r1.getNome() + "sao iguais!");
      }else{
         System.out.println("Os retangulos " + r2.getNome() + " e " + r1.getNome() + "sao diferentes!");
      }
   }
}


// Fim do arquivo: Principal.java

--------------------------------------------------------------------------------

// Início do arquivo: Lixao.java
import java.util.*;

class Lixao{
	public static Scanner sc = new Scanner(System.in);
   public static void main(String[] args){
      Retangulo r1 = new Retangulo();
      Retangulo r2 = new Retangulo();

		System.out.println("Entre com a base: ");
      r1.b = sc.nextInt();
      System.out.println("Entre com a altura: ");
      r1.h = sc.nextInt();
      System.out.println("Entre com o nome: ");
      r1.nome = sc.nextLine();

      System.out.println("Area: " + r1.getArea());
      System.out.println("Diagonal: " + r1.getDiagonal());
      System.out.println("Perimetro: " + r1.getPerimetro());


		System.out.println("Entre com a base: ");
      r2.b = sc.nextInt();
      System.out.println("Entre com a altura: ");
      r2.h = sc.nextInt();
      System.out.println("Entre com o nome: ");
      r2.nome = sc.nextLine();

      System.out.println("Area: " + r2.getArea());
      System.out.println("Diagonal: " + r2.getDiagonal());
      System.out.println("Perimetro: " + r2.getPerimetro());
   }
}

// Fim do arquivo: Lixao.java

--------------------------------------------------------------------------------

// Início do arquivo: Retangulo.java
/**
 * Introducao a programacao orientada por objetos
 * @author Max do Val Machado
 * @version 2 01/2015
 */
class Retangulo{
   //Declaracao de variaveis
   private double b, h;
   private String nome;

   //Construtor vazio
   public Retangulo(){
      this.b = this.h = 0;
      this.nome = "";
   }

   //Construtor que recebe parametros
   public Retangulo(double b, double h, String nome){
      this.b = b;
      this.h = h;
      this.nome = nome;
   }

   public double getB(){
      return this.b;
   }

   public void setB(double b){
      this.b = b;
   }

   public double getH(){
      return this.h;
   }

   public void setH(double h){
      this.h = h;
   }

   public String getNome(){
      return this.nome;
   }

   public void setNome(String nome){
      this.nome = nome;
   }

   public void lerTudo(){
      b = MyIO.readDouble("Entre com a base: ");
      h = MyIO.readDouble("Entre com a altura: ");
      nome = MyIO.readString("Entre com o nome: ");
   }

   public void escreverTudo(){
      System.out.println("NOME: " + nome);
      System.out.println("Base: " + b);
      System.out.println("Altura: " + h);
      System.out.println("Area: " + getArea());
      System.out.println("Diagonal: " + getDiagonal());
      System.out.println("Perimetro: " + getPerimetro());
   }


   //Retornar a area
   public double getArea(){
      return (b * h);
   }

   //Retornar o perimetro
   public double getPerimetro(){
      return ((b + h) * 2);
   }

   //Retornar a diagonal
   public double getDiagonal(){
      return Math.sqrt(b * b + h * h);
   }


   //Comparar
   public boolean comparar(double outraB, double outraH){
      boolean resp;

      if (this.b == outraB && this.h == outraH){
         resp = true;
      }else{
         resp = false;
      }

      return resp;
   }

   //Comparar
   //public boolean comparar(double outraB, double outraH){
   //    return (this.b == outraB && this.h == outraH);
   //}

   //Comparar
   public boolean comparar(Retangulo x){
      return (this.b == x.b && this.h == x.h);
   }
}

// Fim do arquivo: Retangulo.java

--------------------------------------------------------------------------------

// Início do arquivo: Lixao.java
import java.util.*;

class Lixao{
	public static Scanner sc = new Scanner(System.in);
   public static void main(String[] args){
      int linha, coluna;
      Matriz m1, m2;

      //Leitura do numero de linhas das matrizes
      System.out.println("Digite o numero de linhas:");
      linha = sc.nextInt();

      //Leitura do numero de coluna das matrizes
      System.out.println("Digite o numero de colunas:");
      coluna = sc.nextInt();

      //Definicao do tamanho das matrizes
      m1 = new Matriz(linha,coluna);
      m2 = new Matriz(linha, coluna);

      //Leitura de cada elemento da matriz 1
      m1.ler();

      //Leitura de cada elemento da matriz 2
      m2.ler();

      //Somar as duas matrizes e salvar o resultado na matriz 3
      Matriz m3 = m1.soma(m2);

      //Imprimir a matriz 1
      m1.imprimir();

      //Imprimir a matriz 2
      m2.imprimir();

      //Imprimir a matriz 3
      m3.imprimir();

      //Imprimir a matriz 1 em formato de grid
      m1.imprimirEmGrid();

      //Imprimir a matriz 2 em formato de grid
      m2.imprimirEmGrid();

      //Imprimir a matriz 3 em formato de grid
      m3.imprimirEmGrid();
   }
}

// Fim do arquivo: Lixao.java

--------------------------------------------------------------------------------

// Início do arquivo: Matriz.java
import java.util.*;

class Matriz{
   private int linha;
   private int coluna;
   private int[][] mat;
   public static Scanner sc = new Scanner(System.in);
   public Matriz(){
      linha = coluna = 10;
      mat = new int[linha][coluna];
   }
   public Matriz(int linha_, int coluna_){
      linha = linha_;
      coluna = coluna_;
      mat = new int[linha][coluna];
   }
   public int getElemento(int i, int j){
      return mat[i][j];
   }
   public void setElemento(int i, int j, int valor){
      mat[i][j] = valor;
   }
   public void ler(){
      for (int i = 0; i < linha; i++){
         for (int j = 0; j < coluna; j++){
         	System.out.println("Digite o elemento [" + i + "," + j + "]: ");
            mat[i][j] = sc.nextInt();
         }     
      }
      System.out.println();
   }

   public Matriz soma(Matriz outra){

      Matriz resp = new Matriz(linha, coluna);

      for (int i = 0; i < linha; i++){
         for (int j = 0; j < coluna; j++){
            resp.mat[i][j] = mat[i][j] + outra.mat[i][j];
         }    
      }

      return resp;

   }

   public void imprimir(){
      for (int i = 0; i < linha; i++){
         for (int j = 0; j < coluna; j++){
            System.out.println("Mat[" + i + "," + j + "]: " + mat[i][j]);
         }     
      }
      System.out.println();
   }
   public void imprimirEmGrid(){
      for (int i = 0; i < linha; i++){
         for (int j = 0; j < coluna; j++){
            System.out.print(" " + mat[i][j]);
         }
         System.out.println();
      }
      System.out.println();
   }
}


// Fim do arquivo: Matriz.java

--------------------------------------------------------------------------------

// Início do arquivo: Visibilidade.java
class Visibilidade {
   public int numeroPublico;
   private int numeroPrivado;

   public Visibilidade(){
      numeroPublico = numeroPrivado = 0;
   }

   public void setNumeroPrivado(int valor){
      numeroPrivado = valor;
   }

   public int getNumeroPrivado(){
      return numeroPrivado;
   }

   public void metodoPublico(){
      System.out.println("Metodo Publico: " + numeroPublico + " / " + numeroPrivado);
   }

   private void metodoPrivado(){
      System.out.println("Metodo Privado: " + numeroPublico + " / " + numeroPrivado);
   }

   public void chamaPrivado(){
      metodoPrivado();
   }
}

// Fim do arquivo: Visibilidade.java

--------------------------------------------------------------------------------

// Início do arquivo: Lixao.java
class Lixao{
    public static void main(String[] args){
        Visibilidade v = new Visibilidade();

        System.out.println("(1) ==================================");

        v.numeroPublico = 1;
        System.out.println(v.numeroPublico);

        //Error	numeroPrivado has private access in Visibilidade
        //v.numeroPrivado = 2;

        //Error	numeroPrivado has private access in Visibilidade
        //System.out.println(v.numeroPrivado);

        v.setNumeroPrivado(3);
        System.out.println(v.getNumeroPrivado());

        System.out.println("(2) ==================================");

        v.metodoPublico();

        //Error	metodoPrivado() has private access in Visibilidade
        //v.metodoPrivado();

        v.chamaPrivado();        
}    }

// Fim do arquivo: Lixao.java

--------------------------------------------------------------------------------

// Início do arquivo: Lixao.java
class Lixao{
   public static void main(String[] args){
      Estatico e1 = new Estatico();
      Estatico e2 = new Estatico();

      System.out.println("(1) ==================================");
      Estatico.numeroEstatico = 1;
      System.out.println(Estatico.numeroEstatico);
      System.out.println(e1.numeroEstatico);
      e1.numeroEstatico = 3;
      System.out.println(e2.numeroEstatico);

      e1.numeroNaoEstatico = 2;
      e2.numeroNaoEstatico = 4;
      System.out.println(e1.numeroNaoEstatico);

      //Error non-static variable numeroNaoEstatico cannot be referenced from a static context
      //Estatico.numeroNaoEstatico = 10;

      System.out.println("(2) ==================================");
      Estatico.metodoEstatico();
      e1.metodoNaoEstatico();
      //Estatico.metodoNaoEstatico();
   }
}


// Fim do arquivo: Lixao.java

--------------------------------------------------------------------------------

// Início do arquivo: Estatico.java
class Estatico {
   public static int numeroEstatico;
   public int numeroNaoEstatico;

   public Estatico(){
       numeroEstatico = 0;
   }

   public static void metodoEstatico(){
       System.out.println("Metodo Estatico: " + numeroEstatico);
   }

   public void metodoNaoEstatico(){
       System.out.println("Metodo Nao Estatico: " + numeroEstatico + " / " + numeroNaoEstatico);
   }
   public void setEstatico(int valor){
       numeroEstatico = valor;
   }
}

// Fim do arquivo: Estatico.java

--------------------------------------------------------------------------------

// Início do arquivo: argumentos_main.c
#include <stdio.h>
#include <stdlib.h>
//=============================================================================
// EXEMPLO DE UTILIZAÇÃO DOS ARGUMENTOS PASSADOS PARA O MAIN
int main(int argc, char *argv[]){
    
    int i;

    for (i = 0; i < argc; i++)
        printf("%d Parametro: %s\n", i, argv[i]);

    return 0;
}
//=============================================================================
// Fim do arquivo: argumentos_main.c

--------------------------------------------------------------------------------

// Início do arquivo: leituraescrita.c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]){
   char c;
   char s[100];
   int i; 
   double d;

   printf("\nEntre com um caractere: ");
   scanf("%c", &c);

   printf("\nEntre com uma palavra: ");
   scanf("%s", s);

   printf("\nEntre com um inteiro e um real: ");
   scanf("%i%lf", &i, &d);

   printf("\ninteiro(%d) real(%f) char(%c) s(%s)", i, d, c, s);  

   return 0;
}

// Fim do arquivo: leituraescrita.c

--------------------------------------------------------------------------------

// Início do arquivo: meuprimeiroprograma.c
#include <stdio.h> 

int main(int argc, char *argv[]) { 
   printf ("Ola pessoal!!!\n\n"); 
   return 0; 
}

// Fim do arquivo: meuprimeiroprograma.c

--------------------------------------------------------------------------------

// Início do arquivo: sizeof.c
#include <stdio.h> 

int main(int argc, char *argv[]) { 
   int a = sizeof(char), 
       b = sizeof(int),
       c = sizeof(double), 
       d = sizeof(float);

   printf ("Tamanho do char: %i\n", a); 
   printf ("Tamanho do int: %i\n", b); 
   printf ("Tamanho do double: %i\n", c); 
   printf ("Tamanho do float: %i\n", d); 
   return 0; 
}

// Fim do arquivo: sizeof.c

--------------------------------------------------------------------------------

// Início do arquivo: string.c
#include <stdio.h>
#include <string.h>

int main(int argc, char *argv[]){
   char s1[80], s2[80]; 

   strcpy(s1, "Algoritmos"); 
   strcpy(s2, " e Estruturas de Dados II"); 

   printf("\nTamanho s1(%i)", (int)strlen(s1)); 
   printf("\nTamanho s2(%i)", (int)strlen(s2)); 

   if(!strcmp(s1, s2))  printf("\nIguais!!!"); 
   else                 printf("\nDiferentes!!!"); 

   strcat(s1, s2);
   printf("\nNova s1 (%s)", s1); 

   strcpy(s2, s1); 
   printf("\nNova s2 (%s)", s2); 

   if(!strcmp(s1, s2))  printf("\nIguais!!!"); 
   else                 printf("\nDiferentes!!!");

   s1[10] = s2[10] = '\0';  s1[11] = 'a';  s2[11] = 'b';
   printf("\nNova s1 (%s)", s1); 
   printf("\nNova s2 (%s)", s2);

   if(!strcmp(s1, s2))  printf("\nIguais!!!"); 
   else                 printf("\nDiferentes!!!");

   return 0; 
}

// Fim do arquivo: string.c

--------------------------------------------------------------------------------

// Início do arquivo: arq08.c
#include <stdio.h> 
#include <stdlib.h> 

int main(int argc, char *argv[]) { 

   FILE *p; 

   double d = 12.23;
   int i = 101;
   long l = 123023L;

   if ((p = fopen("teste.txt", "wb")) == NULL) {
      printf ("arquivo nao pode ser aberto\n");
      exit(1);
   }

   fwrite(&d, sizeof(double), 1, p);
   fwrite(&i, sizeof(int), 1, p);
   fwrite(&l, sizeof(long), 1, p);

   fclose(p);

   return 0; 
}

// Fim do arquivo: arq08.c

--------------------------------------------------------------------------------

// Início do arquivo: arq05.c
#include <stdio.h> 
#include <stdlib.h> 

int main(int argc, char *argv[]) { 

   FILE *p = fopen ("teste.txt", "w"); 
   fputc('M', p);
   fclose(p);

   return 0; 
}


// Fim do arquivo: arq05.c

--------------------------------------------------------------------------------

// Início do arquivo: arquivos.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
//=============================================================================
void gravar_arquivo_texto(){

    // ABRIR O ARQUIVO
    FILE *arq = fopen("arquivo.txt", "w");

    if(arq == NULL){
        printf("Erro ao tentar abrir o arquivo!\n");
        return;
    }

    // ESCREVER NO ARQUIVO
    fprintf(arq, "%s\t", "Algoritmos");
    fprintf(arq, "%d\t", 1);
    fprintf(arq, "%f\t", 5.3);
    fprintf(arq, "%c\t", 'X');
        
    // FECHA O ARQUIVO
    fclose(arq);
}
//=============================================================================
void ler_texto_texto(){

    char texto[12], caracter;
    int inteiro;
    float real;

    // ABRIR O ARQUIVO
    FILE *arq = fopen("arquivo.txt", "r");

    if(arq == NULL){
        printf("Erro ao tentar abrir o arquivo!\n");
        return;
    }

    // LE O ARQUIVO
    fscanf(arq, "%99[^\t]\t", &texto); // LER STRING
    fscanf(arq, "%d\t", &inteiro);
    fscanf(arq, "%f\t", &real);
    fscanf(arq, "%c\t", &caracter);
        
    // FECHA O ARQUIVO
    fclose(arq);  

    printf("texto: %s\n", texto);  
    printf("inteiro: %d\n", inteiro); 
    printf("real: %f\n", real); 
    printf("caracter: %c\n", caracter); 
}
//=============================================================================
void gravar_arquivo_binario(){

    char texto[12] = "Algoritmos", caracter = 'X';
    int inteiro = 1;
    float real = 5.3;

    // ABRIR O ARQUIVO
    FILE *arq = fopen("arquivo.bin", "wb");

    if(arq == NULL){
        printf("Erro ao tentar abrir o arquivo!\n");
        return;
    }

    // ESCREVER NO ARQUIVO
    fwrite(&texto, sizeof(char), 12, arq);
    fwrite(&inteiro, sizeof(int), 1, arq);
    fwrite(&real, sizeof(float), 1, arq);
    fwrite(&caracter,sizeof(char), 1, arq);
        
    // FECHA O ARQUIVO
    fclose(arq);
}
//=============================================================================
void ler_texto_binario(){

    char texto[12], caracter;
    int inteiro;
    float real;

    // ABRIR O ARQUIVO
    FILE *arq = fopen("arquivo.bin", "rb");

    if(arq == NULL){
        printf("Erro ao tentar abrir o arquivo!\n");
        return;
    }

    // LE O ARQUIVO
    fread(&texto, sizeof(char), 12, arq);
    fread(&inteiro, sizeof(int), 1, arq);
    fread(&real, sizeof(float), 1, arq);
    fread(&caracter,sizeof(char), 1, arq);
        
    // FECHA O ARQUIVO
    fclose(arq);  

    printf("texto: %s\n", texto);  
    printf("inteiro: %d\n", inteiro); 
    printf("real: %f\n", real); 
    printf("caracter: %c\n", caracter); 
}
//=============================================================================

int main(){

    gravar_arquivo_texto();
    ler_texto_texto();

    gravar_arquivo_binario();
    ler_texto_binario();

    return 1;
}
// Fim do arquivo: arquivos.c

--------------------------------------------------------------------------------

// Início do arquivo: arq07.c
#include <stdio.h> 
#include <stdlib.h> 

int main(int argc, char *argv[]) {

   FILE *in = fopen ("teste.txt", "r"), 
        *out = fopen ("copia.txt", "w");

   while ( !feof(in) ) {
      char ch = getc(in);
      if ( !feof(in)) {
         putc(ch, out);
      }
   }

   fclose(in);
   fclose(out);
   return 0; 
}

// Fim do arquivo: arq07.c

--------------------------------------------------------------------------------

// Início do arquivo: arq04.c
#include <stdio.h> 
#include <stdlib.h> 

int main(int argc, char *argv[]) { 

   FILE *p = fopen ("teste.txt", "r"); 
   char str[100+1];
   char* resp;
   int i = 0;

   if (p != NULL) {
      do {
         resp = fgets(str, 100, p);
         if(resp != NULL){
            printf("(%d) %s", i, str);
            i++;
         }
      } while (resp != NULL);
      fclose(p);
   }

   return 0; 
}

// Fim do arquivo: arq04.c

--------------------------------------------------------------------------------

// Início do arquivo: arq01.c
#include <stdio.h> 
#include <stdlib.h> 



int main(int argc, char *argv[]) { 

   FILE *p = fopen ("teste.txt", "r"); 
   // testa se o arquivo foi aberto com sucesso 
   if (p != NULL) {
      printf ("Arquivo foi aberto com sucesso.\n\n"); 
      fclose(p);
   } else {
      printf ("Nao foi possivel abrir o arquivo.\n\n"); 
   }

   return 0; 
}

// Fim do arquivo: arq01.c

--------------------------------------------------------------------------------

// Início do arquivo: arq06.c
#include <stdio.h> 
#include <stdlib.h> 

int main(int argc, char *argv[]) { 

   FILE *p = fopen ("teste.txt", "w"); 
   fputs("Algoritmos e Estruturas de Dados II", p);
   fclose(p);

   return 0; 
}

// Fim do arquivo: arq06.c

--------------------------------------------------------------------------------

// Início do arquivo: arq12.c
#include <stdio.h>

int main(int argc, char *argv[]) { 
   FILE *p  = fopen("teste.txt", "wb+");
   int registro, valor, i;

   for (i = valor = 0; i < 10; i++, valor = i * 10)    fwrite(&valor, sizeof(int), 1, p);

   int numRegistro = ftell(p) / sizeof (int);

   do {
      printf ("\nEscolha um numero entre zero e %i: ", numRegistro-1);
      scanf("%d", &registro);
   } while (registro < 0 || registro >= numRegistro);

   fseek(p, registro * sizeof(int), SEEK_SET);
   fread(&valor, sizeof(int), 1, p);
   fclose(p);
   printf ("\nValor: %d\n\n", valor);

   return 0; 
}

// Fim do arquivo: arq12.c

--------------------------------------------------------------------------------

// Início do arquivo: arq02.c
#include <stdio.h> 
#include <stdlib.h> 



int main(int argc, char *argv[]) { 

   FILE *p = fopen ("teste.txt", "r"); 

   // testa se o arquivo foi aberto com sucesso 
   if (p != NULL) {
      printf ("Arquivo foi aberto com sucesso.\n\n"); 
      fclose(p);
   } else {
      printf ("Nao foi possivel abrir o arquivo.\n\n"); 
   }

   return 0; 
}

// Fim do arquivo: arq02.c

--------------------------------------------------------------------------------

// Início do arquivo: arq10.c
#include <stdio.h>
#include <string.h>

typedef struct cliente {
   char nome[100];
   int codigo;
} cliente;

void escrever(char*);
void ler(char*);

void main(int argc, char** argv){
   escrever("teste.txt");
   ler("teste.txt");
}

void escrever(char* nomeArq){
   cliente c1, c2;
   strcat(c1.nome, "Ze da Silva");		c1.codigo = 1;
   strcat(c2.nome, "Lele da Cuca");	c2.codigo = 11; 
   FILE *p = fopen(nomeArq, "ab");
   fwrite(&c1, sizeof(cliente), 1, p);
   fwrite(&c2, sizeof(cliente), 1, p);
   fclose(p);
}  

void ler(char* nomeArq){
   cliente c1, c2;
   FILE *p = fopen(nomeArq, "rb");
   fread(&c1, sizeof(cliente), 1, p);
   fread(&c2, sizeof(cliente), 1, p);
   fclose(p); 
   printf("%s -- %d\n", c1.nome, c1.codigo);
   printf("%s -- %d\n", c2.nome, c2.codigo);
}

// Fim do arquivo: arq10.c

--------------------------------------------------------------------------------

// Início do arquivo: arq11.c
#include <stdio.h>

int main(int argc, char *argv[]) { 
   FILE *p  = fopen("teste.txt", "wb+");

   double d = 12.23;		int i = 101;			long l = 123023L;


   fwrite(&d, sizeof(double), 1, p);
   fwrite(&i, sizeof(int), 1, p);
   fwrite(&l, sizeof(long), 1, p);

   rewind(p);

   fread(&d, sizeof(double), 1, p);
   fread (&i, sizeof(int), 1, p);
   fread (&l, sizeof(long), 1, p);

   printf("%f %d %ld", d, i, l);
   fclose(p);

   return 0; 
}

// Fim do arquivo: arq11.c

--------------------------------------------------------------------------------

// Início do arquivo: arq09.c
#include <stdio.h> 
#include <stdlib.h> 

int main(int argc, char *argv[]) { 

   FILE *p; 

   double d;
   int i;
   long l;

   if ((p = fopen("teste.txt", "rb")) == NULL) {
      printf ("arquivo nao pode ser aberto\n");
      exit(1);
   }

   fread(&d, sizeof(double), 1, p);
   fread (&i, sizeof(int), 1, p);
   fread (&l, sizeof(long), 1, p);

   printf("%f %d %ld", d, i, l);
   fclose(p);
   return 0; 
}


// Fim do arquivo: arq09.c

--------------------------------------------------------------------------------

// Início do arquivo: arq03.c
#include <stdio.h> 
#include <stdlib.h> 

int main(int argc, char *argv[]) { 

   FILE *p = fopen (argv[1], "r"); 
   int ch;

   if (p != NULL) {
      do {
         ch = fgetc(p);
         if(ch != EOF){
            printf( "%i %c\n", ch, (char)ch);
            //printf( "%c", (char)ch);
         }
      } while (ch != EOF);
      fclose(p);
   }

   return 0; 
}

// Fim do arquivo: arq03.c

--------------------------------------------------------------------------------

// Início do arquivo: ponteiro02.c
#include <stdio.h>
#include <stdlib.h>

int main (int argc, char** argv){
   int x1 = 11, 
       x2 = 22, 
       x3 = 33;   
   int *p;

   p = &x1; //p <- o endereço de x1
   x2 = *p; //x2 <- o cont. do addr apont. por p
   *p = x3; //o cont. do addr apont. por p <- x3
   p = &x3; //p <- o endereço de x3
   *p = 0;  //o cont. do addr apont. por p <- x3

   printf("\ncont:%d %d %d %d", x1, x2, x3, *p);
   printf("\naddr:%p %p %p %p", &x1, &x2, &x3, p);
   printf("\n");
}

// Fim do arquivo: ponteiro02.c

--------------------------------------------------------------------------------

// Início do arquivo: ponteiro09.c
#include <stdio.h>
#include <stdlib.h>

int main (int argc, char** argv){
   int *x1;
   int x2;
   int *x3;

   x1 = (int*) malloc(sizeof(int));
   printf("\nx1(%p)(%p)(%i) x2(%p)(%i) x3(%p)(%p)(%i)", &x1, x1, *x1, &x2, x2, &x3, x3, *x3);

   *x1 = 20;
   printf("\nx1(%p)(%p)(%i) x2(%p)(%i) x3(%p)(%p)(%i)", &x1, x1, *x1, &x2, x2, &x3, x3, *x3);

   x2 = *x1;
   printf("\nx1(%p)(%p)(%i) x2(%p)(%i) x3(%p)(%p)(%i)", &x1, x1, *x1, &x2, x2, &x3, x3, *x3);

   *x3 = x2 * *x1;
   printf("\nx1(%p)(%p)(%i) x2(%p)(%i) x3(%p)(%p)(%i)", &x1, x1, *x1, &x2, x2, &x3, x3, *x3);

   x3 = &x2;
   printf("\nx1(%p)(%p)(%i) x2(%p)(%i) x3(%p)(%p)(%i)", &x1, x1, *x1, &x2, x2, &x3, x3, *x3);

   x2 = 15;
   printf("\nx1(%p)(%p)(%i) x2(%p)(%i) x3(%p)(%p)(%i)", &x1, x1, *x1, &x2, x2, &x3, x3, *x3);

   x2 = 13 & 3;
   printf("\nx1(%p)(%p)(%i) x2(%p)(%i) x3(%p)(%p)(%i)", &x1, x1, *x1, &x2, x2, &x3, x3, *x3);

   x2 = 13 | 3;
   printf("\nx1(%p)(%p)(%i) x2(%p)(%i) x3(%p)(%p)(%i)", &x1, x1, *x1, &x2, x2, &x3, x3, *x3);

   x2 = 13 >> 1;
   printf("\nx1(%p)(%p)(%i) x2(%p)(%i) x3(%p)(%p)(%i)", &x1, x1, *x1, &x2, x2, &x3, x3, *x3);

   x2 = 13 << 1;
   printf("\nx1(%p)(%p)(%i) x2(%p)(%i) x3(%p)(%p)(%i)", &x1, x1, *x1, &x2, x2, &x3, x3, *x3);

   return 0;
}

// Fim do arquivo: ponteiro09.c

--------------------------------------------------------------------------------

// Início do arquivo: ponteiro01.c
#include <stdio.h>
#include <stdlib.h>

int main (int argc, char** argv){
   int x = 10;
   int * y = & x;
   printf("\n%i", x);
   printf("\n%p", &x);
   printf("\n%p", y); 
   printf("\n%p", &y);
   printf("\n%i", *y);
   printf("\n");
}

// Fim do arquivo: ponteiro01.c

--------------------------------------------------------------------------------

// Início do arquivo: ponteiro07.c
#include <stdio.h>
#include <stdlib.h>

int main (int argc, char** argv){
   double a;
   double *p, *q;

   a = 3.14;
   printf("%f\n", a);

   p = &a;
   *p = 2.718;
   printf("%f\n", a);

   a = 5;
   printf("%f\n", *p);

   p = NULL;
   p = (double*) malloc(sizeof(double));
   *p = 20;
   q = p;

   printf("%f\n", *p);
   printf("%f\n", a);
   free(p);
   printf("%f\n", *q);
   printf("\n");

   return 0;
}

// Fim do arquivo: ponteiro07.c

--------------------------------------------------------------------------------

// Início do arquivo: ponteiro12.c
#include <stdio.h>
#include <stdlib.h>

typedef struct Elemento {
   int valor;
} Elemento;

int main (int argc, char** argv){
   Elemento e1;
   Elemento* e2 = (Elemento*) malloc (3 * sizeof (Elemento));
   Elemento e3[3];
   Elemento** e4 = (Elemento**) malloc(3 * sizeof(Elemento*));
   e4[0] = (Elemento*) malloc(sizeof(Elemento*));
   e4[2] = (Elemento*) malloc(sizeof(Elemento*));

   e4[0]->valor = 7;

   printf("\n%i -- %i\n", e4[0]->valor, e4[2]->valor);
   return 0;
}

// Fim do arquivo: ponteiro12.c

--------------------------------------------------------------------------------

// Início do arquivo: ponteiro08.c
#include <stdio.h>
#include <stdlib.h>

int main (int argc, char** argv){
   int a[10], *b;

   b = a;
   b[5] = 100;
   printf("\n%d -- %d", a[5], b[5]);

   b = (int*) malloc(10*sizeof(int));
   b[7] = 100;
   printf("\n%d -- %d", a[7], b[7]);
   printf("\n");

   //O comando a = b gera um erro de compilação

   return 0;
}

// Fim do arquivo: ponteiro08.c

--------------------------------------------------------------------------------

// Início do arquivo: ponteiro05.c
#include <stdio.h>
#include <stdlib.h>

#define MAXTAM 10

typedef struct Cliente {
   int codigo;
   char nome[MAXTAM];
} Cliente;


int main (int argc, char** argv){
   char* p1 = (char*) malloc (sizeof(char));
   int* p2 = (int*) malloc (sizeof(int));
   float* p3 = (float*) malloc (sizeof(float));
   Cliente* p4 = (Cliente*) malloc (sizeof(Cliente));
   int* p5 = (int*) malloc (MAXTAM * sizeof (int));
   Cliente* p6 =(Cliente*) malloc (MAXTAM * sizeof (Cliente));

   free(p1);
   free(p2);
   free(p3);
   free(p4);
   free(p5);
   free(p6);
}

// Fim do arquivo: ponteiro05.c

--------------------------------------------------------------------------------

// Início do arquivo: ponteiro11.c
#include <stdio.h>
#include <stdlib.h>

typedef struct Celula {
   int elemento;
   struct Celula *prox;
} Celula;

Celula *novaCelula(int elemento) {
   Celula *nova = (Celula*) malloc(sizeof(Celula));
   nova->elemento = elemento;
   nova->prox = NULL;
   return nova;
}

int main (int argc, char** argv){
   Celula *tmp = novaCelula(3);

   return 0;
}

// Fim do arquivo: ponteiro11.c

--------------------------------------------------------------------------------

// Início do arquivo: ponteiro06.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAXTAM 100

typedef struct Cliente {
   int codigo;
   char nome[MAXTAM];
} Cliente;

int main (int argc, char** argv){
   Cliente registro;
   Cliente* ponteiro = (Cliente*) malloc (sizeof(Cliente));

   registro.codigo = 1;
   strcpy(registro.nome, "AA");
   printf("\nFuncionario (%i): %s", registro.codigo, registro.nome);

   ponteiro->codigo = 2;
   strcpy(ponteiro->nome, "BB");
   printf("\nFuncionario (%i): %s", ponteiro->codigo, ponteiro->nome);
   printf("\n");
}

// Fim do arquivo: ponteiro06.c

--------------------------------------------------------------------------------

// Início do arquivo: ponteiro10.c
#include <stdio.h>
#include <stdlib.h>

#define MAXTAM 10

typedef struct Cliente {
   int codigo;
   char nome[MAXTAM];
} Cliente;

int main (int argc, char** argv){
   Cliente c;
   c.codigo = 5;
   Cliente *p = NULL;
   p = (Cliente*) malloc (sizeof(Cliente));
   p->codigo = 6;
   Cliente *p2 = &c;
   p2->codigo = 7;

   return 0;
}

// Fim do arquivo: ponteiro10.c

--------------------------------------------------------------------------------

// Início do arquivo: ponteiro03.c
#include <stdio.h>
#include <stdlib.h>

int main (int argc, char** argv){
   int *x1;
   int x2;
   int *x3;

   x1 = (int*) malloc (sizeof(int));
   printf("\nx1(%p)(%i)(%p) x2(%i)(%p) x3(%p)(%i)(%p)", x1, *x1, &x1, x2, &x2, x3, *x3, &x3);

   *x1 = 20;
   printf("\nx1(%p)(%i)(%p) x2(%i)(%p) x3(%p)(%i)(%p)", x1, *x1, &x1, x2, &x2, x3, *x3, &x3);

   x2 = *x1;      
   printf("\nx1(%p)(%i)(%p) x2(%i)(%p) x3(%p)(%i)(%p)", x1, *x1, &x1, x2, &x2, x3, *x3, &x3);

   *x3 = x2 * *x1;
   printf("\nx1(%p)(%i)(%p) x2(%i)(%p) x3(%p)(%i)(%p)", x1, *x1, &x1, x2, &x2, x3, *x3, &x3);

   x3 = &x2;
   printf("\nx1(%p)(%i)(%p) x2(%i)(%p) x3(%p)(%i)(%p)", x1, *x1, &x1, x2, &x2, x3, *x3, &x3);

   x2 = 15;
   printf("\nx1(%p)(%i)(%p) x2(%i)(%p) x3(%p)(%i)(%p)", x1, *x1, &x1, x2, &x2, x3, *x3, &x3);
   printf("\n");
}

// Fim do arquivo: ponteiro03.c

--------------------------------------------------------------------------------

// Início do arquivo: ponteiro04.c
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int main (int argc, char** argv){
   double M [3][3];
   double *p = M[0];

   for (int i = 0; i < pow(3, 2); i++, p++){
      *p=0.0;
   }

}

// Fim do arquivo: ponteiro04.c

--------------------------------------------------------------------------------

// Início do arquivo: ponteiro05emCMaisMais.cc
#include <iostream>
using namespace std;

#define MAXTAM 10

typedef struct Cliente {
   int codigo;
   char nome[MAXTAM];
} Cliente;


int main (int argc, char** argv){
   char* p1 = new char;
   int* p2 = new int;
   float* p3 = new float;
   Cliente* p4 = new Cliente;
   int* p5 = new int [MAXTAM];
   Cliente* p6 = new Cliente[MAXTAM];

   delete p1;
   delete p2;
   delete p3;
   delete p4;
   delete [] p5;
   delete [] p6;
}

// Fim do arquivo: ponteiro05emCMaisMais.cc

--------------------------------------------------------------------------------

// Início do arquivo: chamandometodo.c
#include <stdio.h> 
#include <stdlib.h> 

void terceiro(){
   printf("3o - inicio e fim\n");
}

void segundo(){
   printf("2o - inicio\n");
   terceiro();
   printf("2o - fim\n");
}

void primeiro(){
   printf("1o - inicio\n");
   segundo();
   printf("1o - fim\n");
}

int main(int argc, char *argv[]) { 
   printf("main - inicio\n");
   primeiro();
   printf("main - fim\n");

   return 0; 
}

// Fim do arquivo: chamandometodo.c

--------------------------------------------------------------------------------

// Início do arquivo: multiplicacao.c
#include <stdio.h> 
#include <stdlib.h> 

int multiplicacaoRec(int a, int b, int i){
   int resp = 0;

   if(i < b){
      resp = a + multiplicacaoRec(a, b, i+1);
   }

   return resp;
}

int multiplicacao(int a, int b){
   return multiplicacaoRec(a, b, 0);
}

int multiplicacaoIt(int a, int b){
   int resp = 0;
   for(int i = 0; i < b; i++){
      resp = a + resp;
   }
   return resp;
}

int main(int argc, char *argv[]) { 
   int mult = multiplicacaoIt(4, 3);
   printf("\nRESPOSTA IT: %i", mult);

   mult = multiplicacao(4, 3);
   printf("\nRESPOSTA REC: %i", mult);

   return 0; 
}

// Fim do arquivo: multiplicacao.c

--------------------------------------------------------------------------------

// Início do arquivo: fatorialrecursivo.c
#include <stdio.h> 
#include <stdlib.h> 

int fatorial(int n){
   int resp;
   printf("\nfat (%i)", n);
   resp = (n == 1) ? 1 : n * fatorial(n-1);
   printf("\nfat n(%i): %i", n, resp);
   return resp;
}


int main(int argc, char *argv[]) { 
   int n = 5;
   printf("\nFATORIAL RECURSIVO(%i): %i", n, fatorial(n));

   return 0; 
}

// Fim do arquivo: fatorialrecursivo.c

--------------------------------------------------------------------------------

// Início do arquivo: printrecursivo.c
#include <stdio.h> 
#include <stdlib.h> 

void printRecursivo(int i){
   printf("\nvalor de i: %i", i);
   if(i > 0){
      printRecursivo(i-1);
   }
   printf("\nvalor de i: %i", i);
}

int main(int argc, char *argv[]) { 
   int n = 3;
   printRecursivo(n);

   return 0; 
}

// Fim do arquivo: printrecursivo.c

--------------------------------------------------------------------------------

// Início do arquivo: fibonaccirecursivo.c
#include <stdio.h> 
#include <stdlib.h> 

int fibonacci(int n){
   int resp;
   printf("\nfib (%i)", n);
   resp = (n == 0 || n == 1) ? 1 : fibonacci(n-1) + fibonacci(n-2);
   printf("\nfib n(%i): %i", n, resp);
   return resp;
}


int main(int argc, char *argv[]) { 
   int n = 5;
   printf("\nFIBONACCI RECURSIVO(%i): %i", n, fibonacci(n));

   return 0; 
}

// Fim do arquivo: fibonaccirecursivo.c

--------------------------------------------------------------------------------

// Início do arquivo: contarmaiuscula.c
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h>

#define bool int
#define true 1
#define false 0

bool isUpper(char x){
   return (x >= 'A' && x <= 'Z');
}

int contMaiusculo(char* s){
   int cont = 0;

   for(int i = 0; i < strlen(s); i++){
      if(isUpper(s[i]) == true){
         cont++;
      }
   }
   return cont;
}

int contMaiusculoRec(char* s, int i){
   int cont = 0;

   if(i < strlen(s)){
      if(isUpper(s[i]) == true){
         cont++;
      }
      cont += contMaiusculoRec(s, i + 1);
   }
   return cont;
}

int contMaiusculoRecursivo(char* s){
   return contMaiusculoRec(s, 0);
}

int main(int argc, char *argv[]) { 
   printf("\nAlGoritmos e Estrutudas de Dados: %i", contMaiusculo("AlGoritmos e Estruturas de Dados"));
   printf("\nAlGoritmos e Estruturas de Dados: %i", contMaiusculoRecursivo("AlGoritmos e Estruturas de Dados"));

   return 0; 
}

// Fim do arquivo: contarmaiuscula.c

--------------------------------------------------------------------------------

// Início do arquivo: helloworld.h
#ifndef _H_TESTE
#define _H_TESTE
 
void helloWorld(void);
 
#endif

// Fim do arquivo: helloworld.h

--------------------------------------------------------------------------------

// Início do arquivo: helloworld.c
#include <stdio.h>
#include <stdlib.h>

void helloWorld(void){
	printf("Hello World!\n");
}

// Fim do arquivo: helloworld.c

--------------------------------------------------------------------------------

// Início do arquivo: main.c
#include <stdio.h>
#include <stdlib.h>
#include "helloworld.h"
 
int main(){
 helloWorld();
 return (0);
}

// Fim do arquivo: main.c

--------------------------------------------------------------------------------

// Início do arquivo: makefile
# My first makefile

all: printy

printy: main.o helloworld.o
	gcc -o printy main.o helloworld.o

main.o: main.c helloworld.h
	gcc -o main.o main.c -c -W -Wall -ansi -pedantic

helloworld.o: helloworld.c helloworld.h
	gcc -o helloworld.o helloworld.c -c -W -Wall -ansi -pedantic

clean:
	rm -rf *.o *~ printy

// Fim do arquivo: makefile

--------------------------------------------------------------------------------

// Início do arquivo: registro01.c


#include <stdio.h>

#define MAXTAM   100

struct Funcionario {
   int matricula;
   char nome[MAXTAM];
};

void main (){
   struct Funcionario f;

   printf("\nEntre com a matricula: ");
   scanf("%d", &f.matricula);

   printf("\nEntre com o nome: ");
   scanf("%s", f.nome);

   printf("\nMatricula: %d", f.matricula);
   printf("\nNome: %s", f.nome);
   printf("\n\n");
}

// Fim do arquivo: registro01.c

--------------------------------------------------------------------------------

// Início do arquivo: registro04.c
#include <stdio.h>

#define MAXTAM   100

struct Funcionario {
   int matricula;
   char nome[MAXTAM];
};

typedef struct Funcionario Funcionario;

void main (){
   Funcionario vet[MAXTAM];
   int n = 3;

   for(int i = 0; i < n; i++){
      printf("\nEntre com a matricula do funcionario %d: ", (i+1));
      scanf("%d", &vet[i].matricula);

      printf("\nEntre com o nome do funcionario %d: ", (i+1));
      scanf("%s", vet[i].nome);
   }

   for(int i = 0; i < n; i++){
      printf("\nMatricula do funcionario %d: %d", (i+1), vet[i].matricula);
      printf("\nNome do funcionario %d: %s\n", (i+1), vet[i].nome);
   }
   printf("\n\n");
}

// Fim do arquivo: registro04.c

--------------------------------------------------------------------------------

// Início do arquivo: registro03.c
#include <stdio.h>

#define MAXTAM   100

typedef struct Funcionario {
   int matricula;
   char nome[MAXTAM];
} Funcionario;

void main (){
   Funcionario f;

   printf("\nEntre com a matricula: ");
   scanf("%d", &f.matricula);

   printf("\nEntre com o nome: ");
   scanf("%s", f.nome);

   printf("\nMatricula: %d", f.matricula);
   printf("\nNome: %s", f.nome);
   printf("\n\n");
}

// Fim do arquivo: registro03.c

--------------------------------------------------------------------------------

// Início do arquivo: registro02.c
#include <stdio.h>

#define MAXTAM   100

struct Funcionario {
   int matricula;
   char nome[MAXTAM];
};

typedef struct Funcionario Funcionario;

void main (){
   Funcionario f;

   printf("\nEntre com a matricula: ");
   scanf("%d", &f.matricula);

   printf("\nEntre com o nome: ");
   scanf("%s", f.nome);

   printf("\nMatricula: %d", f.matricula);
   printf("\nNome: %s", f.nome);
   printf("\n\n");
}

// Fim do arquivo: registro02.c

--------------------------------------------------------------------------------

// Início do arquivo: README.md
# U1 - Introdução
Repositório de códigos da disciplina de Algoritmos e Estrutura de Dados II

// Fim do arquivo: README.md

--------------------------------------------------------------------------------

// Início do arquivo: Log.java
class Log {
   public static void main (String[] args) {
      int[] n = {4,5,6,7,8,9,10,11,12,13,14,15,16,17,31,32,33,63,64,65};
      int cont;

      for(int k = 0; k < n.length; k++){
         System.out.print("\n[n = " + n[k] + "] => ");
         cont = 0;
         for(int i = n[k]; i > 0; i /= 2){
            System.out.print(" " + i);
            cont++;
         }
         System.out.print(" (" + cont + " vezes)");
      }
      System.out.print("\n");
   }
}

// Fim do arquivo: Log.java

--------------------------------------------------------------------------------

// Início do arquivo: Pesquisa.java
class Pesquisa {
   public static boolean pesqSeq(int[] vet, int x){
      boolean resp = false;
      int n = vet.length;

      for(int i = 0; i < n; i++){
         if(vet[i] == x){
            resp = true;
            i = n;
         }
      }
      return resp;
   }

   public static boolean pesqBin(int[] vet, int x){
      boolean resp = false;
      int dir = (vet.length - 1), esq = 0, meio;

      while (esq <= dir){
         meio = (esq + dir) / 2;
         if(x == vet[meio]){
            resp = true;
            esq = dir + 1;
         } else if (x > vet[meio]) {
            esq = meio + 1;
         } else {
            dir = meio - 1;
         }
      }
      return resp;
   }

   public static boolean pesqBinRec(int[] vet, int x){
      return pesqBinRec(vet, x, 0, (vet.length - 1));
   }

   public static boolean pesqBinRec(int[] vet, int x, int esq, int dir){
      boolean resp;
      int meio = (esq + dir) / 2;

      if(esq > dir) {
         resp = false;
      } else if(x == vet[meio]){
         resp = true;
      } else if (x > vet[meio]) {
         resp = pesqBinRec(vet, x, meio + 1, dir);
      } else {
         resp = pesqBinRec(vet, x, esq, meio - 1);
      }
      return resp;
   }

   public static void main (String[] args){
      int[] vet = {2, 3, 5, 7, 9, 11, 15, 17, 20, 21, 30, 43, 49, 70, 71, 82};
      int x = 35;

      System.out.println("Pesquisa Sequencial: " + pesqSeq(vet, x));
      System.out.println("Pesquisa Binária: " + pesqBin(vet, x));
      System.out.println("Pesquisa Binária Recursiva: " + pesqBinRec(vet, x));
   }
}

// Fim do arquivo: Pesquisa.java

--------------------------------------------------------------------------------

// Início do arquivo: AND_OR.java
class AND_OR {
   public static boolean m1(){
      System.out.println("m1");
      return true;
   }
   public static boolean m2(){
      System.out.println("m2");
      return false;
   }
   public static void main (String[] args) {
      System.out.println("=====================");
      boolean or = m1() || m2();
      System.out.println("OR: " + or);
      System.out.println("=====================");
      boolean and = m2() && m1();
      System.out.println("AND: " + and);
      System.out.println("=====================");
   }
}

// Fim do arquivo: AND_OR.java

--------------------------------------------------------------------------------

// Início do arquivo: README.md
# U8 - Tabelas e dicionários
Repositório de códigos da disciplina de Algoritmos e Estrutura de Dados II

// Fim do arquivo: README.md

--------------------------------------------------------------------------------

// Início do arquivo: DoidonaComTADsProntas.java
class DoidonaComTADsProntas {
   final int TAMT1 = 100;
   final int TAMT3 = 100;
   final int NULO = -0x7FFFFF;

   int[] t1;
   int[] t3;

   ArvoreBinaria arvoreBinaria;
   ListaSimples lista;
   AVL arvoreAVL;

   public Doidona(){
      t1 = new int [TAMT1];
      t3 = new int [TAMT3];

      for(int i = 0; i < TAMT1; i++){
         t1[i] = NULO;
      }
      for(int i = 0; i < TAMT3; i++){
         t3[i] = NULO;
      }

      arvoreBinaria = new ArvoreBinaria();
      arvoreAVL = new AVL();
      lista = new ListaSimples();
   }

   public int hashT1(int elemento){
   }

   public int hashT2(int elemento){
      return elemento % 3;
   }

   public int hashT3(int elemento){
   }

   public int rehashT3(int elemento){
   }

   public void inserir(int elemento){
      int i = hashT1(elemento);
      if(elemento == NULO) {
         //gerar msg de erro para o usuario...
      } else if(t1[i] == NULO){
         t1[i] = elemento;
      }else if(hashT2(elemento) == 0){
         i = hashT3(elemento);
         if(t3[i] == NULO){
            t3[i] = elemento;
         } else {
            i = rehashT3(elemento);
            if(t3[i] == NULO){
               t3[i] = elemento;
            } else {
               arvoreBinaria.inserir(elemento);
            }
         }
      }else if (hashT2(elemento) == 1){
         lista.inserirFim(elemento);
      }else if (hashT2(elemento) == 2){
         arvoreAVL.inserir(elemento);
      } else {
         System.out.println("ERRO!!!!");
      }
   }
   void remover (int elemento){
   }

   boolean pesquisar (int elemento){
      boolean resp = false;
      int pos = hashT1(elemento);
      if(elemento == NULO){
         resp = false;
      } else if(t1[pos] == elemento){
         resp = true;
      }else {
         pos = hashT2(elemento);
         if (pos == 0){
            pos = hashT3(elemento);
            if(t3[pos] == elemento){
               resp = true;
            }else{
               pos = rehashT3(elemento);
               if(t3[pos] == elemento){
                  resp = true;
               }else{
                  resp = arvoreBinaria.pesquisar(elemento);
               }
            }
         }else if (pos == 1){
            resp = lista.pesquisar(elemento);
         } else {
            resp = arvoreAVL.pesquisar(elemento);
         }
      }
      return resp;
   }

   void mostrar(){
      //t1, t3, arvoreBinaria, lista, arvoreAVL
      for(int i = 0; i < TAMT1; i++){
         if(t1[i] != NULO){
            System.out.println(t1[i]);
         }
      }
      for(int i = 0; i < TAMT3; i++){
         if(t3[i] != NULO){
            System.out.println(t3[i]);
         }
      }
      arvoreBinaria.mostrar();
      lista.mostrar();
      arvoreAVL.mostrar();
   }
}

// Fim do arquivo: DoidonaComTADsProntas.java

--------------------------------------------------------------------------------

// Início do arquivo: DoidonaSemTADsProntas.java
class DoidonaSemTADsProntas {
   final int TAMT1 = 100;
   final int TAMT3 = 100;
   final int NULO = -0x7FFFFF;

   int[] t1;
   int[] t3;

   Celula primeiroListaT2, ultimoListaT2;
   No raizArvoreT2, raizArvoreT3;

   public Doidona (){
      t1 = new int[TAMT1];
      t3 = new int[TAMT3];

      for(int i = 0; i < TAMT1; i++){
         t1[i] = NULO;
      }
      for(int i = 0; i < TAMT3; i++){
         t3[i] = NULO;
      }

      primeiroListaT2 = ultimoListaT2 = new Celula();

      raizArvoreT2 = raizArvoreT3 = null;
   }

   public int hashT1(int elemento){
   }

   public int hashT2(int elemento){
   }

   public int hashT3(int elemento){
   }

   public int rehashT3(int elemento){
   }

   public void inserir(int elemento){
      int i = hashT1(elemento);

      if(elemento == NULO){
         // gerar msg de erro!!!!
      } else if(t1[i] == NULO){
         t1[i] = elemento;
      }else if(hashT2(elemento) == 0){
         inserirT3(elemento);
      }else if (hashT2(elemento) == 1){
         inserirLista(elemento);
      }else if (hashT2(elemento) == 2){
         raizArvoreT2 = inserirArvore(raizArvoreT2, elemento);
      } else {
         System.out.println("ERRO!!!!");
      }
   }

   public void inserirT3(int elemento){
      int i = hashT3(elemento);

      if(t3[i] == NULO){
         t3[i] = elemento;
      } else {
         i = rehashT3(elemento);

         if(t3[i] == NULO){
            t3[i] = elemento;
         } else {
            raizArvoreT3 = inserirArvore(raizArvoreT3, elemento);
         }
      }
   }

   public void inserirLista(int elemento){
      ultimoListaT2.prox = new Celula(elemento);
      ultimoListaT2 = ultimoListaT2.prox;
   }

   public No inserirArvore(No no, int elemento){
      if(no == null){
         no = new No (elemento);
      } else if (no.elemento < elemento){
         no.esq = inserirArvore(no.esq, elemento);
      } else if (no.elemento > elemento){
         no.dir = inserirArvore(no.dir, elemento);
      } else {
         System.out.println("Erro de Insercao");
      }
      return no;
   }

   public boolean pesquisar(int elemento){
      boolean resp;
      int i = hashT1(elemento);
      if(t1[i] == NULO){
         resp = false;
      }else if(t1[i] == elemento){
         resp = true;
      }else if(hashT2(elemento) == 0){
         resp = pesquisarT3(elemento);
      }else if (hashT2(elemento) == 1){
         resp = pesquisarLista(elemento);
      }else if (hashT2(elemento) == 2){
         resp = pesquisarArvore(raizArvoreT2, elemento);
      } else {
         resp = false;
         System.out.println("ERRO!!!!");
      }
      return resp;
   }

   public boolean pesquisarT3(int elemento){
      int i = hashT3(elemento);

      if(t3[i] == NULO){
         resp = false;
      }else if(t3[i] == elemento){
         resp = true;
      } else {
         i = rehashT3(elemento);

         if(t3[i] == NULO){
            resp = false;
         } else if(t3[i] == elemento){
            resp = true;
         } else {
            resp = pesquisarArvore(raizArvoreT3, elemento);
         }
      }

      return resp;
   }

   public boolean pesquisarLista(int elemento){
      boolean resp = false;
      for(Celula i = primeiroListaT2.prox; i != null; i = i.prox){
         if(i.elemento == elemento){
            resp = true;
            i = ultimoListaT2;
         }
      }
      return resp;
   }

   public boolean pesquisarArvore(No no, int elemento){
      boolean resp;

      if(no == null){
         resp = false;
      } else if (no.elemento < elemento){
         resp = pesquisarArvore(no.esq, elemento);
      } else if (no.elemento > elemento){
         resp = pesquisarArvore(no.dir, elemento);
      } else {
         resp = true;
      }
      return resp;
   }
}

// Fim do arquivo: DoidonaSemTADsProntas.java

--------------------------------------------------------------------------------

// Início do arquivo: Hash.java

public class Hash {
   int tabela[];
   int m;
   final int NULO = -1;

   public Hash() {
      this(13);
   }

   public Hash(int m) {
      this.m = m;
      this.tabela = new int[this.m];
      for (int i = 0; i < m; i++) {
         tabela[i] = NULO;
      }
   }

   public int h(int elemento) {
      return elemento % m;
   }

   public int reh(int elemento) {
      return ++elemento % m;
   }

   public boolean inserir(int elemento) {
      boolean resp = false;
      if (elemento != NULO) {
         int pos = h(elemento);
         if (tabela[pos] == NULO) {
            tabela[pos] = elemento;
            resp = true;
         } else {
            pos = reh(elemento);
            if (tabela[pos] == NULO) {
               tabela[pos] = elemento;
               resp = true;
            }
         }
      }
      return resp;
   }

   public boolean pesquisar(int elemento) {
      boolean resp = false;
      int pos = h(elemento);
      if (tabela[pos] == elemento) {
         resp = true;
      } else if (tabela[pos] != NULO) {
         pos = reh(elemento);
         if (tabela[pos] == elemento) {
            resp = true;
         }
      }
      return resp;
   }

   boolean remover(int elemento) {
      boolean resp = false;
      // ...
      return resp;
   }
}

// Fim do arquivo: Hash.java

--------------------------------------------------------------------------------

// Início do arquivo: Hash.java

public class HashIndiretoLista {
   Lista tabela[];
   int tamanho;
   final int NULO = -1;

   public HashIndiretoLista() {
      this(7);
   }

   public HashIndiretoLista(int tamanho) {
      this.tamanho = tamanho;
      tabela = new Lista[tamanho];
      for (int i = 0; i < tamanho; i++) {
         tabela[i] = new Lista();
      }
   }

   public int h(int elemento) {
      return elemento % tamanho;
   }

   boolean pesquisar(int elemento) {
      int pos = h(elemento);
      return tabela[pos].pesquisar(elemento);
   }

   public void inserirInicio(int elemento) {
      int pos = h(elemento);
      tabela[pos].inserirInicio(elemento);
   }

   public int remover(int elemento) {
      int resp = NULO;
      if (pesquisar(elemento) == false) {
         throw new Exception("Erro ao remover!");
      } else {
         int pos = h(elemento);
         resp = tabela[pos].remover(elemento);
      }
      return resp;
   }
}

// Fim do arquivo: Hash.java

--------------------------------------------------------------------------------

// Início do arquivo: Lista.java
/**
 * Celula simplesmente encadeada
 * @author Joao Paulo Domingos Silva
 * @version 1.1 02/2012
 */
class Celula {
	public int elemento; // Elemento inserido na celula.
	public Celula prox; // Aponta a celula prox.

	/**
	 * Construtor da classe.
	 * @param elemento Elemento inserido na celula.
	 */
	Celula(int elemento) {
		this.elemento = elemento;
		this.prox = null;
	}

	/**
	 * Construtor da classe.
	 * @param elemento Elemento inserido na celula.
	 * @param prox Aponta a celula prox.
	 */
	Celula(int elemento, Celula prox) {
		this.elemento = elemento;
		this.prox = prox;
	}
}

/**
 * Lista dinamica simplesmente encadeada
 * @author Joao Paulo Domingos Silva
 * @version 1.1 02/2012
 */
public class Lista {
	private Celula primeiro; // Primeira celula: SEM elemento valido.
	private Celula ultimo; // Ultima celula: COM elemento valido.

	/**
	 * Construtor da classe: Instancia uma celula (primeira e ultima).
	 */
	public Lista() {
		primeiro = new Celula(-1);
		ultimo = primeiro;
	}

	/**
	 * Mostra os elementos separados por espacos.
	 */
	public void mostrar() {
		System.out.print("[ "); // Comeca a mostrar.
		for (Celula i = primeiro.prox; i != null; i = i.prox) {
			System.out.print(i.elemento + " ");
		}
		System.out.println("] "); // Termina de mostrar.
	}

	/**
	 * Procura um elemento e retorna se ele existe.
	 * @param x Elemento a pesquisar.
	 * @return <code>true</code> se o elemento existir,
	 * <code>false</code> em caso contrario.
	 */
	public boolean pesquisar(int x) {
		boolean retorno = false;
		for (Celula i = primeiro.prox; i != null; i = i.prox) {
         if(i.elemento == x){
            retorno = true;
            i = ultimo;
         }
		}
		return retorno;
	}

	/**
	 * Insere um elemento na primeira posicao da sequencia.
	 * @param elemento Elemento a inserir.
	 */
	public void inserirInicio(int elemento) {
		Celula tmp = new Celula(elemento);
      tmp.prox = primeiro.prox;
		primeiro.prox = tmp;
		if (primeiro == ultimo) {
			ultimo = tmp;
		}
      tmp = null;
	}

	/**
	 * Insere um elemento na ultima posicao da sequencia.
	 * @param elemento Elemento a inserir.
	 */
	public void inserirFim(int elemento) {
		Celula tmp = new Celula(elemento);
		ultimo.prox = tmp;
		ultimo = ultimo.prox;
      tmp = null;
	}

	/**
	 * Insere elemento em um indice especifico.
	 * Considera que primeiro elemento esta no indice 0.
	 * @param x Elemento a inserir.
	 * @param posicao Meio da insercao.
	 * @throws Exception Se <code>posicao</code> for incorreta.
	 */
   public void inserirMeio(int x, int posicao) throws Exception {
      Celula i;
      int cont;

		// Caminhar ate chegar na posicao anterior a insercao
      for(i = primeiro, cont = 0; (i.prox != ultimo && cont < posicao); i = i.prox, cont++);
		
		// Se indice for incorreto:
		if (posicao < 0 || posicao > cont + 1) {
			throw new Exception("Erro ao inserir (posicao " + posicao + "(cont = " + cont + ") invalida)!");

      } else if (posicao == cont + 1) {
         inserirFim(x);
		}else{
         Celula tmp = new Celula(x);
         tmp.prox = i.prox;
         i.prox = tmp;
         tmp = i = null;
      }
   }

	/**
	 * Remove um elemento da primeira posicao da sequencia.
	 * @return Elemento removido.
	 * @throws Exception Se a sequencia nao contiver elementos.
	 */
	public int removerInicio() throws Exception {
      int resp = -1;

		if (primeiro == ultimo) {
			throw new Exception("Erro ao remover (vazia)!");
		}else{
         primeiro = primeiro.prox;
         resp = primeiro.elemento;
      }

		return resp;
	}

	/**
	 * Remove um elemento da ultima posicao da sequencia.
	 * @return Elemento removido.
	 * @throws Exception Se a sequencia nao contiver elementos.
	 */
	public int removerFim() throws Exception {
      int resp =  -1;
      Celula i = null;

		if (primeiro == ultimo) {
			throw new Exception("Erro ao remover (vazia)!");
		} else {

         resp = ultimo.elemento;

		   // Caminhar ate a penultima celula:
         for(i = primeiro; i.prox != ultimo; i = i.prox);

         ultimo = i;
         i = ultimo.prox = null;
      }

		return resp;
	}

	/**
	 * Remove elemento de um indice especifico.
	 * Considera que primeiro elemento esta no indice 0.
	 * @param posicao Meio da remocao.
	 * @return Elemento removido.
	 * @throws Exception Se <code>posicao</code> for incorreta.
	 */
	public int removerMeio(int posicao) throws Exception {
      Celula i;
      int resp = -1, cont;

		if (primeiro == ultimo){
			throw new Exception("Erro ao remover (vazia)!");
      }else{

		   // Caminhar ate chegar na posicao anterior a insercao
         for(i = primeiro, cont = 0; (i.prox != ultimo && cont < posicao); i = i.prox, cont++);

         // Se indice for incorreto:
		   if (posicao < 0 || posicao > cont + 1) {
            throw new Exception("Erro ao remover (posicao " + posicao + " invalida)!");

         } else if (posicao == cont + 1) {
            resp = removerFim();
         }else{
            Celula tmp = i.prox;
            resp = tmp.elemento;
            i.prox = tmp.prox;
            tmp.prox = null;
            i = tmp = null;
         }
      }

		return resp;
	}
}

// Fim do arquivo: Lista.java

--------------------------------------------------------------------------------

// Início do arquivo: Hash.java

public class Hash {
   int tabela[];
   int m1, m2, m, reserva;
   final int NULO = -1;

   public Hash() {
      this(13, 7);
   }

   public Hash(int m1, int m2) {
      this.m1 = m1;
      this.m2 = m2;
      this.m = m1 + m2;
      this.tabela = new int[this.m];
      for (int i = 0; i < m1; i++) {
         tabela[i] = NULO;
      }
      reserva = 0;
   }

   public int h(int elemento) {
      return elemento % m1;
   }

   public boolean inserir(int elemento) {
      boolean resp = false;
      if (elemento != NULO) {
         int pos = h(elemento);
         if (tabela[pos] == NULO) {
            tabela[pos] = elemento;
            resp = true;
         } else if (reserva < m2) {
            tabela[m1 + reserva] = elemento;
            reserva++;
            resp = true;
         }
      }
      return resp;
   }

   public boolean pesquisar(int elemento) {
      boolean resp = false;
      int pos = h(elemento);
      if (tabela[pos] == elemento) {
         resp = true;
      } else if (tabela[pos] != NULO) {
         for (int i = 0; i < reserva; i++) {
            if (tabela[m1 + i] == elemento) {
               resp = true;
               i = reserva;
            }
         }
      }
      return resp;
   }

   boolean remover(int elemento) {
      boolean resp = false;
      // ...
      return resp;
   }
}

// Fim do arquivo: Hash.java

--------------------------------------------------------------------------------

// Início do arquivo: README.md
# U9 - Árvores TRIE
Repositório de códigos da disciplina de Algoritmos e Estrutura de Dados II

// Fim do arquivo: README.md

--------------------------------------------------------------------------------

// Início do arquivo: Principal.java
class Principal {
   public static void main (String[] args) throws Exception {
      ArvoreTrie arv = new ArvoreTrie();

      String array[] = new String[8];
      array[0] = "ABACAXI";
      array[1] = "BALA";
      array[2] = "BOLO";
      array[3] = "ABACATE";
      array[4] = "galo";
      array[5] = "pata";
      array[6] = "pato";
      array[7] = "gato";

      for(int i = 0; i < array.length; i++){
         arv.inserir(array[i]);
      }
      arv.mostrar();
      /*
      for(int i = 0; i < array.length; i++){
         System.out.println("Pesquisar(" + array[i] + "):" + arv.pesquisar(array[i]));
      }

      String s = "ABACA";
      System.out.println("Pesquisar(" + s + "):" + arv.pesquisar(s));

      s = "ABACAXIS";
      System.out.println("Pesquisar(" + s + "):" + arv.pesquisar(s));

      s = "gaga";
      System.out.println("Pesquisar(" + s + "):" + arv.pesquisar(s));
   */
      
   }
}

// Fim do arquivo: Principal.java

--------------------------------------------------------------------------------

// Início do arquivo: No.java
class No {
   public char elemento;
   public final int tamanho = 255;
   public No[] prox;
   public boolean folha;
   
   public No (){
      this(' ');
   }

   public No (char elemento){
      this.elemento = elemento;
      prox = new No [tamanho];
      for (int i = 0; i < tamanho; i++) prox[i] = null;
      folha = false;
   }

   public static int hash (char x){
      return (int)x;
   }
}

// Fim do arquivo: No.java

--------------------------------------------------------------------------------

// Início do arquivo: ArvoreTrie.java
class ArvoreTrie {
    private No raiz;

    public ArvoreTrie(){
        raiz = new No();
    }


    public boolean pesquisar(String s) throws Exception {
        return pesquisar(s, raiz, 0);
    }

    public boolean pesquisar(String s, No no, int i) throws Exception {
        boolean resp;
        if(no.prox[s.charAt(i)] == null){
            resp = false;
        } else if(i == s.length() - 1){
            resp = (no.prox[s.charAt(i)].folha == true);
        } else if(i < s.length() - 1 ){
            resp = pesquisar(s, no.prox[s.charAt(i)], i + 1);
        } else {
            throw new Exception("Erro ao pesquisar!");
        }
        return resp;
    }

    public void inserir(String s) throws Exception {
        inserir(s, raiz, 0);
    }

    private void inserir(String s, No no, int i) throws Exception {
        System.out.print("\nEM NO(" + no.elemento + ") (" + i + ")");
        if(no.prox[s.charAt(i)] == null){
            System.out.print("--> criando filho(" + s.charAt(i) + ")");
            no.prox[s.charAt(i)] = new No(s.charAt(i));

            if(i == s.length() - 1){
                System.out.print("(folha)");
                no.prox[s.charAt(i)].folha = true;
            }else{
                inserir(s, no.prox[s.charAt(i)], i + 1);
            }

        } else if (no.prox[s.charAt(i)].folha == false && i < s.length() - 1){
            inserir(s, no.prox[s.charAt(i)], i + 1);

        } else {
            throw new Exception("Erro ao inserir!");
        } 
    }

    public void mostrar(){
        mostrar("", raiz);
    }

    public void mostrar(String s, No no) {
        if(no.folha == true){
            System.out.println("Palavra: " + (s + no.elemento));
        } else {
            for(int i = 0; i < no.prox.length; i++){
                if(no.prox[i] != null){
                    System.out.println("ESTOU EM (" + no.elemento + ") E VOU PARA (" + no.prox[i].elemento + ")");
                    mostrar(s + no.elemento, no.prox[i]);
                }
            }
        }
    }

    public int contarAs(){
        int resp = 0;
        if(raiz != null){
            resp = contarAs(raiz);
        }
        return resp;
    }

    public int contarAs(No no) {
        int resp = (no.elemento == 'A') ? 1 : 0;

        if(no.folha == false){
            for(int i = 0; i < no.prox.length; i++){
                if(no.prox[i] != null){
                    resp += contarAs(no.prox[i]);
                }
            }
        }
        return resp;
    }
}


// Fim do arquivo: ArvoreTrie.java

--------------------------------------------------------------------------------

// Início do arquivo: Patricia.java
class Patricia {
   No raiz;
   String[] array; //ignorar questão de tamanho do array

   public Patricia(){
      raiz = new No();
      array = null;
   }

   public void setArray(String[] array) throws Exception {
      this.array = array;
      for(int i = 0; i < array.length; i++){
         inserir(i);
      }
   }

   private String string(No no){
      return (no == raiz) ? " " : string(no.i, no.j, no.k);
   }
   private String string(int i, int j, int k){
      //System.out.println("i("+i+") j("+j+") k("+k+") array(i)("+array[i]+") ijk(" + array[i].substring(j,k+1) + ")");
      return array[i].substring(j,k+1);
   }

   public void inserir(int i) throws Exception {
      System.out.print("\n==================================================== INSERINDO : " + array[i]);
      inserir(raiz, i, 0);
      mostrar();
   }
   private void inserir(No no, int i, int j) throws Exception {

      System.out.println("\nEM NO(" + string(no) + ") i("+ i +") j(" + j + ")");

      if(no.prox[array[i].charAt(j)] == null){
         no.prox[array[i].charAt(j)] = new No(i, j, array[i].length()-1, true);
         System.out.print("--> criando folha(" + array[i].charAt(j) + "/" + string(no.prox[array[i].charAt(j)]) + ")");

      } else {
         String prox = string(no.prox[array[i].charAt(j)]);
         String inserindo = array[i].substring(j);
         System.out.println("prox(" + prox + ") e inserindo(" + inserindo + ")");

         int k;
         for(k = 1; k < prox.length() && k < inserindo.length() && prox.charAt(k) == inserindo.charAt(k); k++);
         System.out.println("k (" + k + ")");

         if(k == prox.length()){
            if(no.prox[array[i].charAt(j)].folha == true){
               throw new Exception("Erro: exite um prefixo de [" + array[i] + "] na arvore");
            } else {
               inserir(no.prox[array[i].charAt(j)], i, j + k);
            }
         } else if (k == inserindo.length()){
            throw new Exception("Erro: [" + array[i] + "] é prefixo de outra palavra da árvore");
         } else {
            No novo = new No(i, j, j + k - 1, false);
            novo.prox[prox.charAt(k)] = no.prox[array[i].charAt(j)];
            novo.prox[prox.charAt(k)].j = j + k;
            novo.prox[inserindo.charAt(k)] = new No(i, j + k, array[i].length()-1, true);
            no.prox[array[i].charAt(j)] = novo;
            System.out.println("no(" + string(no) + ") e filhoNOVO(" + string(novo) + ") neto1(" + string(novo.prox[inserindo.charAt(k)]) + ") neto2(" + string(novo.prox[prox.charAt(k)]) + ")");
         }
      }
   }


   public boolean pesquisar(String s){
      System.out.println("\n==================================================== PESQUISAR: " + s);
      return pesquisar (raiz, s, 0);
   }
   public boolean pesquisar (No no, String s, int cont){
      boolean resp;

      System.out.println("EM NO(" + string(no) + ") s("+ s +") cont(" + cont + ") prox(" + no.prox[s.charAt(cont)] + ")");

      if(no.prox[s.charAt(cont)] == null){
         System.out.println("não existe filho para [" + s.charAt(cont) + "]");
         resp = false;
      } else {
         String prox = string(no.prox[s.charAt(cont)]);
         System.out.println("prox: " + prox);

         int i1, i2;
         for(i1 = 0, i2 = cont; i1 < prox.length() && i2 < s.length() && prox.charAt(i1) == s.charAt(i2); i1++, i2++);

         if(i2 == s.length()){
            System.out.println("resp = consumiuTodosOsCaracteresDeProx(" + (i1 == prox.length()) + ") and proxFolha(" + (no.prox[s.charAt(cont)].folha) + ")");
            resp = i1 == prox.length() && no.prox[s.charAt(cont)].folha;
         } else {
            resp = pesquisar(no.prox[s.charAt(cont)], s, i2);
         }
      }

      return resp;
   }

   public void mostrar(){
      System.out.println("\n==================================================== MOSTRAR: ");
      mostrar("", raiz);
   }

   public void mostrar(String s, No no) {
      if(no.folha == true){
         System.out.println("Palavra: " + (s + string(no)));
      } else {
         for(int i = 0; i < no.prox.length; i++){
            if(no.prox[i] != null){
               System.out.println("ESTOU EM (" + string(no) + ") E VOU PARA (" + string(no.prox[i]) + ")");
               mostrar(s + string(no), no.prox[i]);
            }
         }
      }
   }
   public int contarAs(){
      int resp = 0;
      if(raiz != null){
         resp = contarAs(raiz);
      }
      return resp;
   }

   public int contarAs(No no) {
      int resp = 0;
      String palavra = string(no);

      for(int i = 0; i < palavra.length(); i++){
         if(palavra.charat(i) == 'A'){
            resp++;
         }
      }

      if(no.folha == false){
         for(int i = 0; i < no.prox.length; i++){
            if(no.prox[i] != null){
               resp += contarAs(no.prox[i]);
            }
         }
      }
      return resp;
   }
}

// Fim do arquivo: Patricia.java

--------------------------------------------------------------------------------

// Início do arquivo: Principal.java
class Principal {
   public static void main (String[] args) throws Exception {
      Patricia arv = new Patricia();

      String array[] = new String[18];

      array[0] = "bear";
      array[1] = "bell";
      array[2] = "bid";
      array[3] = "bull";
      array[4] = "buy";
      array[5] = "sell";
      array[6] = "stock";
      array[7] = "stop";
      array[8] = "sapo";
      array[9] = "sapato";
      array[10] = "ABACAXI";
      array[11] = "BALA";
      array[12] = "BOLO";
      array[13] = "ABACATE";
      array[14] = "galo";
      array[15] = "pata";
      array[16] = "pato";
      array[17] = "gato";
      //array[17] = "ABAC";
      //array[17] = "ABACAXIS";
      arv.setArray(array);

      arv.mostrar();
      for(int i = 0; i < array.length; i++){
         System.out.println("Pesquisar(" + array[i] + "):" + arv.pesquisar(array[i]));
      }

      String s = "ABACA";
      System.out.println("Pesquisar(" + s + "):" + arv.pesquisar(s));

      s = "ABACAXIS";
      System.out.println("Pesquisar(" + s + "):" + arv.pesquisar(s));

      s = "gaga";
      System.out.println("Pesquisar(" + s + "):" + arv.pesquisar(s));

      s = "ABAC";
      System.out.println("Pesquisar(" + s + "):" + arv.pesquisar(s));
      
   }
}

// Fim do arquivo: Principal.java

--------------------------------------------------------------------------------

// Início do arquivo: No.java
class No {
   public int i, j, k;
   public int tamanho = 255;
   public No[] prox;
   public boolean folha;
   
   public No (){
      this(-1, -1, -1);
   }

   public No (int i, int j, int k){
      this(i, j, k, false);
   }

   public No (int i, int j, int k, boolean folha){
      this.i = i;
      this.j = j;
      this.k = k;
      this.folha = folha;

      prox = new No [tamanho];

      for (int l = 0; l < tamanho; l++){
         prox[l] = null;
      }
   }

   public static int hash (char x){
      return (int)x;
   }
}

// Fim do arquivo: No.java

--------------------------------------------------------------------------------

// Início do arquivo: Celula.java
/**
 * Celula (pilha, lista e fila flexivel)
 * @author Max do Val Machado
 * @version 2 01/2015
 */
class Celula {
	public char elemento; // Elemento inserido na celula.
	public Celula prox; // Aponta a celula prox.
   public No no;


	/**
	 * Construtor da classe.
	 */
	public Celula() {
      this.elemento = 0;
      this.prox = null;
      this.no = null;
	}

	/**
	 * Construtor da classe.
	 * @param elemento char inserido na celula.
	 */
	public Celula(char elemento) {
      this.elemento = elemento;
      this.prox = null;
      this.no = new No(elemento);
	}
}

// Fim do arquivo: Celula.java

--------------------------------------------------------------------------------

// Início do arquivo: oi

EM NO( ) (0)--> criando filho(A)
EM NO(A) (1)--> criando filho(B)
EM NO(B) (2)--> criando filho(A)
EM NO(A) (3)--> criando filho(C)
EM NO(C) (4)--> criando filho(A)
EM NO(A) (5)--> criando filho(X)
EM NO(X) (6)--> criando filho(I)(folha)
EM NO( ) (0)--> criando filho(B)
EM NO(B) (1)--> criando filho(A)
EM NO(A) (2)--> criando filho(L)
EM NO(L) (3)--> criando filho(A)(folha)
EM NO( ) (0)
EM NO(B) (1)--> criando filho(O)
EM NO(O) (2)--> criando filho(L)
EM NO(L) (3)--> criando filho(O)(folha)
EM NO( ) (0)
EM NO(A) (1)
EM NO(B) (2)
EM NO(A) (3)
EM NO(C) (4)
EM NO(A) (5)--> criando filho(T)
EM NO(T) (6)--> criando filho(E)(folha)
EM NO( ) (0)--> criando filho(g)
EM NO(g) (1)--> criando filho(a)
EM NO(a) (2)--> criando filho(l)
EM NO(l) (3)--> criando filho(o)(folha)
EM NO( ) (0)--> criando filho(p)
EM NO(p) (1)--> criando filho(a)
EM NO(a) (2)--> criando filho(t)
EM NO(t) (3)--> criando filho(a)(folha)
EM NO( ) (0)
EM NO(p) (1)
EM NO(a) (2)
EM NO(t) (3)--> criando filho(o)(folha)
EM NO( ) (0)
EM NO(g) (1)
EM NO(a) (2)--> criando filho(t)
EM NO(t) (3)--> criando filho(o)(folha)ESTOU EM ( ) E VOU PARA (A)
ESTOU EM (A) E VOU PARA (B)
ESTOU EM (B) E VOU PARA (A)
ESTOU EM (A) E VOU PARA (C)
ESTOU EM (C) E VOU PARA (A)
ESTOU EM (A) E VOU PARA (X)
ESTOU EM (X) E VOU PARA (I)
Palavra:  ABACAXI
ESTOU EM (A) E VOU PARA (T)
ESTOU EM (T) E VOU PARA (E)
Palavra:  ABACATE
ESTOU EM ( ) E VOU PARA (B)
ESTOU EM (B) E VOU PARA (A)
ESTOU EM (A) E VOU PARA (L)
ESTOU EM (L) E VOU PARA (A)
Palavra:  BALA
ESTOU EM (B) E VOU PARA (O)
ESTOU EM (O) E VOU PARA (L)
ESTOU EM (L) E VOU PARA (O)
Palavra:  BOLO
ESTOU EM ( ) E VOU PARA (g)
ESTOU EM (g) E VOU PARA (a)
ESTOU EM (a) E VOU PARA (l)
ESTOU EM (l) E VOU PARA (o)
Palavra:  galo
ESTOU EM (a) E VOU PARA (t)
ESTOU EM (t) E VOU PARA (o)
Palavra:  gato
ESTOU EM ( ) E VOU PARA (p)
ESTOU EM (p) E VOU PARA (a)
ESTOU EM (a) E VOU PARA (t)
ESTOU EM (t) E VOU PARA (a)
Palavra:  pata
ESTOU EM (t) E VOU PARA (o)
Palavra:  pato
Pesquisar(ABACAXI):true
Pesquisar(BALA):true
Pesquisar(BOLO):true
Pesquisar(ABACATE):true
Pesquisar(galo):true
Pesquisar(pata):true
Pesquisar(pato):true
Pesquisar(gato):true
Pesquisar(ABACA):false
Pesquisar(ABACAXIS):false
Pesquisar(gaga):false

// Fim do arquivo: oi

--------------------------------------------------------------------------------

// Início do arquivo: Principal.java
class Principal {
   public static void main (String[] args) throws Exception {
      ArvoreTrie arv = new ArvoreTrie();

      String array[] = new String[8];
      array[0] = "ABACAXI";
      array[1] = "BALA";
      array[2] = "BOLO";
      array[3] = "ABACATE";
      array[4] = "galo";
      array[5] = "pata";
      array[6] = "pato";
      array[7] = "gato";

      for(int i = 0; i < array.length; i++){
         arv.inserir(array[i]);
      }

      arv.mostrar();
      for(int i = 0; i < array.length; i++){
         System.out.println("Pesquisar(" + array[i] + "):" + arv.pesquisar(array[i]));
      }

      String s = "ABACA";
      System.out.println("Pesquisar(" + s + "):" + arv.pesquisar(s));

      s = "ABACAXIS";
      System.out.println("Pesquisar(" + s + "):" + arv.pesquisar(s));

      s = "gaga";
      System.out.println("Pesquisar(" + s + "):" + arv.pesquisar(s));
      
   }
}

// Fim do arquivo: Principal.java

--------------------------------------------------------------------------------

// Início do arquivo: No.java
class No {
   public char elemento;
	private Celula primeiro;
	private Celula ultimo;
   public boolean folha;
   
   public No (){
      this(' ');
   }

   public No (char elemento){
      this.elemento = elemento;
		ultimo = primeiro = new Celula();
      folha = false;
   }

   public No inserir(char x){
		ultimo.prox = new Celula(x);
		ultimo = ultimo.prox;
      return ultimo.no;
   }

   public No pesquisar(char x){
		No resp = null;
		for (Celula i = primeiro.prox; i != null; i = i.prox) {
         if(i.elemento == x){
            resp = i.no;
            i = ultimo;
         }
		}
		return resp;
   }

   public void setFilhoFolha(char x){
		for (Celula i = primeiro.prox; i != null; i = i.prox) {
         if(i.elemento == x){
            i.no.folha = true;
            i = ultimo;
         }
		}
   }

   public No[] getFilho(){
      int n = 0;
		for (Celula i = primeiro.prox; i != null; i = i.prox, n++);
      No[] vet = new No[n];

      n = 0;
		for (Celula i = primeiro.prox; i != null; i = i.prox){
         vet[n++] = i.no;
		}
      
      return vet;
   }

	public void mostrar() {
		System.out.print("[ ");
		for (Celula i = primeiro.prox; i != null; i = i.prox) {
			System.out.print(i.elemento + " ");
		}
		System.out.println("] ");
	}
}

// Fim do arquivo: No.java

--------------------------------------------------------------------------------

// Início do arquivo: ArvoreTrie.java
class ArvoreTrie {
    private No raiz;

    public ArvoreTrie(){
        raiz = new No();
    }

    public void inserir(String s) throws Exception {
        inserir(s, raiz, 0);
    }

    private void inserir(String s, No no, int i) throws Exception {
        System.out.print("\nEM NO(" + no.elemento + ") (" + i + ")");
        No filho = no.pesquisar(s.charAt(i));
        if(filho == null){
            System.out.print("--> criando filho(" + s.charAt(i) + ")");
            filho = no.inserir(s.charAt(i));

            if(i == s.length() - 1){
                System.out.print("(folha)");
                no.setFilhoFolha(s.charAt(i));
            }else{
                inserir(s, filho, i + 1);
            }

        } else if (filho.folha == false && i < s.length() - 1){
            inserir(s, filho, i + 1);

        } else {
            throw new Exception("Erro ao inserir!");
        } 
    }


    public boolean pesquisar(String s) throws Exception {
        return pesquisar(s, raiz, 0);
    }

    public boolean pesquisar(String s, No no, int i) throws Exception {
        boolean resp;
        No filho = no.pesquisar(s.charAt(i));
        if(filho == null){
            resp = false;
        } else if(i == s.length() - 1){
            resp = (filho.folha == true);
        } else if(i < s.length() - 1 ){
            resp = pesquisar(s, filho, i + 1);
        } else {
            throw new Exception("Erro ao pesquisar!");
        }
        return resp;
    }


    public void mostrar(){
        mostrar("", raiz);
    }

    public void mostrar(String s, No no) {
        if(no.folha == true){
            System.out.println("Palavra: " + (s + no.elemento));
        } else {
            No[] filho = no.getFilho();
            for(int i = 0; i < filho.length; i++){
                 System.out.println("ESTOU EM (" + no.elemento + ") E VOU PARA (" + filho[i].elemento + ")");
                 mostrar(s + no.elemento, filho[i]);
            }
        }
    }
}


// Fim do arquivo: ArvoreTrie.java

--------------------------------------------------------------------------------

// Início do arquivo: Principal.java
class Principal {
   public static void main (String[] args) throws Exception {
      ArvoreTrie arv = new ArvoreTrie();

      String array[] = new String[11];
      array[0] = "ABACAXI";
      array[1] = "BALA";
      array[2] = "BOLO";
      array[3] = "ABACATE";
      array[4] = "galo";
      array[5] = "pata";
      array[6] = "pato";
      array[7] = "gato";
      array[8] = "BAL";
      array[9] = "BA";
      array[10] = "BALAS";

      for(int i = 0; i < array.length; i++){
         arv.inserir(array[i]);
      }
      arv.mostrar();
      for(int i = 0; i < array.length; i++){
         System.out.println("Pesquisar(" + array[i] + "):" + arv.pesquisar(array[i]));
      }

      String s = "ABACA";
      System.out.println("Pesquisar(" + s + "):" + arv.pesquisar(s));

      s = "ABACAXIS";
      System.out.println("Pesquisar(" + s + "):" + arv.pesquisar(s));

      s = "gaga";
      System.out.println("Pesquisar(" + s + "):" + arv.pesquisar(s));
      
   }
}

// Fim do arquivo: Principal.java

--------------------------------------------------------------------------------

// Início do arquivo: No.java
class No {
   public char elemento;
   public int tamanho = 255;
   public No[] prox;
   public boolean folha;
   
   public No (){
      this(' ');
   }

   public No (char elemento){
      this.elemento = elemento;
      prox = new No [tamanho];
      for (int i = 0; i < tamanho; i++) prox[i] = null;
      folha = false;
   }

   public static int hash (char x){
      return (int)x;
   }
}

// Fim do arquivo: No.java

--------------------------------------------------------------------------------

// Início do arquivo: ArvoreTrie.java
class ArvoreTrie {
    private No raiz;

    public ArvoreTrie(){
        raiz = new No();
    }

    public void inserir(String s) throws Exception {
        inserir(s, raiz, 0);
    }

    private void inserir(String s, No no, int i) throws Exception {
        System.out.print("\nEM NO(" + no.elemento + ") (" + i + ")");
        if(no.prox[s.charAt(i)] == null){
            System.out.print("--> criando filho(" + s.charAt(i) + ")");
            no.prox[s.charAt(i)] = new No(s.charAt(i));

            if(i == s.length() - 1){
                System.out.print("(folha)");
                no.prox[s.charAt(i)].folha = true;
            }else{
                inserir(s, no.prox[s.charAt(i)], i + 1);
            }

        } else if (i < s.length() - 1){
            inserir(s, no.prox[s.charAt(i)], i + 1);

        } else if(i == s.length() - 1){
            System.out.print("(folha)");
            no.prox[s.charAt(i)].folha = true;
        } 
    }


    public boolean pesquisar(String s) throws Exception {
        return pesquisar(s, raiz, 0);
    }

    public boolean pesquisar(String s, No no, int i) throws Exception {
        boolean resp;
        if(no.prox[s.charAt(i)] == null){
            resp = false;
        } else if(i == s.length() - 1){
            resp = (no.prox[s.charAt(i)].folha == true);
        } else if(i < s.length() - 1 ){
            resp = pesquisar(s, no.prox[s.charAt(i)], i + 1);
        } else {
            throw new Exception("Erro ao pesquisar!");
        }
        return resp;
    }


    public void mostrar(){
        mostrar("", raiz);
    }

    public void mostrar(String s, No no) {
        if(no.folha == true){
            System.out.println("Palavra: " + (s + no.elemento));
        }

        for(int i = 0; i < no.prox.length; i++){
                if(no.prox[i] != null){
                    System.out.println("ESTOU EM (" + no.elemento + ") E VOU PARA (" + no.prox[i].elemento + ")");
                    mostrar(s + no.elemento, no.prox[i]);
            }
        }
        
    }
}


// Fim do arquivo: ArvoreTrie.java

--------------------------------------------------------------------------------

// Início do arquivo: NoAB.java
class NoAB {
	public char elemento;
	public NoAB esq, dir;
   public No no;


	/**
	 * Construtor da classe.
	 */
	public NoAB() {
      this.elemento = 0;
      this.esq = null;
      this.dir = null;
      this.no = null;
	}

	/**
	 * Construtor da classe.
	 * @param elemento char inserido na celula.
	 */
	public NoAB(char elemento) {
      this.elemento = elemento;
      this.esq = null;
      this.dir = null;
      this.no = new No(elemento);
	}
}

// Fim do arquivo: NoAB.java

--------------------------------------------------------------------------------

// Início do arquivo: Principal.java
class Principal {
   public static void main (String[] args) throws Exception {
      ArvoreTrie arv = new ArvoreTrie();

      String array[] = new String[8];
      array[0] = "ABACAXI";
      array[1] = "BALA";
      array[2] = "BOLO";
      array[3] = "ABACATE";
      array[4] = "galo";
      array[5] = "pata";
      array[6] = "pato";
      array[7] = "gato";

      for(int i = 0; i < array.length; i++){
         arv.inserir(array[i]);
      }

      arv.mostrar();
      for(int i = 0; i < array.length; i++){
         System.out.println("Pesquisar(" + array[i] + "):" + arv.pesquisar(array[i]));
      }

      String s = "ABACA";
      System.out.println("Pesquisar(" + s + "):" + arv.pesquisar(s));

      s = "ABACAXIS";
      System.out.println("Pesquisar(" + s + "):" + arv.pesquisar(s));

      s = "gaga";
      System.out.println("Pesquisar(" + s + "):" + arv.pesquisar(s));
      
   }
}

// Fim do arquivo: Principal.java

--------------------------------------------------------------------------------

// Início do arquivo: No.java
class No {
   public char elemento;
	private NoAB raiz;
   public boolean folha;
   
   public No (){
      this(' ');
   }

   public No (char elemento){
      this.elemento = elemento;
		raiz = null;
      folha = false;
   }

   public No inserir(char x) throws Exception {
		raiz = inserir(x, raiz);
      return pesquisar(x);
	}

	private NoAB inserir(char x, NoAB i) throws Exception {
		if (i == null) {
         i = new NoAB(x);

      } else if (x < i.elemento) {
         i.esq = inserir(x, i.esq);

      } else if (x > i.elemento) {
         i.dir = inserir(x, i.dir);

      } else {
         throw new Exception("Erro ao inserir!");
      }

		return i;
	}

	public No pesquisar(char x) {
		return pesquisar(x, raiz);
	}

	private No pesquisar(int x, NoAB i) {
      No resp;
		if (i == null) {
         resp = null;

      } else if (x == i.elemento) {
         resp = i.no;

      } else if (x < i.elemento) {
         resp = pesquisar(x, i.esq);

      } else {
         resp = pesquisar(x, i.dir);
      }
      return resp;
	}

   public void setFilhoFolha(char x){
      setFilhoFolha(x, raiz);
   }
   public void setFilhoFolha(char x, NoAB i){
		if (i == null) {
         //nada...

      } else if (x == i.elemento) {
         i.no.folha = true;

      } else if (x < i.elemento) {
         setFilhoFolha(x, i.esq);

      } else {
         setFilhoFolha(x, i.dir);
      }
   }

	public int getN() {
      return getN(raiz);
	}
	private int getN(NoAB i) {
      int resp = 0;
		if (i != null) {
         resp = 1 + getN(i.esq) + getN(i.dir);
		}
      return resp;
	}

   public No[] getFilho(){
      int n = getN();
      No[] vet = new No[n];
      getFilho(vet, 0, raiz);
      return vet;
   }

   public int getFilho(No[] vet, int pos, NoAB i){
      if(i != null){
         vet[pos++] = i.no;
         pos = getFilho(vet, pos, i.esq);
         pos = getFilho(vet, pos, i.dir);
      }
      return pos;
   }
}

// Fim do arquivo: No.java

--------------------------------------------------------------------------------

// Início do arquivo: ArvoreTrie.java
class ArvoreTrie {
    private No raiz;

    public ArvoreTrie(){
        raiz = new No();
    }

    public void inserir(String s) throws Exception {
        inserir(s, raiz, 0);
    }

    private void inserir(String s, No no, int i) throws Exception {
        System.out.print("\nEM NO(" + no.elemento + ") (" + i + ")");
        No filho = no.pesquisar(s.charAt(i));
        if(filho == null){
            System.out.print("--> criando filho(" + s.charAt(i) + ")");
            filho = no.inserir(s.charAt(i));

            if(i == s.length() - 1){
                System.out.print("(folha)");
                no.setFilhoFolha(s.charAt(i));
            }else{
                inserir(s, filho, i + 1);
            }

        } else if (filho.folha == false && i < s.length() - 1){
            inserir(s, filho, i + 1);

        } else {
            throw new Exception("Erro ao inserir!");
        } 
    }


    public boolean pesquisar(String s) throws Exception {
        return pesquisar(s, raiz, 0);
    }

    public boolean pesquisar(String s, No no, int i) throws Exception {
        boolean resp;
        No filho = no.pesquisar(s.charAt(i));
        if(filho == null){
            resp = false;
        } else if(i == s.length() - 1){
            resp = (filho.folha == true);
        } else if(i < s.length() - 1 ){
            resp = pesquisar(s, filho, i + 1);
        } else {
            throw new Exception("Erro ao pesquisar!");
        }
        return resp;
    }


    public void mostrar(){
        mostrar("", raiz);
    }

    public void mostrar(String s, No no) {
        if(no.folha == true){
            System.out.println("Palavra: " + (s + no.elemento));
        } else {
            No[] filho = no.getFilho();
            for(int i = 0; i < filho.length; i++){
                 System.out.println("ESTOU EM (" + no.elemento + ") E VOU PARA (" + filho[i].elemento + ")");
                 mostrar(s + no.elemento, filho[i]);
            }
        }
    }
}


// Fim do arquivo: ArvoreTrie.java

--------------------------------------------------------------------------------

// Início do arquivo: README.md
# U7 - Balanceamento de árvores
Repositório de códigos da disciplina de Algoritmos e Estrutura de Dados II

// Fim do arquivo: README.md

--------------------------------------------------------------------------------

// Início do arquivo: AVL.java
/**
 * Arvore binaria de pesquisa
 * @author Max do Val Machado
 */

public class AVL {
	private No raiz; // Raiz da arvore.

	/**
	 * Construtor da classe.
	 */
	public AVL() {
		raiz = null;
	}

	/**
	 * Metodo publico iterativo para pesquisar elemento.
	 * @param x Elemento que sera procurado.
	 * @return <code>true</code> se o elemento existir, <code>false</code> em caso
	 *         contrario.
	 */
	public boolean pesquisar(int x) {
		return pesquisar(x, raiz);
	}

	/**
	 * Metodo privado recursivo para pesquisar elemento.
	 * @param x Elemento que sera procurado.
	 * @param i No em analise.
	 * @return <code>true</code> se o elemento existir, <code>false</code> em caso
	 *         contrario.
	 */
	private boolean pesquisar(int x, No i) {
		boolean resp;
		if (i == null) {
			resp = false;
		} else if (x == i.elemento) {
			resp = true;
		} else if (x < i.elemento) {
			resp = pesquisar(x, i.esq);
		} else {
			resp = pesquisar(x, i.dir);
		}
		return resp;
	}

	/**
	 * Metodo publico iterativo para exibir elementos.
	 */
	public void caminharCentral() {
		System.out.print("[ ");
		caminharCentral(raiz);
		System.out.println("]");
	}

	/**
	 * Metodo privado recursivo para exibir elementos.
	 * @param i No em analise.
	 */
	private void caminharCentral(No i) {
		if (i != null) {
			caminharCentral(i.esq); // Elementos da esquerda.
			System.out.print(i.elemento + " "); // Conteudo do no.
			caminharCentral(i.dir); // Elementos da direita.
		}
	}

	/**
	 * Metodo publico iterativo para exibir elementos.
	 */
	public void caminharPre() {
		System.out.print("[ ");
		caminharPre(raiz);
		System.out.println("]");
	}

	/**
	 * Metodo privado recursivo para exibir elementos.
	 * @param i No em analise.
	 */
	private void caminharPre(No i) {
		if (i != null) {
			System.out.print(i.elemento + "(fator " + (No.getNivel(i.dir) - No.getNivel(i.esq)) + ") "); // Conteudo do no.
			caminharPre(i.esq); // Elementos da esquerda.
			caminharPre(i.dir); // Elementos da direita.
		}
	}

	/**
	 * Metodo publico iterativo para exibir elementos.
	 */
	public void caminharPos() {
		System.out.print("[ ");
		caminharPos(raiz);
		System.out.println("]");
	}

	/**
	 * Metodo privado recursivo para exibir elementos.
	 * @param i No em analise.
	 */
	private void caminharPos(No i) {
		if (i != null) {
			caminharPos(i.esq); // Elementos da esquerda.
			caminharPos(i.dir); // Elementos da direita.
			System.out.print(i.elemento + " "); // Conteudo do no.
		}
	}

	/**
	 * Metodo publico iterativo para inserir elemento.
	 * @param x Elemento a ser inserido.
	 * @throws Exception Se o elemento existir.
	 */
	public void inserir(int x) throws Exception {
		raiz = inserir(x, raiz);
	}

	/**
	 * Metodo privado recursivo para inserir elemento.
	 * @param x Elemento a ser inserido.
	 * @param i No em analise.
	 * @return No em analise, alterado ou nao.
	 * @throws Exception Se o elemento existir.
	 */
	private No inserir(int x, No i) throws Exception {
		if (i == null) {
			i = new No(x);
		} else if (x < i.elemento) {
			i.esq = inserir(x, i.esq);
		} else if (x > i.elemento) {
			i.dir = inserir(x, i.dir);
		} else {
			throw new Exception("Erro ao inserir!");
		}
		return balancear(i);
	}

	/**
	 * Metodo publico iterativo para remover elemento.
	 * @param x Elemento a ser removido.
	 * @throws Exception Se nao encontrar elemento.
	 */
	public void remover(int x) throws Exception {
		raiz = remover(x, raiz);
	}

	/**
	 * Metodo privado recursivo para remover elemento. 
	 * @param x Elemento a ser removido.
	 * @param i No em analise.
	 * @return No em analise, alterado ou nao.
	 * @throws Exception Se nao encontrar elemento.
	 */
	private No remover(int x, No i) throws Exception {
		if (i == null) {
			throw new Exception("Erro ao remover!");
		} else if (x < i.elemento) {
			i.esq = remover(x, i.esq);
		} else if (x > i.elemento) {
			i.dir = remover(x, i.dir);
		// Sem no a direita.
		} else if (i.dir == null) {
			i = i.esq;
		// Sem no a esquerda.
		} else if (i.esq == null) {
			i = i.dir;
		// No a esquerda e no a direita.
		} else {
			i.esq = maiorEsq(i, i.esq);
		}
		return balancear(i);
	}

	/**
	 * Metodo para trocar o elemento "removido" pelo maior da esquerda.
	 * @param i No que teve o elemento removido.
	 * @param j No da subarvore esquerda.
	 * @return No em analise, alterado ou nao.
	 */
	private No maiorEsq(No i, No j) {
		// Encontrou o maximo da subarvore esquerda.
		if (j.dir == null) {
			i.elemento = j.elemento; // Substitui i por j.
			j = j.esq; // Substitui j por j.ESQ.
		// Existe no a direita.
		} else {
			// Caminha para direita.
			j.dir = maiorEsq(i, j.dir);
		}
		return j;
	}

	private No balancear(No no) throws Exception {
		if (no != null) {
			int fator = No.getNivel(no.dir) - No.getNivel(no.esq);
			// Se balanceada
			if (Math.abs(fator) <= 1) {
				no.setNivel();
			// Se desbalanceada para a direita
			} else if (fator == 2) {
				int fatorFilhoDir = No.getNivel(no.dir.dir) - No.getNivel(no.dir.esq);
				// Se o filho a direita tambem estiver desbalanceado
				if (fatorFilhoDir == -1) {
					no.dir = rotacionarDir(no.dir);
				}
				no = rotacionarEsq(no);
			// Se desbalanceada para a esquerda
			} else if (fator == -2) {
				int fatorFilhoEsq = No.getNivel(no.esq.dir) - No.getNivel(no.esq.esq);
				// Se o filho a esquerda tambem estiver desbalanceado
				if (fatorFilhoEsq == 1) {
					no.esq = rotacionarEsq(no.esq);
				}
				no = rotacionarDir(no);
			} else {
				throw new Exception(
						"Erro no No(" + no.elemento + ") com fator de balanceamento (" + fator + ") invalido!");
			}
		}
		return no;
	}

	private No rotacionarDir(No no) {
		System.out.println("Rotacionar DIR(" + no.elemento + ")");
		No noEsq = no.esq;
		No noEsqDir = noEsq.dir;

		noEsq.dir = no;
		no.esq = noEsqDir;
		no.setNivel(); // Atualizar o nivel do no
		noEsq.setNivel(); // Atualizar o nivel do noEsq

		return noEsq;
	}

	private No rotacionarEsq(No no) {
		System.out.println("Rotacionar ESQ(" + no.elemento + ")");
		No noDir = no.dir;
		No noDirEsq = noDir.esq;

		noDir.esq = no;
		no.dir = noDirEsq;

		no.setNivel(); // Atualizar o nivel do no
		noDir.setNivel(); // Atualizar o nivel do noDir
		return noDir;
	}
}

// Fim do arquivo: AVL.java

--------------------------------------------------------------------------------

// Início do arquivo: Principal.java
/**
 * Principal para Arvore Binaria de Pesquisa
 * @author Max do Val Machado
 */
public class Principal {
	public static void main(String[] args) {
		try {
			AVL avl = new AVL();
			//int array[] = {4,35,10,13,3,30,15,12,7,40,20};
			int array[] = {1,2,3,4,5,6,7,8,9,10};
			for(int item: array){
				System.out.println("Inserindo -> " + item);
				avl.inserir(item);
				avl.caminharPre();
			}
		} catch (Exception erro) {
			System.out.println(erro.getMessage());
		}
	}
}

// Fim do arquivo: Principal.java

--------------------------------------------------------------------------------

// Início do arquivo: No.java
/**
 * No da arvore binaria
 * @author Max do Val Machado
 */
class No {
	public int elemento; // Conteudo do no.
	public No esq, dir; // Filhos da esq e dir.
	public int nivel; // Numero de niveis abaixo do no

	/**
	 * Construtor da classe
	 * @param elemento Conteudo do no.
	 */
	public No(int elemento) {
		this(elemento, null, null, 1);
	}

	/**
	 * Construtor da classe.
	 * @param elemento Conteudo do no.
	 * @param esq      No da esquerda.
	 * @param dir      No da direita.
	 */
	public No(int elemento, No esq, No dir, int nivel) {
		this.elemento = elemento;
		this.esq = esq;
		this.dir = dir;
		this.nivel = nivel;
	}

	/**
	 * Cálculo do número de níveis a partir de um vértice
	 */
	public void setNivel() {
		this.nivel = 1 + Math.max(getNivel(esq), getNivel(dir));
	}

	/**
	 * Retorna o número de níveis a partir de um vértice
	 * @param no nó que se deseja o nível.
	 */
	public static int getNivel(No no) {
		return (no == null) ? 0 : no.nivel;
	}
}

// Fim do arquivo: No.java

--------------------------------------------------------------------------------

// Início do arquivo: AVL.java
/**
 * Arvore binaria de pesquisa
 * @author Max do Val Machado
 */

 public class AVL extends ArvoreBinaria{

	/**
	 * Construtor da classe.
	 */
	public AVL() {
		super();
	}

	/**
	 * Metodo publico iterativo para inserir elemento.
	 * @param x Elemento a ser inserido.
	 * @throws Exception Se o elemento existir.
	 */
	public void inserirAVL(int x) throws Exception {
		raiz = inserirAVL(x, raiz);
	}

	/**
	 * Metodo privado recursivo para inserir elemento.
	 * @param x Elemento a ser inserido.
	 * @param i No em analise.
	 * @return No em analise, alterado ou nao.
	 * @throws Exception Se o elemento existir.
	 */
	private No inserirAVL(int x, No i) throws Exception {
		if (i == null) {
			i = new No(x);
		} else if (x < i.elemento) {
			i.esq = inserirAVL(x, i.esq);
		} else if (x > i.elemento) {
			i.dir = inserirAVL(x, i.dir);
		} else {
			throw new Exception("Erro ao inserir!");
		}
		return balancear(i);
	}

	private No balancear(No no) throws Exception {
		if (no != null) {
			int fator = No.getNivel(no.dir) - No.getNivel(no.esq);
			// Se balanceada
			if (Math.abs(fator) <= 1) {
				no.setNivel();
			// Se desbalanceada para a direita
			} else if (fator == 2) {
				int fatorFilhoDir = No.getNivel(no.dir.dir) - No.getNivel(no.dir.esq);
				// Se o filho a direita tambem estiver desbalanceado
				if (fatorFilhoDir == -1) {
					no.dir = rotacionarDir(no.dir);
				}
				no = rotacionarEsq(no);
			// Se desbalanceada para a esquerda
			} else if (fator == -2) {
				int fatorFilhoEsq = No.getNivel(no.esq.dir) - No.getNivel(no.esq.esq);
				// Se o filho a esquerda tambem estiver desbalanceado
				if (fatorFilhoEsq == 1) {
					no.esq = rotacionarEsq(no.esq);
				}
				no = rotacionarDir(no);
			} else {
				throw new Exception(
						"Erro no No(" + no.elemento + ") com fator de balanceamento (" + fator + ") invalido!");
			}
		}
		return no;
	}

	private No rotacionarDir(No no) {
		System.out.println("Rotacionar DIR(" + no.elemento + ")");
		No noEsq = no.esq;
		No noEsqDir = noEsq.dir;

		noEsq.dir = no;
		no.esq = noEsqDir;
		no.setNivel(); // Atualizar o nivel do no
		noEsq.setNivel(); // Atualizar o nivel do noEsq

		return noEsq;
	}

	private No rotacionarEsq(No no) {
		System.out.println("Rotacionar ESQ(" + no.elemento + ")");
		No noDir = no.dir;
		No noDirEsq = noDir.esq;

		noDir.esq = no;
		no.dir = noDirEsq;

		no.setNivel(); // Atualizar o nivel do no
		noDir.setNivel(); // Atualizar o nivel do noDir
		return noDir;
	}

}

// Fim do arquivo: AVL.java

--------------------------------------------------------------------------------

// Início do arquivo: ArvoreBinaria.java
/**
 * Arvore binaria de pesquisa
 * 
 * @author Max do Val Machado
 */
public class ArvoreBinaria {
	protected No raiz; // Raiz da arvore.

	/**
	 * Construtor da classe.
	 */
	public ArvoreBinaria() {
		raiz = null;
	}

	/**
	 * Metodo publico iterativo para pesquisar elemento.
	 * 
	 * @param x Elemento que sera procurado.
	 * @return <code>true</code> se o elemento existir,
	 *         <code>false</code> em caso contrario.
	 */
	public boolean pesquisar(int x) {
		return pesquisar(x, raiz);
	}

	/**
	 * Metodo privado recursivo para pesquisar elemento.
	 * 
	 * @param x Elemento que sera procurado.
	 * @param i No em analise.
	 * @return <code>true</code> se o elemento existir,
	 *         <code>false</code> em caso contrario.
	 */
	private boolean pesquisar(int x, No i) {
		boolean resp;
		if (i == null) {
			resp = false;

		} else if (x == i.elemento) {
			resp = true;

		} else if (x < i.elemento) {
			resp = pesquisar(x, i.esq);

		} else {
			resp = pesquisar(x, i.dir);
		}
		return resp;
	}

	/**
	 * Metodo publico iterativo para exibir elementos.
	 */
	public void caminharCentral() {
		System.out.print("[ ");
		caminharCentral(raiz);
		System.out.println("]");
	}

	/**
	 * Metodo privado recursivo para exibir elementos.
	 * 
	 * @param i No em analise.
	 */
	private void caminharCentral(No i) {
		if (i != null) {
			caminharCentral(i.esq); // Elementos da esquerda.
			System.out.print(i.elemento + " "); // Conteudo do no.
			caminharCentral(i.dir); // Elementos da direita.
		}
	}

	/**
	 * Metodo publico iterativo para exibir elementos.
	 */
	public void caminharPre() {
		System.out.print("[ ");
		caminharPre(raiz);
		System.out.println("]");
	}

	/**
	 * Metodo privado recursivo para exibir elementos.
	 * 
	 * @param i No em analise.
	 */
	private void caminharPre(No i) {
		if (i != null) {
			System.out.print(i.elemento + " "); // Conteudo do no.
			caminharPre(i.esq); // Elementos da esquerda.
			caminharPre(i.dir); // Elementos da direita.
		}
	}

	/**
	 * Metodo publico iterativo para exibir elementos.
	 */
	public void caminharPos() {
		System.out.print("[ ");
		caminharPos(raiz);
		System.out.println("]");
	}

	/**
	 * Metodo privado recursivo para exibir elementos.
	 * 
	 * @param i No em analise.
	 */
	private void caminharPos(No i) {
		if (i != null) {
			caminharPos(i.esq); // Elementos da esquerda.
			caminharPos(i.dir); // Elementos da direita.
			System.out.print(i.elemento + " "); // Conteudo do no.
		}
	}

	/**
	 * Metodo publico iterativo para inserir elemento.
	 * 
	 * @param x Elemento a ser inserido.
	 * @throws Exception Se o elemento existir.
	 */
	public void inserir(int x) throws Exception {
		raiz = inserir(x, raiz);
	}

	/**
	 * Metodo privado recursivo para inserir elemento.
	 * 
	 * @param x Elemento a ser inserido.
	 * @param i No em analise.
	 * @return No em analise, alterado ou nao.
	 * @throws Exception Se o elemento existir.
	 */
	protected No inserir(int x, No i) throws Exception {
		if (i == null) {
			i = new No(x);
		} else if (x < i.elemento) {
			i.esq = inserir(x, i.esq);
		} else if (x > i.elemento) {
			i.dir = inserir(x, i.dir);
		} else {
			throw new Exception("Erro ao inserir!");
		}
		return i;
	}

	/**
	 * Metodo publico para inserir elemento.
	 * 
	 * @param x Elemento a ser inserido.
	 * @throws Exception Se o elemento existir.
	 */
	public void inserirPai(int x) throws Exception {
		if (raiz == null) {
			raiz = new No(x);
		} else if (x < raiz.elemento) {
			inserirPai(x, raiz.esq, raiz);
		} else if (x > raiz.elemento) {
			inserirPai(x, raiz.dir, raiz);
		} else {
			throw new Exception("Erro ao inserirPai!");
		}
	}

	/**
	 * Metodo privado recursivo para inserirPai elemento.
	 * 
	 * @param x   Elemento a ser inserido.
	 * @param i   No em analise.
	 * @param pai No superior ao em analise.
	 * @throws Exception Se o elemento existir.
	 */
	private void inserirPai(int x, No i, No pai) throws Exception {
		if (i == null) {
			if (x < pai.elemento) {
				pai.esq = new No(x);
			} else {
				pai.dir = new No(x);
			}
		} else if (x < i.elemento) {
			inserirPai(x, i.esq, i);
		} else if (x > i.elemento) {
			inserirPai(x, i.dir, i);
		} else {
			throw new Exception("Erro ao inserirPai!");
		}
	}

	/**
	 * Metodo publico iterativo para remover elemento.
	 * 
	 * @param x Elemento a ser removido.
	 * @throws Exception Se nao encontrar elemento.
	 */
	public void remover(int x) throws Exception {
		raiz = remover(x, raiz);
	}

	/**
	 * Metodo privado recursivo para remover elemento.
	 * 
	 * @param x Elemento a ser removido.
	 * @param i No em analise.
	 * @return No em analise, alterado ou nao.
	 * @throws Exception Se nao encontrar elemento.
	 */
	protected No remover(int x, No i) throws Exception {
		if (i == null) {
			throw new Exception("Erro ao remover!");
		} else if (x < i.elemento) {
			i.esq = remover(x, i.esq);
		} else if (x > i.elemento) {
			i.dir = remover(x, i.dir);
			// Sem no a direita.
		} else if (i.dir == null) {
			i = i.esq;
			// Sem no a esquerda.
		} else if (i.esq == null) {
			i = i.dir;
			// No a esquerda e no a direita.
		} else {
			i.esq = maiorEsq(i, i.esq);
		}
		return i;
	}

	/**
	 * Metodo para trocar o elemento "removido" pelo maior da esquerda.
	 * 
	 * @param i No que teve o elemento removido.
	 * @param j No da subarvore esquerda.
	 * @return No em analise, alterado ou nao.
	 */
	protected No maiorEsq(No i, No j) {
		// Encontrou o maximo da subarvore esquerda.
		if (j.dir == null) {
			i.elemento = j.elemento; // Substitui i por j.
			j = j.esq; // Substitui j por j.ESQ.

			// Existe no a direita.
		} else {
			// Caminha para direita.
			j.dir = maiorEsq(i, j.dir);
		}
		return j;
	}

	/**
	 * Metodo que retorna o maior elemento da árvore
	 * 
	 * @return int maior elemento da árvore
	 */
	public int getMaior() {
		int resp = -1;

		if (raiz != null) {
			No i;
			for (i = raiz; i.dir != null; i = i.dir)
				;
			resp = i.elemento;
		}

		return resp;
	}

	/**
	 * Metodo que retorna o menor elemento da árvore
	 * 
	 * @return int menor elemento da árvore
	 */
	public int getMenor() {
		int resp = -1;

		if (raiz != null) {
			No i;
			for (i = raiz; i.esq != null; i = i.esq)
				;
			resp = i.elemento;
		}

		return resp;
	}

	/**
	 * Metodo que retorna a altura da árvore
	 * @return int altura da árvore
	 */
	public int getAltura() {
		return getAltura(raiz, 0);
	}

	/**
	 * Metodo que retorna a altura da árvore
	 * @return int altura da árvore
	 */
	public int getAltura(No i, int altura) {
		if (i == null) {
			altura--;
		} else {
			int alturaEsq = getAltura(i.esq, altura + 1);
			int alturaDir = getAltura(i.dir, altura + 1);
			altura = (alturaEsq > alturaDir) ? alturaEsq : alturaDir;
		}
		return altura;
	}

	/**
	 * Metodo publico iterativo para remover elemento.
	 * 
	 * @param x Elemento a ser removido.
	 * @throws Exception Se nao encontrar elemento.
	 */
	public void remover2(int x) throws Exception {
		if (raiz == null) {
			throw new Exception("Erro ao remover2!");
		} else if (x < raiz.elemento) {
			remover2(x, raiz.esq, raiz);
		} else if (x > raiz.elemento) {
			remover2(x, raiz.dir, raiz);
		} else if (raiz.dir == null) {
			raiz = raiz.esq;
		} else if (raiz.esq == null) {
			raiz = raiz.dir;
		} else {
			raiz.esq = maiorEsq(raiz, raiz.esq);
		}
	}

	/**
	 * Metodo privado recursivo para remover elemento.
	 * 
	 * @param x   Elemento a ser removido.
	 * @param i   No em analise.
	 * @param pai do No em analise.
	 * @throws Exception Se nao encontrar elemento.
	 */
	private void remover2(int x, No i, No pai) throws Exception {
		if (i == null) {
			throw new Exception("Erro ao remover2!");
		} else if (x < i.elemento) {
			remover2(x, i.esq, i);
		} else if (x > i.elemento) {
			remover2(x, i.dir, i);
		} else if (i.dir == null) {
			pai = i.esq;
		} else if (i.esq == null) {
			pai = i.dir;
		} else {
			i.esq = maiorEsq(i, i.esq);
		}
	}

	public int getRaiz() throws Exception {
		return raiz.elemento;
	}

	public static boolean igual(ArvoreBinaria a1, ArvoreBinaria a2) {
		return igual(a1.raiz, a2.raiz);
	}

	private static boolean igual(No i1, No i2) {
		boolean resp;
		if (i1 != null && i2 != null) {
			resp = (i1.elemento == i2.elemento) && igual(i1.esq, i2.esq) && igual(i1.dir, i2.dir);
		} else if (i1 == null && i2 == null) {
			resp = true;
		} else {
			resp = false;
		}
		return resp;
	}

	public int soma() {
		return soma(raiz);
	}

	public int soma(No i) {
		int resp = 0;
		if (i != null) {
			resp = i.elemento + soma(i.esq) + soma(i.dir);
		}
		return resp;
	}

	public int quantidadePares() {
		return quantidadePares(raiz);
	}

	public int quantidadePares(No i) {
		int resp = 0;
		if (i != null) {
			resp = ((i.elemento % 2 == 0) ? 1 : 0) + quantidadePares(i.esq) + quantidadePares(i.dir);
		}
		return resp;
	}

	public boolean hasDiv11() {
		return hasDiv11(raiz);
	}

	public boolean hasDiv11(No i) {
		boolean resp = false;
		if (i != null) {
			resp = (i.elemento % 11 == 0) || hasDiv11(i.esq) || hasDiv11(i.dir);
		}
		return resp;
	}
}

// Fim do arquivo: ArvoreBinaria.java

--------------------------------------------------------------------------------

// Início do arquivo: Principal.java
/**
 * Principal para Arvore Binaria de Pesquisa
 * @author Max do Val Machado
 */
public class Principal {
	public static void main(String[] args) {
		try {
			AVL avl = new AVL();
			ArvoreBinaria ab = new ArvoreBinaria();
			int array[] = {4,35,10,13,3,30,15,12,7,40,20};
			for (int item : array) {
				//System.out.println("Inserindo -> " + item);
				avl.inserirAVL(item);
				ab.inserir(item);
			}

			System.out.println("Altura da AVL: " + avl.getAltura());
			System.out.println("Altura da ABP: " + ab.getAltura());

		} catch (Exception erro) {
			System.out.println(erro.getMessage());
		}
	}
}

// Fim do arquivo: Principal.java

--------------------------------------------------------------------------------

// Início do arquivo: No.java
/**
 * No da arvore binaria
 * @author Max do Val Machado
 */
class No {
	public int elemento; // Conteudo do no.
	public No esq, dir; // Filhos da esq e dir.
	public int nivel; // Numero de niveis abaixo do no

	/**
	 * Construtor da classe
	 * @param elemento Conteudo do no.
	 */
	public No(int elemento) {
		this(elemento, null, null, 1);
	}

	/**
	 * Construtor da classe.
	 * @param elemento Conteudo do no.
	 * @param esq      No da esquerda.
	 * @param dir      No da direita.
	 */
	public No(int elemento, No esq, No dir, int nivel) {
		this.elemento = elemento;
		this.esq = esq;
		this.dir = dir;
		this.nivel = nivel;
	}

	/**
	 * Cálculo do número de níveis a partir de um vértice
	 */
	public void setNivel() {
		this.nivel = 1 + Math.max(getNivel(esq), getNivel(dir));
	}

	/**
	 * Retorna o número de níveis a partir de um vértice
	 * @param no nó que se deseja o nível.
	 */
	public static int getNivel(No no) {
		return (no == null) ? 0 : no.nivel;
	}
}

// Fim do arquivo: No.java

--------------------------------------------------------------------------------

// Início do arquivo: Principal.java
/**
 * Principal para Arvore Binaria de Pesquisa
 * 
 * @author Max do Val Machado
 */
public class Principal {
   public static void main(String[] args) throws Exception {
      Alvinegra arvore = new Alvinegra();

      /*
       * arvore.inserir(1);
       * arvore.inserir(2);
       * arvore.inserir(3);
       * arvore.mostrarPre();
       * 
       * arvore = new Alvinegra();
       * arvore.inserir(1);
       * arvore.inserir(3);
       * arvore.inserir(2);
       * arvore.mostrarPre();
       * 
       * arvore = new Alvinegra();
       * arvore.inserir(2);
       * arvore.inserir(1);
       * arvore.inserir(3);
       * arvore.mostrarPre();
       * 
       * arvore = new Alvinegra();
       * arvore.inserir(2);
       * arvore.inserir(3);
       * arvore.inserir(1);
       * arvore.mostrarPre();
       * 
       * arvore = new Alvinegra();
       * arvore.inserir(3);
       * arvore.inserir(1);
       * arvore.inserir(2);
       * arvore.mostrarPre();
       * 
       * arvore = new Alvinegra();
       * arvore.inserir(3);
       * arvore.inserir(2);
       * arvore.inserir(1);
       * arvore.mostrarPre();
       */
      arvore.inserir(4);
      arvore.caminharPre();
      arvore.inserir(35);
      arvore.caminharPre();
      arvore.inserir(10);
      arvore.caminharPre();
      arvore.inserir(13);
      arvore.caminharPre();
      arvore.inserir(3);
      arvore.caminharPre();
      arvore.inserir(30);
      arvore.caminharPre();
      arvore.inserir(15);
      arvore.caminharPre();
      arvore.inserir(12);
      arvore.caminharPre();
      arvore.inserir(7);
      arvore.caminharPre();
      arvore.inserir(40);
      arvore.caminharPre();
      arvore.inserir(20);
      arvore.caminharPre();

      /*
       * arvore = new Alvinegra();
       * Random gerador = new Random();
       * gerador.setSeed(4);
       * for(int i = 0; i < 4000; i++){
       * int elemento;
       * do {
       * elemento = ((int)Math.abs(gerador.nextInt())) % 100000;
       * } while (arvore.pesquisar(elemento) == true);
       * arvore.inserir(elemento);
       * arvore.mostrarPre();
       * }
       */
   }
}

// Fim do arquivo: Principal.java

--------------------------------------------------------------------------------

// Início do arquivo: NoAN.java
/**
 * NoAN da arvore binaria
 * 
 * @author Max do Val Machado
 */
class NoAN {
  public boolean cor;
  public int elemento;
  public NoAN esq, dir;

  public NoAN() {
    this(-1);
  }

  public NoAN(int elemento) {
    this(elemento, false, null, null);
  }

  public NoAN(int elemento, boolean cor) {
    this(elemento, cor, null, null);
  }

  public NoAN(int elemento, boolean cor, NoAN esq, NoAN dir) {
    this.cor = cor;
    this.elemento = elemento;
    this.esq = esq;
    this.dir = dir;
  }
}

// Fim do arquivo: NoAN.java

--------------------------------------------------------------------------------

// Início do arquivo: Alvinegra.java
/**
 * Arvore binaria de pesquisa
 * 
 * @author Max do Val Machado
 */
public class Alvinegra {
   private NoAN raiz; // Raiz da arvore.

   /**
    * Construtor da classe.
    */
   public Alvinegra() {
      raiz = null;
   }

   /**
    * Metodo publico iterativo para pesquisar elemento.
    * 
    * @param elemento Elemento que sera procurado.
    * @return <code>true</code> se o elemento existir,
    *         <code>false</code> em caso contrario.
    */
   public boolean pesquisar(int elemento) {
      return pesquisar(elemento, raiz);
   }

   /**
    * Metodo privado recursivo para pesquisar elemento.
    * 
    * @param elemento Elemento que sera procurado.
    * @param i        NoAN em analise.
    * @return <code>true</code> se o elemento existir,
    *         <code>false</code> em caso contrario.
    */
   private boolean pesquisar(int elemento, NoAN i) {
      boolean resp;
      if (i == null) {
         resp = false;
      } else if (elemento == i.elemento) {
         resp = true;
      } else if (elemento < i.elemento) {
         resp = pesquisar(elemento, i.esq);
      } else {
         resp = pesquisar(elemento, i.dir);
      }
      return resp;
   }

   /**
    * Metodo publico iterativo para exibir elementos.
    */
   public void caminharCentral() {
      System.out.print("[ ");
      caminharCentral(raiz);
      System.out.println("]");
   }

   /**
    * Metodo privado recursivo para exibir elementos.
    * 
    * @param i NoAN em analise.
    */
   private void caminharCentral(NoAN i) {
      if (i != null) {
         caminharCentral(i.esq); // Elementos da esquerda.
         System.out.print(i.elemento + ((i.cor) ? "(p) " : "(b) ")); // Conteudo do no.
         caminharCentral(i.dir); // Elementos da direita.
      }
   }

   /**
    * Metodo publico iterativo para exibir elementos.
    */
   public void caminharPre() {
      System.out.print("[ ");
      caminharPre(raiz);
      System.out.println("]");
   }

   /**
    * Metodo privado recursivo para exibir elementos.
    * 
    * @param i NoAN em analise.
    */
   private void caminharPre(NoAN i) {
      if (i != null) {
         System.out.print(i.elemento + ((i.cor) ? "(p) " : "(b) ")); // Conteudo do no.
         caminharPre(i.esq); // Elementos da esquerda.
         caminharPre(i.dir); // Elementos da direita.
      }
   }

   /**
    * Metodo publico iterativo para exibir elementos.
    */
   public void caminharPos() {
      System.out.print("[ ");
      caminharPos(raiz);
      System.out.println("]");
   }

   /**
    * Metodo privado recursivo para exibir elementos.
    * 
    * @param i NoAN em analise.
    */
   private void caminharPos(NoAN i) {
      if (i != null) {
         caminharPos(i.esq); // Elementos da esquerda.
         caminharPos(i.dir); // Elementos da direita.
         System.out.print(i.elemento + ((i.cor) ? "(p) " : "(b) ")); // Conteudo do no.
      }
   }

   /**
    * Metodo publico iterativo para inserir elemento.
    * 
    * @param elemento Elemento a ser inserido.
    * @throws Exception Se o elemento existir.
    */
   public void inserir(int elemento) throws Exception {
      // Se a arvore estiver vazia
      if (raiz == null) {
         raiz = new NoAN(elemento);
         System.out.println("Antes, zero elementos. Agora, raiz(" + raiz.elemento + ").");

      // Senao, se a arvore tiver um elemento
      } else if (raiz.esq == null && raiz.dir == null) {
         if (elemento < raiz.elemento) {
            raiz.esq = new NoAN(elemento);
            System.out.println("Antes, um elemento. Agora, raiz(" + raiz.elemento + ") e esq(" + raiz.esq.elemento + ").");
         } else {
            raiz.dir = new NoAN(elemento);
            System.out.println("Antes, um elemento. Agora, raiz(" + raiz.elemento + ") e dir(" + raiz.dir.elemento + ").");
         }

      // Senao, se a arvore tiver dois elementos (raiz e dir)
      } else if (raiz.esq == null) {
         if (elemento < raiz.elemento) {
            raiz.esq = new NoAN(elemento);
            System.out.println("Antes, dois elementos(A). Agora, raiz(" + raiz.elemento + "), esq (" + raiz.esq.elemento + ") e dir(" + raiz.dir.elemento + ").");

         } else if (elemento < raiz.dir.elemento) {
            raiz.esq = new NoAN(raiz.elemento);
            raiz.elemento = elemento;
            System.out.println("Antes, dois elementos(B). Agora, raiz(" + raiz.elemento + "), esq (" + raiz.esq.elemento + ") e dir(" + raiz.dir.elemento + ").");

         } else {
            raiz.esq = new NoAN(raiz.elemento);
            raiz.elemento = raiz.dir.elemento;
            raiz.dir.elemento = elemento;
            System.out.println("Antes, dois elementos(C). Agora, raiz(" + raiz.elemento + "), esq (" + raiz.esq.elemento + ") e dir(" + raiz.dir.elemento + ").");
         }
         raiz.esq.cor = raiz.dir.cor = false;

      // Senao, se a arvore tiver dois elementos (raiz e esq)
      } else if (raiz.dir == null) {
         if (elemento > raiz.elemento) {
            raiz.dir = new NoAN(elemento);
            System.out.println("Antes, dois elementos(D). Agora, raiz(" + raiz.elemento + "), esq (" + raiz.esq.elemento + ") e dir(" + raiz.dir.elemento + ").");

         } else if (elemento > raiz.esq.elemento) {
            raiz.dir = new NoAN(raiz.elemento);
            raiz.elemento = elemento;
            System.out.println("Antes, dois elementos(E). Agora, raiz(" + raiz.elemento + "), esq (" + raiz.esq.elemento + ") e dir(" + raiz.dir.elemento + ").");

         } else {
            raiz.dir = new NoAN(raiz.elemento);
            raiz.elemento = raiz.esq.elemento;
            raiz.esq.elemento = elemento;
            System.out.println("Antes, dois elementos(F). Agora, raiz(" + raiz.elemento + "), esq (" + raiz.esq.elemento + ") e dir(" + raiz.dir.elemento + ").");
         }
         raiz.esq.cor = raiz.dir.cor = false;

      // Senao, a arvore tem tres ou mais elementos
      } else {
         System.out.println("Arvore com tres ou mais elementos...");
         inserir(elemento, null, null, null, raiz);
      }
      raiz.cor = false;
   }

   private void balancear(NoAN bisavo, NoAN avo, NoAN pai, NoAN i) {
      // Se o pai tambem e preto, reequilibrar a arvore, rotacionando o avo
      if (pai.cor == true) {
         // 4 tipos de reequilibrios e acoplamento
         if (pai.elemento > avo.elemento) { // rotacao a esquerda ou direita-esquerda
            if (i.elemento > pai.elemento) {
               avo = rotacaoEsq(avo);
            } else {
               avo = rotacaoDirEsq(avo);
            }
         } else { // rotacao a direita ou esquerda-direita
            if (i.elemento < pai.elemento) {
               avo = rotacaoDir(avo);
            } else {
               avo = rotacaoEsqDir(avo);
            }
         }
         if (bisavo == null) {
            raiz = avo;
         } else if (avo.elemento < bisavo.elemento) {
            bisavo.esq = avo;
         } else {
            bisavo.dir = avo;
         }
         // reestabelecer as cores apos a rotacao
         avo.cor = false;
         avo.esq.cor = avo.dir.cor = true;
         System.out.println("Reestabeler cores: avo(" + avo.elemento + "->branco) e avo.esq / avo.dir("
               + avo.esq.elemento + "," + avo.dir.elemento + "-> pretos)");
      } // if(pai.cor == true)
   }

   /**
    * Metodo privado recursivo para inserir elemento.
    * 
    * @param elemento Elemento a ser inserido.
    * @param avo      NoAN em analise.
    * @param pai      NoAN em analise.
    * @param i        NoAN em analise.
    * @throws Exception Se o elemento existir.
    */
   private void inserir(int elemento, NoAN bisavo, NoAN avo, NoAN pai, NoAN i) throws Exception {
      if (i == null) {
         if (elemento < pai.elemento) {
            i = pai.esq = new NoAN(elemento, true);
         } else {
            i = pai.dir = new NoAN(elemento, true);
         }
         if (pai.cor == true) {
            balancear(bisavo, avo, pai, i);
         }
      } else {
         // Achou um 4-no: eh preciso fragmeta-lo e reequilibrar a arvore
         if (i.esq != null && i.dir != null && i.esq.cor == true && i.dir.cor == true) {
            i.cor = true;
            i.esq.cor = i.dir.cor = false;
            if (i == raiz) {
               i.cor = false;
            } else if (pai.cor == true) {
               balancear(bisavo, avo, pai, i);
            }
         }
         if (elemento < i.elemento) {
            inserir(elemento, avo, pai, i, i.esq);
         } else if (elemento > i.elemento) {
            inserir(elemento, avo, pai, i, i.dir);
         } else {
            throw new Exception("Erro inserir (elemento repetido)!");
         }
      }
   }

   private NoAN rotacaoDir(NoAN no) {
      System.out.println("Rotacao DIR(" + no.elemento + ")");
      NoAN noEsq = no.esq;
      NoAN noEsqDir = noEsq.dir;

      noEsq.dir = no;
      no.esq = noEsqDir;

      return noEsq;
   }

   private NoAN rotacaoEsq(NoAN no) {
      System.out.println("Rotacao ESQ(" + no.elemento + ")");
      NoAN noDir = no.dir;
      NoAN noDirEsq = noDir.esq;

      noDir.esq = no;
      no.dir = noDirEsq;
      return noDir;
   }

   private NoAN rotacaoDirEsq(NoAN no) {
      no.dir = rotacaoDir(no.dir);
      return rotacaoEsq(no);
   }

   private NoAN rotacaoEsqDir(NoAN no) {
      no.esq = rotacaoEsq(no.esq);
      return rotacaoDir(no);
   }
}

// Fim do arquivo: Alvinegra.java

--------------------------------------------------------------------------------

// Início do arquivo: Oi.java
boolean isNoTipo4(NoAN i){
   return (i.esq != null && i.dir != null && i.esq.cor == true && i.dir.cor == true);
}

// Fim do arquivo: Oi.java

--------------------------------------------------------------------------------

